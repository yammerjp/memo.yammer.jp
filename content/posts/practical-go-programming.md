---
title: "実用Go言語を少し読む"
date: "2023-05-01T08:07:40+09:00"
tags: [ "Go", "本", "一週間読書" ]
---

3冊目は実用Go言語。1〜6, 8〜11, 13, 16章と付録と、一部は飛ばしたものの、前から順番に読んでいったし、これまでの本よりは読んだ分量が多め。Goで開発するにあたって必要になるトピックを全体的に取りこぼしなく抑えておきたかったので、読む章が増えていった。

[実用Go言語 (オライリー・ジャパン発行、IDBN978-4-87311-969-4) 渋川よしき、辻大志郎、真野隼記 著](https://www.oreilly.co.jp/books/9784873119694/)

なお、この記事内で上記の書籍を引用するときは、ページ番号のみ記載している。

## 印象に残ったところ

本を読みながら整理されたGoの知識をメモがてら記していく。

### Go Modulesとライブラリ管理、Go製ツールのインストール

インターネットの適当な文献をみつつ開発していて、ライブラリ管理をあんまりわかっていないと思いながら進めていたので、あらためて整理されてよかった。このあたりがあんまりわかっていなかったのは、おそらく古い文献に示されているやり方と今の方法が異なるからだろう。`GOPATH`、`go mod`、`go install`のあたりが整理された。

#### `go mod`

Goでは、1.16[^go-1-16]からデフォルトになったGo Modulesでライブラリ管理を行う。GitHub上で公開されているモジュール名は`github.com/gorilla/mux`などのように、外部公開されるものはFQDNを含んだ一意なものにする慣習がある。

開発する上では以下のようなコマンドを実行することになる。

- `go mod init <モジュール名>` ... `go.mod`を自動生成する
- `go get -u <モジュール名>` ... ライブラリを`go.mod`ファイルに記録し、モジュールをインストールする
- `go mod tidy` ... モジュールの追加ソースコード上にimportを記述/削除してから実行すると、ライブラリが追加/更新/削除される

6.4.3項「ドメイン/レイヤー vs レイヤー/ドメイン」では、モジュール分割の方針が示されていた。ざっくりと「レイヤーよりもドメインで分けることが望ましい」と書かれていたが、詳細は書籍を参照されたい。言語仕様や記述の方法から踏み込んで、こういった方針を示してもらえるのはありがたい。

[^go-1-16]: 2021/02にリリースされたようである。結構最近。(といいつつ2年前か) https://groups.google.com/g/golang-announce/c/q-exD-8mG3w

#### `go install`

ライブラリではなく開発時に使うGo製のツールは`go install <パッケージ名>@<バージョン>`でインストールできる。このとき`go.mod`に影響を与えることはない。過去には`go get`で実行バイナリのインストールもできたが、それは過去のものである。

#### `GOPATH`

Go Moduleが利用されるようになるより前は、環境変数`GOPATH`を設定し、`GOPATH`下にライブラリのパッケージが配置されて管理されていたようである。一方で、現在はGOPATHを変更することで管理を多重化するのは一般的ではないようである。

この本は著者が日本人の方で、訳書ではなく原著が日本語なので、以下のような文書の書きっぷりは読んでいてわかりやすいしちょっと楽しい。このほかの箇所でも、色のある表現が使われていて読み進めやすかった。

> 乱暴ですが、「GOPATHは過去のもの」、と考えて問題ありません。環境変数で上書きもできますが、現在は`HOME/go`、あるいはWindowsであれば`%USERPROFILE%/go`がデフォルト値となっています。この下に、ダウンロードしたサードパーティーのモジュールやパッケージがダウンロードされます。
> (p119)

### ブランクインポート

Goでは、パッケージ内に定義された`init()`関数が、プログラムのエントリポイントである`main()`よりも前に実行される。[^go-init]この初期化処理を利用したいが、ライブラリの実装を直接呼び出さないとき、ブランクインポートが使える。ブランクインポートとは、`import ( _ <パッケージ名> )`のような記述のことで、パッケージを読み込むが、参照できない状態とすることである。

書籍の中で紹介されていた例は、PostgreSQLのドライバを使うが、アプリケーションの実装は`database/sql`パッケージ(ドライバを抽象化した標準的なインタフェース)のみに依存させたいときのものであった。

[^go-init]: 参考: [init関数のふしぎ #golang - Qiita](https://qiita.com/tenntenn/items/7c70e3451ac783999b4f)

### チャネル

`go f()`と書くだけで実行できる、Goの特徴の一つでもある軽量な平行処理のしくみであるgoroutineと合わせて使われるのが、チャネルである。[チャネル](https://go-tour-jp.appspot.com/concurrency/2)はgoroutine間の通信に利用できる。

TODO: チャネルは...

TODO: selectは... 以下のように書ける。

```go
select {
case <-recv:
    log.Println("受信があったこと or チャネルのクローズを感知 (どちらか判断はできない、値は捨てる)")
case v := <-recv2:
    log.Println("受信があったこと or チャネルのクローズを感知 (どちらか判断はできない、値は受け取る):", v)
case v, ok := <-recv3:
    log.Println("受信があったこと or チャネルのクローズを感知 (チャネルの状態と値は受け取る):", v, ok)
case send <- 10:
    log.Println("送信が成功したことを検知")
default:
    log.Println("どのチャネルの送受信も行われなかった")
}
// https://github.com/oreilly-japan/practical-go-programming/blob/f81e93abb8c899bab8c809b695ea7a2c13b5f5cd/ch16/select/main.go#L21-L32
```

### context

contextは、Goのコードを書いていて時々出会うが、雰囲気で使っていると感じていた。この本を読んで最も整理されたものに思う。contextの概要は書籍の元[^future-blog]になったと思われる次の記事がわかりやすい。

> コンテキストを受け取る関数は、処理に長い時間のかかる関数です。もし呼び出し側の都合で中断させたいときにcontextを使います。時間がかかるという点では、他の言語で言う所のasync関数と同じようなものと言えます。
> 引用元: [Goを学ぶときにつまずきやすいポイントFAQ - Future Tech Blog](https://future-architect.github.io/articles/20190713/#Q-%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E9%96%A2%E6%95%B0%E3%81%A3%E3%81%A6%E3%81%A9%E3%82%93%E3%81%AA%E3%82%82%E3%81%AE%E3%81%AA%E3%82%93%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%81%8B%EF%BC%9F)

書籍の中では、Contextの使い方を以下の2つに整理している。

> - 1セッションから派生する全ての処理をまとめてキャンセルする(タイムアウトでの終了も含む)
> - 1セッションの中で共有される情報を保持する
> (p379)

並行処理をどのように扱うかは言語ごとの差が出やすい部分だろう。私はJavaScriptのasnyc/await, Promiseがイメージしやすい[^single-thread]のだが、Goではgoroutineによる並行処理間での通信にチャネルを使い、このチャネルを利用しやすいものにラップしたのがContextである、というふうに理解した。

処理の中断だけでなく、key-valueをもたせられるので、そのセッション(並行される処理の1つ)内で共有したい情報の保持にも用いられる。例えばWebアプリケーションサーバは多数のHTTPリクエストを短い時間に受け付けるが、それぞれのリクエストごとに保持したい情報を、contextに保持しておくなどが考えられる。

[^future-blog]: 著者の方の講演で、ブログ記事にしたものをもとに書籍をつくっていると語られている。紹介した当該記事それ自体が直接書籍になったとは明言されていないが、おそらく書籍の題材の一つであろう。https://pr.forkwell.com/event/practical-go-lang/
[^single-thread]: もっとも、JavaScriptはシングルスレッドで実行されるので、並行処理といえども並列処理は単体では扱わない。Goは並列処理も扱えるので、複雑度のより高い問題を扱っているという違いがある。

### その他のトピック

だんだんブログ記事が長くなってきたので、その他のトピックは箇条書きに留めておく。

- 他のパッケージで定義された形にはメソッドを実装できない (p39)
- .や_で始まるファイルや、testdataというディレクトリの中身はGoコンパイル対象外 (p119)
- ゼロ値とnilを区別したいときはポインター型を使う (p236) (そのほかJSONの章やDBの章でも出てくる)
- JSONをGoの構造体にマッピングするとき、プライベートな構造体のフィールドは、外部のデコードライブラリからはアクセスできないために、デコード結果が代入されない落とし穴がある。(pp170-171)
- HTTPハンドラーが`ResponseWriter`と`*Request`を引数にもち、HTTPハンドラーをメソッドとしてもつインタフェースを定義することで、ミドルウェアやルーティングの仕組みを形づくり、Webサーバに向いたアーキテクチャを作れるようになっている。型にメソッドを実装する活用例として、HandlerFuncと Handlerインタフェースが紹介されている (p232)

## おわりに

今回は、記事を書くのがちょっと難しかった。前回までは、感想や、読書の進め方みたいなのを書いていたのだが、この本は具体的な技術情報の解説本であるので、本から学んだこともおのずと「本に書いてあるGoの使い方を学びました」となってしまいがちであった。

書籍の内容をブログにすることの是非については「[ブログに技術書の内容を丸写しする問題点と、オリジナルなコンテンツを書くためのアイデア - give IT a try](https://blog.jnito.com/entry/2018/01/23/075856)」という記事の意見がとても参考になる。本を読んだ後、自分なりにまとめてみると知識の定着に繋がるし、どうせならそれを手の内に留めておくのは勿体無いと思うので、余裕がある時はこうやって文章を残していきたい。加えて、こういった本の感想記事が、読んだ人の購買意欲を高めて本を買うことにつながれば、著者や出版社に貢献できて悪いことはないだろう、と思う。
