{"title":"memo.yammer.jp","home_page_url":"http://localhost:3000","feed_url":"http://localhost:3000/json_feed","description":"常に完成形","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"language":"ja","expired":false,"_feed_url_rss2":"http://localhost:3000/posts/index.xml","items":[{"id":"http://localhost:3000/posts/database-specialist-examination","url":"http://localhost:3000/posts/database-specialist-examination","title":"情報処理技術者試験にはミックスサンド (DBスペシャリスト試験を受けました)","summary":"2021/10/10に令和3年度秋期データベーススペシャリスト試験を受験しました。 情報処理技術者試験は通算4回目、高度情報は2回目 (春にネットワークスペシャリスト落ち)、データベーススペシャリストは今回が初でした。 合格したので、この度晴れてみくりさんと結婚できる権利を得ました。 \\#逃げ恥 リストラ候補の津崎平匡さんの資格欄「応用情報技術者、データベーススペシャリスト、基本情報技術者」 - togetter 以下、対策したことを記録します。 参考書 いままではインプレスの過去問題集を毎度買っていたのですが、今回は翔泳社の「うかる！データベーススペシャリスト」を購入しました。 結果からいう","date_published":"2021-12-19T17:13:00+09:00","date_modified":"2021-12-19T19:11:33+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93%E3%81%AB%E3%81%AF%E3%83%9F%E3%83%83%E3%82%AF%E3%82%B9%E3%82%B5%E3%83%B3%E3%83%89%20(DB%E3%82%B9%E3%83%9A%E3%82%B7%E3%83%A3%E3%83%AA%E3%82%B9%E3%83%88%E8%A9%A6%E9%A8%93%E3%82%92%E5%8F%97%E3%81%91%E3%81%BE%E3%81%97%E3%81%9F),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記","データベース","情報処理技術者試験"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/21ce18f2d691845f444f1c1fcdbadd37fa2b097a","comment":"Fix: 表記を統一\n","date_modified":"2021-12-19T19:11:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a8b6af4aae30ec190bce92f0b5718846002a157d","comment":"Post:「情報処理技術者試験にはミックスサンド (DBスペシャリスト試験を受けました)\"」\n","date_modified":"2021-12-19T08:14:02+00:00"}],"content_html":"<p>2021/10/10に令和3年度秋期データベーススペシャリスト試験を受験しました。\n情報処理技術者試験は通算4回目、高度情報は2回目 (春にネットワークスペシャリスト落ち)、データベーススペシャリストは今回が初でした。</p>\n<p>合格したので、この度晴れてみくりさんと結婚できる権利を得ました。</p>\n<p><a href=\"https://togetter.com/li/1058081\">#逃げ恥 リストラ候補の津崎平匡さんの資格欄「応用情報技術者、データベーススペシャリスト、基本情報技術者」 - togetter</a></p>\n<p>以下、対策したことを記録します。</p>\n<h2>参考書</h2>\n<p>いままではインプレスの過去問題集を毎度買っていたのですが、今回は翔泳社の「うかる！データベーススペシャリスト」を購入しました。</p>\n<p>結果からいうとこれは大正解で、午後問題の解説がめちゃくちゃ丁寧なので知識があまりない状態でも解説から吸収することができました。\nインプレスの過去問題集は、ネットワークスペシャリストの午後問題を勉強しているときに解説がサラッとしすぎていてわからんなあという気持ちになっていました。\n「うかる！データベーススペシャリスト」には各問題のパターンと解き方も参考書に丁寧に解説されているので、試験申し込んだときに一読し、あとで解くときに読み直すと良いように思います。</p>\n<p>インプレスの過去問題集は書籍自体をPDFダウンロードできるのが気に入って前回まで買っていました。\n翔泳社の書籍の電子版はKindleで販売されていますが、こういう参考書は書き込んでなんぼなのでKindleアプリ上で勉強するのは厳しいものがあります。\nPDFでの販売をしてくれるとより買いやすくなるのですが...</p>\n<h2>試験勉強の時間軸</h2>\n<p>試験勉強を始めたのは申込みをした8月中旬からでした。\n参考書を前からざっくり読んだ後、問題演習として初めに取り組んだのは午前Ⅱ対策です。\n1分半程度で解く規模の問題なので軽い気持ちで勉強しやすく、知識中心なのでまずはこれから手を付けました。</p>\n<p>9月に入った頃に午前Ⅱ対策を終わりにして午後対策に移りました。\n午後Ⅱは1問解くのに2時間かかるので、休日に午後Ⅱ、平日に午後Iとして、並行して過去問を解いていました。\nしかしながら特に午後Ⅱはとにかく文章が長いしやってると眠くなるし、この頃からモチベーションも薄れてきて勉強ペースが落ちがちに。\n結局参考書で紹介された再重要問題の半分くらい解いたところで試験前日になりまして、残りの問題は解説を読んで雰囲気を掴んで当日を迎えました。</p>\n<p>情報処理技術者試験は申し込んだとき一番モチベーションが高い気がします。\n毎度試験会場は半分〜7割くらいしかいないのでみんなそんな感じなんじゃないかな。\n申込時のモチベーションとその勢いでどこまで勉強できるか、それをどれだけ維持できるかが大事なのかなと思っています。</p>\n<h2>各試験区分の対策と感想</h2>\n<h3>午前Ⅰ</h3>\n<p>応用情報技術者試験を受けたのが2年以上前なので午前1の免除はありませんでした。\nいけるやろ」と無勉強で望んだのものの意外とと解けない問題もありました。\nさらに大々的にマークミスをしていまい、少し危なっかしい点数でした。\n問題番号と解答用紙のマーク位置はよく確認しましょう。</p>\n<h3>午前Ⅱ</h3>\n<p>午前Ⅱは選択式の問題で、データベースに関連する幅広い知識が問われます。\n対策としては参考書についてくる200問を繰り返し解いていました。\nデータベース何もわからん人間でSQLすら怪しい状態でしたが、間違えたところに絞りながら2,3周すればそこそこ解けるようになりました。</p>\n<p>SQLはどうやって学べばええんやというときは、PostgreSQLやMySQLの日本語ドキュメントを参考にすることが多かったです。\n参考書では簡潔に書かれ読み取れないことも含めて丁寧に書かれており読みやすい内容でした。\n(それが標準SQLであるかは確認する必要があります。)</p>\n<p>情報処理技術者試験の選択問題対策はどれも範囲が広いので雑にググって知らない言葉をなんとなく頭に入れておくのがよいと思っているのですが、ことSQLにおいては信頼できなさそうな量産ブログがたくさん引っかかるので最初から的を絞った方がよかったです。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>今思えばSQLに関する本を一冊買うなどしてもよかったように思います。</p>\n<h3>午後I</h3>\n<p>午後Iの問題は出題形式がいろいろありますが、一部の問題は午後IIをコンパクトにしたようなものもあります。\n午後Ⅱの対策をある程度進めてから午後Iに取り掛かった方が効率が良いように思います。</p>\n<h3>午後Ⅱ</h3>\n<p>参考書によるとデータベーススペシャリストの午後Ⅱは出題形式が定番になっていて、前述の通りその問題が出来ないと受からないかつそれが出来れば午後I対策にもなるとのこと。\n午後Ⅱのもっとも定番な問題である概念データモデルと関係スキーマに関する問題を何問か解いていきました。\n業務ロジックが文章で説明されており、未完成の概念データモデルと関係スキーマを完成させるのが主な問題の内容です。</p>\n<p>が、この問題、とにかく問題の文章量が多い。\n1問あたり12ページくらいあります。\niPadではページ切り替えが多すぎて厳しいので印刷して紙でやったほうがいいでしょう。</p>\n<h2>試験のためのTips</h2>\n<h3>概念データモデルの記法</h3>\n<p>午後問題では概念データモデルが必ず出てきます。\nそれぞれの記号に関する意味は注意書きとして試験問題の前半に書いてありますが、これは例年同じものです。</p>\n<p>午後問題の勉強を始めるときに初めに時間をとってじっくり読むことをお勧めします。\nこの記法にしたがって概念データモデルを書く問題も頻出です。\n私は読まずに問題を解いていて、対策中盤くらいまでなんだかよくわからない記法が使われているなあという気持ちになっていました。</p>\n<h3>午後Ⅱ開始前の...</h3>\n<p>当日は各試験区分が始まる15分くらい前から説明が始まります。\n午前中は受験票の回収がありますが、午後にもなると説明や準備もすぐに終わって解答開始まで10分くらい無の時間が訪れます。\n携帯も切って参考書も閉まったあとで、じっと座っているだけの時間です。</p>\n<p>ここの時間は空想をするくらいしかないと思っていたのですが、午後IIには未完成の概念データモデルを埋める定番問題があります。\nこれを解くにはたくさんの問題文から情報を抽出して回答する必要があるので全体を掴んでおくと結構よかったりします。\nそしてこの問題は解答用紙に未完成の図が書いてあるので、試験開始前になんとなく問題に出てくる用語とその関係を見ることができてしまいます。ます😜</p>\n<h2>おわりに</h2>\n<p>データベーススペシャリストに合格したところで実際の業務上でわからないことは沢山あると思いますが、ひとまず一定の知識を習得できた意味で受験してよかったです。</p>\n<p>タイトルのミックスサンドは試験当日に食べたお昼のメニューです。\n情報処理技術者試験の試験会場は私が参加した限りでは大抵どこかの学校で開かれます。\nコンビニが近くになかったり、あっても混み合うことが予想されるので、駅を降りたあたりのコンビニでご飯を買うとよいと思っています。</p>\n<p>今回もコンビニに寄ったのですが、その時ふと以前の試験のときにミックスサンドを買ったことを思い出しまして。\nコンビニに売っている普通のミックスサンドですが妙に美味しかった記憶が残っており今回も同様のものを選びました。</p>\n<p>起床時間が早く空腹を感じて午前Ⅱの前に美味しくいただきました。\n次に情報処理技術者試験を受けることがあったら、またミックスサンドを選ぶかもしれません。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">このブログも個人が書いているもので、大して信頼できる情報ではないのだった<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"2021/10/10に令和3年度秋期データベーススペシャリスト試験を受験しました。\n情報処理技術者試験は通算4回目、高度情報は2回目 (春にネットワークスペシャリスト落ち)、データベーススペシャリストは今回が初でした。\n\n合格したので、この度晴れてみくりさんと結婚できる権利を得ました。\n\n\\#逃げ恥 リストラ候補の津崎平匡さんの資格欄「応用情報技術者、データベーススペシャリスト、基本情報技術者」 - togetter\n\n以下、対策したことを記録します。\n\n参考書\n\nいままではインプレスの過去問題集を毎度買っていたのですが、今回は翔泳社の「うかる！データベーススペシャリスト」を購入しました。\n\n結果からいうとこれは大正解で、午後問題の解説がめちゃくちゃ丁寧なので知識があまりない状態でも解説から吸収することができました。\nインプレスの過去問題集は、ネットワークスペシャリストの午後問題を勉強しているときに解説がサラッとしすぎていてわからんなあという気持ちになっていました。\n「うかる！データベーススペシャリスト」には各問題のパターンと解き方も参考書に丁寧に解説されているので、試験申し込んだときに一読し、あとで解くときに読み直すと良いように思います。\n\nインプレスの過去問題集は書籍自体をPDFダウンロードできるのが気に入って前回まで買っていました。\n翔泳社の書籍の電子版はKindleで販売されていますが、こういう参考書は書き込んでなんぼなのでKindleアプリ上で勉強するのは厳しいものがあります。\nPDFでの販売をしてくれるとより買いやすくなるのですが...\n\n試験勉強の時間軸\n\n試験勉強を始めたのは申込みをした8月中旬からでした。\n参考書を前からざっくり読んだ後、問題演習として初めに取り組んだのは午前Ⅱ対策です。\n1分半程度で解く規模の問題なので軽い気持ちで勉強しやすく、知識中心なのでまずはこれから手を付けました。\n\n9月に入った頃に午前Ⅱ対策を終わりにして午後対策に移りました。\n午後Ⅱは1問解くのに2時間かかるので、休日に午後Ⅱ、平日に午後Iとして、並行して過去問を解いていました。\nしかしながら特に午後Ⅱはとにかく文章が長いしやってると眠くなるし、この頃からモチベーションも薄れてきて勉強ペースが落ちがちに。\n結局参考書で紹介された再重要問題の半分くらい解いたところで試験前日になりまして、残りの問題は解説を読んで雰囲気を掴んで当日を迎えました。\n\n情報処理技術者試験は申し込んだとき一番モチベーションが高い気がします。\n毎度試験会場は半分〜7割くらいしかいないのでみんなそんな感じなんじゃないかな。\n申込時のモチベーションとその勢いでどこまで勉強できるか、それをどれだけ維持できるかが大事なのかなと思っています。\n\n各試験区分の対策と感想\n\n午前Ⅰ\n\n応用情報技術者試験を受けたのが2年以上前なので午前1の免除はありませんでした。\nいけるやろ」と無勉強で望んだのものの意外とと解けない問題もありました。\nさらに大々的にマークミスをしていまい、少し危なっかしい点数でした。\n問題番号と解答用紙のマーク位置はよく確認しましょう。\n\n午前Ⅱ\n\n午前Ⅱは選択式の問題で、データベースに関連する幅広い知識が問われます。\n対策としては参考書についてくる200問を繰り返し解いていました。\nデータベース何もわからん人間でSQLすら怪しい状態でしたが、間違えたところに絞りながら2,3周すればそこそこ解けるようになりました。\n\nSQLはどうやって学べばええんやというときは、PostgreSQLやMySQLの日本語ドキュメントを参考にすることが多かったです。\n参考書では簡潔に書かれ読み取れないことも含めて丁寧に書かれており読みやすい内容でした。\n(それが標準SQLであるかは確認する必要があります。)\n\n情報処理技術者試験の選択問題対策はどれも範囲が広いので雑にググって知らない言葉をなんとなく頭に入れておくのがよいと思っているのですが、ことSQLにおいては信頼できなさそうな量産ブログがたくさん引っかかるので最初から的を絞った方がよかったです。[^1]\n\n今思えばSQLに関する本を一冊買うなどしてもよかったように思います。\n\n午後I\n\n午後Iの問題は出題形式がいろいろありますが、一部の問題は午後IIをコンパクトにしたようなものもあります。\n午後Ⅱの対策をある程度進めてから午後Iに取り掛かった方が効率が良いように思います。\n\n午後Ⅱ\n\n参考書によるとデータベーススペシャリストの午後Ⅱは出題形式が定番になっていて、前述の通りその問題が出来ないと受からないかつそれが出来れば午後I対策にもなるとのこと。\n午後Ⅱのもっとも定番な問題である概念データモデルと関係スキーマに関する問題を何問か解いていきました。\n業務ロジックが文章で説明されており、未完成の概念データモデルと関係スキーマを完成させるのが主な問題の内容です。\n\nが、この問題、とにかく問題の文章量が多い。\n1問あたり12ページくらいあります。\niPadではページ切り替えが多すぎて厳しいので印刷して紙でやったほうがいいでしょう。\n\n試験のためのTips\n\n概念データモデルの記法\n\n午後問題では概念データモデルが必ず出てきます。\nそれぞれの記号に関する意味は注意書きとして試験問題の前半に書いてありますが、これは例年同じものです。\n\n午後問題の勉強を始めるときに初めに時間をとってじっくり読むことをお勧めします。\nこの記法にしたがって概念データモデルを書く問題も頻出です。\n私は読まずに問題を解いていて、対策中盤くらいまでなんだかよくわからない記法が使われているなあという気持ちになっていました。\n\n午後Ⅱ開始前の...\n\n当日は各試験区分が始まる15分くらい前から説明が始まります。\n午前中は受験票の回収がありますが、午後にもなると説明や準備もすぐに終わって解答開始まで10分くらい無の時間が訪れます。\n携帯も切って参考書も閉まったあとで、じっと座っているだけの時間です。\n\nここの時間は空想をするくらいしかないと思っていたのですが、午後IIには未完成の概念データモデルを埋める定番問題があります。\nこれを解くにはたくさんの問題文から情報を抽出して回答する必要があるので全体を掴んでおくと結構よかったりします。\nそしてこの問題は解答用紙に未完成の図が書いてあるので、試験開始前になんとなく問題に出てくる用語とその関係を見ることができてしまいます。ます😜\n\nおわりに\n\nデータベーススペシャリストに合格したところで実際の業務上でわからないことは沢山あると思いますが、ひとまず一定の知識を習得できた意味で受験してよかったです。\n\nタイトルのミックスサンドは試験当日に食べたお昼のメニューです。\n情報処理技術者試験の試験会場は私が参加した限りでは大抵どこかの学校で開かれます。\nコンビニが近くになかったり、あっても混み合うことが予想されるので、駅を降りたあたりのコンビニでご飯を買うとよいと思っています。\n\n今回もコンビニに寄ったのですが、その時ふと以前の試験のときにミックスサンドを買ったことを思い出しまして。\nコンビニに売っている普通のミックスサンドですが妙に美味しかった記憶が残っており今回も同様のものを選びました。\n\n起床時間が早く空腹を感じて午前Ⅱの前に美味しくいただきました。\n次に情報処理技術者試験を受けることがあったら、またミックスサンドを選ぶかもしれません。\n\n[^1]: このブログも個人が書いているもので、大して信頼できる情報ではないのだった\n"},{"id":"http://localhost:3000/posts/newcomer-in-development-team-supplement","url":"http://localhost:3000/posts/newcomer-in-development-team-supplement","title":"ECテックカンファレンスの前と後","summary":"前の記事に書いたとおり先日ペパボECテックカンファレンスに登壇しました。 今日はテックカンファレンスの内容ではなく発表前後に考えていたことと気持ちをいくつか記します。 「新卒」という言葉を使わない 発表に際してひとつ気をつけていたことに「新卒」という言葉をあまり使わないことがあります。 テックカンファレンスの目的や狙いが記載された社内向けのissueを登壇が決まった頃に読んだ記憶があります。 これと今までやってきたこととを照らし合わせ自らの発表を聞いて欲しい人をジュニア層 [^1] のエンジニアと定めていました。 私は新卒で入社したのでその体験をこれから新卒で入社される方や興味のある方に向けて","date_published":"2021-12-16T10:43:00+09:00","date_modified":"2021-12-16T13:31:03+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:EC%E3%83%86%E3%83%83%E3%82%AF%E3%82%AB%E3%83%B3%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9%E3%81%AE%E5%89%8D%E3%81%A8%E5%BE%8C,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c2e660d0f8a1a91121aad25ff9a155a61242bc27","comment":"Fix: リンクの修正\n","date_modified":"2021-12-16T13:31:03+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/2973a55a2247b3b075c158f641d91718aa4ed3d9","comment":"Fix: 表記を統一\n","date_modified":"2021-12-16T10:50:21+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/f34fc3f957d81a13b238583e8b8fa0a565934cc0","comment":"Post: 「ECテックカンファレンスの前と後」\n","date_modified":"2021-12-16T10:44:26+09:00"}],"content_html":"<p><a href=\"/posts/newcomer-in-development-team\">前の記事に書いたとおり</a>先日<a href=\"https://pepabo.connpass.com/event/231478\">ペパボECテックカンファレンス</a>に登壇しました。\n今日はテックカンファレンスの内容ではなく発表前後に考えていたことと気持ちをいくつか記します。</p>\n<h2>「新卒」という言葉を使わない</h2>\n<p>発表に際してひとつ気をつけていたことに「新卒」という言葉をあまり使わないことがあります。</p>\n<p>テックカンファレンスの目的や狙いが記載された社内向けのissueを登壇が決まった頃に読んだ記憶があります。\nこれと今までやってきたこととを照らし合わせ自らの発表を聞いて欲しい人をジュニア層 <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> のエンジニアと定めていました。</p>\n<p>私は新卒で入社したのでその体験をこれから新卒で入社される方や興味のある方に向けて話す行為は普通は一定程度価値があると思います。\nしかしながら実は聞いて欲しい人として定めたジュニア層のエンジニアと、私の所属する会社の今後の新卒採用の募集方針は重なる部分が少なくなっています。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>\nこのことを鑑みると「新卒」という言葉を聞いて会社に興味を抱いてくださっても募集要項とは重ならずミスマッチが発生することになります。</p>\n<p>そこで聞いて欲しい人と伝えたい内容を合わせるために、新卒かどうかにかかわらず「新しくチームに入る人」という視点で内容を組み立てることとしました。\nこれであれば新卒に限定せずエンジニアに広く聞いてもらえる内容となります。\nチームで働いている人は誰でも人を迎え入れたりチームに加わったりした経験があるはずですし、今後チームで働きたい人にとっても聞く耳を持ってもらえることと思います。</p>\n<h2>技術的にどんなことに取り組んだかを軸にしない</h2>\n<p>テックカンファレンスですから技術に興味のある人が集まり技術について発表する場であることは明らかでしょう。\nしかしながら今回発表したようなチームとしてうまくやるための手法も、技術による価値提供を支えるために技術者に求められることの一つに思います。</p>\n<p>もちろん技術の話は面白いし現にたくさんの方々が技術の話をされたわけですが、一方で今の私が技術の話に触れたとき内容が中途半端になることを恐れていました。\n日々の仕事は難しく面白いものでありエンジニアであるから技術を用いた課題解決をしているわけでありますが、今やっている事柄は業務知識に密接に紐づいたものであったり事業部の物事をキャッチアップしたりする機会が多く、切り取り方が難しいと感じていたのです。</p>\n<p>しばらく考えてもあまり良い内容が思い浮かばず、発表が近づいてきた段階で自分で決めたのが「技術的にどんなことに取り組んだかを軸にしない」ことでした。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>\n中途半端に技術の話をするよりも、どのように考え何を感じたのかの方がきっと面白味があるし、私の発表の目的<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>のひとつであった「このサービスで働くのはこんな感じか」を想像しやすいのではないかと考えました。</p>\n<p>テクニカルな内容にあまり触れなかったのは結果としてよかったと感じています。\n今の私に話せることを発表に落とし込んだつもりですが、一方で他の方々の発表を聞いて「技術的にこんなことをやっているぞ」と自慢できるくらい成果を出せるようになりたいとも思ったので、来年以降たくさん成果を出して発表の場に立ちたいと思います。</p>\n<h2>聴衆は\"あなたの発表\"を聞きに来ているのです。</h2>\n<p>発表前に社内のSlackに投稿されていた文章がいい話だったのでここで触れます。</p>\n<blockquote>\n<p>初めての発表で緊張していたり、どういう反応がくるか不安になってしまうというのはよくわかります。\nしかし、あなたの発表を見に来ている人は、他の誰でもない「あなた」の発表を見たくて見に来ているのです。</p>\n</blockquote>\n<p><a href=\"https://diary.shu-cream.net/%E8%81%B4%E8%A1%86%E3%81%AF%22%E3%81%82%E3%81%AA%E3%81%9F%E3%81%AE%E7%99%BA%E8%A1%A8%22%E3%82%92%E8%81%9E%E3%81%8D%E3%81%AB%E6%9D%A5%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE%E3%81%A7%E3%81%99\">聴衆は\"あなたの発表\"を聞きに来ているのです - けんちゃんくんさんのWeb日記</a></p>\n<p>(どうぞ上記の記事を全文お読みください)</p>\n<p>当日は緊張していましたが、何か一つでも持ち帰ってもらえるものがあればという気持ちで内容に自信を持って臨むことができました。\nオンラインで発表していたので聴講者の顔は見えませんが、何人もの人に発表を聞いていただけたようで本当に嬉しいです。</p>\n<p>次にまた発表の機会があったときこの文章を読んで気持ちを整えたいと思っています。\nあわせて自らの話を聞く時間をとってくださる人のために内容に自信をもてるだけの準備をしなければと感じます。</p>\n<h2>Speaker Deckにスライドを公開する</h2>\n<p>当日の発表スライドはSpeaker Deckにアップロードしました。\n公開にあたって気をつけたことがあるので紹介します。</p>\n<h3>Google SlidesとSpeaker Deckの相性</h3>\n<p>どうもGoogle Slidesで出力した日本語を含むPDFはSpeaker Deckで公開すると崩れるようです。(太字部分が白抜き文字になる)\nこれを回避するために一旦Keynoteで読み込んでからPDFにするなどしました。\nKeynoteに読み込むとスライド内のオブジェクトの位置ズレなどが発生するので、それを修正する必要もありました。</p>\n<h3>Speaker DeckのタイトルとURL</h3>\n<p>Speaker Deckで公開したスライドのURLはタイトルから生成されるようになっています。\n日本語の場合はローマ字読みのアルファベットに置き換えられますが、完全に正しい読みになるわけではありません。\nこれを回避するために発表名の末尾に<code>/</code>を付けて続けて半角英数字などをおくと、<code>/</code>の後の半角英数字のみがURLになるようです。</p>\n<p>これを生かして以下のようなタイトルとURLとしました。</p>\n<ul>\n<li>タイトル: 「開発チームの新しいエンジニアメンバーがうまくやるには / newcomer-in-development-team」</li>\n<li>URL: 「<a href=\"https://speakerdeck.com/yammerjp/newcomer-in-development-team%E3%80%8D\">https://speakerdeck.com/yammerjp/newcomer-in-development-team」</a></li>\n</ul>\n<p>以上、雑多ですが、発表に際してどんなことを考えていたかを記しました。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">ジュニア層のエンジニアとは<a href=\"https://tech.pepabo.com/2020/07/30/pepabo-engineering-2020-summer/\">ペパボのエンジニアの各種制度 2020 夏 - ペパボテックブログ</a> で示されている1-3等級相当のエンジニアのことを指して言っています。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\"><a href=\"https://pepabo.com/news/information/202112131500\">GMOインターネットグループ共通2023年度新卒採用エントリーを開始しました - GMOペパボ株式会社</a> にある通りの採用基準が定められています。これは新卒の採用基準であって、例えば<a href=\"https://recruit.pepabo.com/info/career/\">ジュニア層向けの中途採用</a>や<a href=\"https://recruit.pepabo.com/info/collage/\">未経験者向け研修付き採用「ペパボカレッジ」</a>などはこれに該当せず、募集が開かれています。(2021/12/16時点)<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">発表の趣旨から離れすぎない範囲で技術的な内容に触れてはいます。(環境作成タスクの内容や自動テストなど)<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">私の発表を聞いて「このサービスで働くのはこんな感じか」「このサービスで働くのは面白いぞ」「このサービスで働いてみたい」などの感情を想起してもらいたいと思っていました。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"前の記事に書いたとおり先日ペパボECテックカンファレンスに登壇しました。\n今日はテックカンファレンスの内容ではなく発表前後に考えていたことと気持ちをいくつか記します。\n\n「新卒」という言葉を使わない\n\n発表に際してひとつ気をつけていたことに「新卒」という言葉をあまり使わないことがあります。\n\nテックカンファレンスの目的や狙いが記載された社内向けのissueを登壇が決まった頃に読んだ記憶があります。\nこれと今までやってきたこととを照らし合わせ自らの発表を聞いて欲しい人をジュニア層 [^1] のエンジニアと定めていました。\n\n私は新卒で入社したのでその体験をこれから新卒で入社される方や興味のある方に向けて話す行為は普通は一定程度価値があると思います。\nしかしながら実は聞いて欲しい人として定めたジュニア層のエンジニアと、私の所属する会社の今後の新卒採用の募集方針は重なる部分が少なくなっています。[^2]\nこのことを鑑みると「新卒」という言葉を聞いて会社に興味を抱いてくださっても募集要項とは重ならずミスマッチが発生することになります。\n\nそこで聞いて欲しい人と伝えたい内容を合わせるために、新卒かどうかにかかわらず「新しくチームに入る人」という視点で内容を組み立てることとしました。\nこれであれば新卒に限定せずエンジニアに広く聞いてもらえる内容となります。\nチームで働いている人は誰でも人を迎え入れたりチームに加わったりした経験があるはずですし、今後チームで働きたい人にとっても聞く耳を持ってもらえることと思います。\n\n技術的にどんなことに取り組んだかを軸にしない\n\nテックカンファレンスですから技術に興味のある人が集まり技術について発表する場であることは明らかでしょう。\nしかしながら今回発表したようなチームとしてうまくやるための手法も、技術による価値提供を支えるために技術者に求められることの一つに思います。\n\nもちろん技術の話は面白いし現にたくさんの方々が技術の話をされたわけですが、一方で今の私が技術の話に触れたとき内容が中途半端になることを恐れていました。\n日々の仕事は難しく面白いものでありエンジニアであるから技術を用いた課題解決をしているわけでありますが、今やっている事柄は業務知識に密接に紐づいたものであったり事業部の物事をキャッチアップしたりする機会が多く、切り取り方が難しいと感じていたのです。\n\nしばらく考えてもあまり良い内容が思い浮かばず、発表が近づいてきた段階で自分で決めたのが「技術的にどんなことに取り組んだかを軸にしない」ことでした。[^3]\n中途半端に技術の話をするよりも、どのように考え何を感じたのかの方がきっと面白味があるし、私の発表の目的[^4]のひとつであった「このサービスで働くのはこんな感じか」を想像しやすいのではないかと考えました。\n\nテクニカルな内容にあまり触れなかったのは結果としてよかったと感じています。\n今の私に話せることを発表に落とし込んだつもりですが、一方で他の方々の発表を聞いて「技術的にこんなことをやっているぞ」と自慢できるくらい成果を出せるようになりたいとも思ったので、来年以降たくさん成果を出して発表の場に立ちたいと思います。\n\n聴衆は\"あなたの発表\"を聞きに来ているのです。\n\n発表前に社内のSlackに投稿されていた文章がいい話だったのでここで触れます。\n\n初めての発表で緊張していたり、どういう反応がくるか不安になってしまうというのはよくわかります。\nしかし、あなたの発表を見に来ている人は、他の誰でもない「あなた」の発表を見たくて見に来ているのです。\n\n聴衆は\"あなたの発表\"を聞きに来ているのです - けんちゃんくんさんのWeb日記\n\n(どうぞ上記の記事を全文お読みください)\n\n当日は緊張していましたが、何か一つでも持ち帰ってもらえるものがあればという気持ちで内容に自信を持って臨むことができました。\nオンラインで発表していたので聴講者の顔は見えませんが、何人もの人に発表を聞いていただけたようで本当に嬉しいです。\n\n次にまた発表の機会があったときこの文章を読んで気持ちを整えたいと思っています。\nあわせて自らの話を聞く時間をとってくださる人のために内容に自信をもてるだけの準備をしなければと感じます。\n\nSpeaker Deckにスライドを公開する\n\n当日の発表スライドはSpeaker Deckにアップロードしました。\n公開にあたって気をつけたことがあるので紹介します。\n\nGoogle SlidesとSpeaker Deckの相性\n\nどうもGoogle Slidesで出力した日本語を含むPDFはSpeaker Deckで公開すると崩れるようです。(太字部分が白抜き文字になる)\nこれを回避するために一旦Keynoteで読み込んでからPDFにするなどしました。\nKeynoteに読み込むとスライド内のオブジェクトの位置ズレなどが発生するので、それを修正する必要もありました。\n\nSpeaker DeckのタイトルとURL\n\nSpeaker Deckで公開したスライドのURLはタイトルから生成されるようになっています。\n日本語の場合はローマ字読みのアルファベットに置き換えられますが、完全に正しい読みになるわけではありません。\nこれを回避するために発表名の末尾に/を付けて続けて半角英数字などをおくと、/の後の半角英数字のみがURLになるようです。\n\nこれを生かして以下のようなタイトルとURLとしました。\n\nタイトル: 「開発チームの新しいエンジニアメンバーがうまくやるには / newcomer-in-development-team」\n\nURL: 「https\\://speakerdeck.com/yammerjp/newcomer-in-development-team」\n\n以上、雑多ですが、発表に際してどんなことを考えていたかを記しました。\n\n[^1]: ジュニア層のエンジニアとはペパボのエンジニアの各種制度 2020 夏 - ペパボテックブログ で示されている1-3等級相当のエンジニアのことを指して言っています。\n\n[^2]: GMOインターネットグループ共通2023年度新卒採用エントリーを開始しました - GMOペパボ株式会社 にある通りの採用基準が定められています。これは新卒の採用基準であって、例えばジュニア層向けの中途採用や未経験者向け研修付き採用「ペパボカレッジ」などはこれに該当せず、募集が開かれています。(2021/12/16時点)\n\n[^3]: 発表の趣旨から離れすぎない範囲で技術的な内容に触れてはいます。(環境作成タスクの内容や自動テストなど)\n\n[^4]: 私の発表を聞いて「このサービスで働くのはこんな感じか」「このサービスで働くのは面白いぞ」「このサービスで働いてみたい」などの感情を想起してもらいたいと思っていました。\n"},{"id":"http://localhost:3000/posts/newcomer-in-development-team","url":"http://localhost:3000/posts/newcomer-in-development-team","title":"開発チームの新しいエンジニアメンバーがうまくやるには","summary":"こんにちは、2021/12/09に開催されたペパボECテックカンファレンスにて、記事名と同じタイトルで発表をしました。 当日のスライドはSpeaker Deckで公開しています。 今日はその発表の内容を記事として紹介します。 開発チームの新しいエンジニアメンバーがうまくやるには 私は4月に新卒でWebアプリケーションエンジニアとして入社し、今は10人弱のチームに配属となってから3ヶ月ほどが経ちました。 会社のGitHub Enterprise Server上では、配属からこれまでで約60のPull Requestを開き、マージし、デプロイされました。 Pull Requestの数と成果は必ずし","date_published":"2021-12-14T00:03:00+09:00","date_modified":"2021-12-16T10:45:31+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E9%96%8B%E7%99%BA%E3%83%81%E3%83%BC%E3%83%A0%E3%81%AE%E6%96%B0%E3%81%97%E3%81%84%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%A1%E3%83%B3%E3%83%90%E3%83%BC%E3%81%8C%E3%81%86%E3%81%BE%E3%81%8F%E3%82%84%E3%82%8B%E3%81%AB%E3%81%AF,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["オンボーディング","チームワーク","Webサービス開発","ドメイン知識"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1c890361f24a031510272d9fbbf454b8a3e00070","comment":"Fix: 投稿日時\n","date_modified":"2021-12-16T10:45:31+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9caf6e188622e5afe171f771588158fb902332cd","comment":"Post: 「開発チームの新しいエンジニアメンバーがうまくやるには」\n","date_modified":"2021-12-14T00:03:57+09:00"}],"content_html":"<p>こんにちは、2021/12/09に開催された<a href=\"https://pepabo.connpass.com/event/231478\">ペパボECテックカンファレンス</a>にて、記事名と同じタイトルで発表をしました。\n当日のスライドはSpeaker Deckで公開しています。</p>\n<div style=\"text-align: center;\">\n<iframe class=\"speakerdeck-iframe\" frameborder=\"0\" src=\"https://speakerdeck.com/player/aff516d8e9404ef5b58c114f714fff87\" title=\"開発チームの新しいエンジニアメンバーがうまくやるには / newcomer-in-development-team\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" style=\"border: 0px; background: padding-box padding-box rgba(0, 0, 0, 0.1); margin: 0px; padding: 0px; border-radius: 6px; box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 40px; width: 560px; height: 314px;\" data-ratio=\"1.78343949044586\"></iframe>\n</div>\n<p>今日はその発表の内容を記事として紹介します。</p>\n<h2>開発チームの新しいエンジニアメンバーがうまくやるには</h2>\n<p>私は4月に新卒でWebアプリケーションエンジニアとして入社し、今は10人弱のチームに配属となってから3ヶ月ほどが経ちました。\n会社のGitHub Enterprise Server上では、配属からこれまでで約60のPull Requestを開き、マージし、デプロイされました。\nPull Requestの数と成果は必ずしも一致しませんが、配属から今日までの間、昨日を細かく分割して実装しデプロイするということを続けています。</p>\n<p>チームメンバーが私を迎え入れるにあたってしてくれたことは、業務経験の無い自分が開発に取り組むにあたってとても役に立つものでした。\n以下では自らが意識的に取り組んだことと合わせて「新しいメンバーが〇〇するには」という題目で紹介します。</p>\n<h2>1.新しいメンバーが業務知識を素早く獲得するには</h2>\n<p>Webサービスのアプリケーション開発において、業務知識への理解は欠かせません。\nここでいう業務知識とは、そのサービスを成立させるためのアプリケーションの構成やそれらのアプリケーション固有の仕様などをはじめとした、エンジニアが業務を進める上で必要なそのサービス特有の知識のことを指しています。</p>\n<p>このような知識は開発チームに参加したのちに獲得する必要があり、素早く獲得すればより早く広範囲のタスクを扱えるようになるでしょう。</p>\n<h3>アプリケーションの構成に関する共有会を開く</h3>\n<p>(チームメンバーが私にしてくれたこと)</p>\n<p>チームメンバーに業務知識の共有会を開いていただいたことは、業務知識の獲得に直接的に大きく影響を与えました。\n独自のアーキテクチャを持つアプリケーションのディレクトリごとの構成や各レイヤの関係性をざっくりと説明をしてもらったことでその後のコードリーディングが捗ったように思います。</p>\n<p>他にもリレーショナルデータベースの重要なテーブルの関係性についてレクチャーをいただいたことも良い機会でした。\n私の開発するサービスは多数のロールがデータベースを介して連携をしています。即ち特定のロールの処理を見てもそれ自体がサービスの動作を表しているわけではなく、他ロールでどのように使われているかを知る必要があります。\nこういった広い範囲の挙動を把握するためには、全体感をつかむ説明を受けた方がアプリケーションの挙動を把握するのが楽になります。</p>\n<h3>少しずつ取り組む領域を広げる</h3>\n<p>(チームメンバーが私にしてくれたこと)</p>\n<p>配属初期にいただいたタスクに関連するコード上の領域が少しずつ広がっていったことも業務知識を素早く獲得するに寄与しました。私は元々フロントエンド寄りのスキルセットであったので、Webフロントエンド領域のテンプレートやVueコンポーネントの実装からはじめて、次にWebサーバサイド領域のController層、Model層の開発に関わり、さらに他のロールや外部APIとの通信、バッチといった部分へ手を広げていきました。\n大きなコードベースの中で少しずつコードリーディングの範囲を広げられたことはスムーズに開発に参加できた要因のひとつでした。</p>\n<h3>チームに回ってくるタスクに「やります」と言う</h3>\n<p>(自らが意識していること)</p>\n<p>業務知識を素早く獲得するために私が心掛けていることの1つとして、チームに回ってくるタスクに積極的に「やります」と手を挙げることがあります。\n開発チームにおいて、お問い合わせやパートナー (社員のこと) からの依頼に起因して、もともとの計画に含まれない突発的なタスクが発生することがときどきあります。\nこういったタスクの中には配属後少し時間が経ち慣れてくればある程度対応できそうなものもあります。\n自らのできることが少ないからこそ、できることは積極的に巻き取ることでチームに貢献しようとしています。</p>\n<p>チームとしての生産性を高めるという点だけでなく、こういったタスクはときに自らの知っている領域を広げるきっかけになることがあります。\n例えば私はあるロールのDockerを用いた開発環境を作成するタスクに取り組みましたが、これはまさに自らの知っている領域を広げるものでした。</p>\n<p>普段はコードベースの大きい中心的なロールに対して開発を行なっており、CI/CD環境が整備され、Gitの操作やSlackとの連携によって、深く知らずとも簡単にデプロイできる環境が整っています。</p>\n<p>一方開発環境の作成では、そのようなCI/CD環境が普段どのようなことを行なっているのかを一定程度追う必要がありました。\nまた、Webアプリケーションのエントリポイントに到達する前に、インフラレベルでHTTPリクエストがどのようにルーティングされているかといったことについても一定程度理解する必要がありました。\nこれらの知識は中心的なロールを含む他のロールにも適用でき、ブラックボックスとして扱っていたサービスを構成する要素の一部がどんなことをしているかを知ることができました。</p>\n<p>手を挙げてタスクを受け取ることで、こういった毛色の違うタスクに触れる</p>\n<h2>2.新しいメンバーがチームに馴染むには</h2>\n<p>昨今は心理的安全性という言葉が取り沙汰され、開発チームのメンバー同士の関係もプロダクトの提供する価値に影響を与えることが広く知られていることと思います。\n私の所属するチームにおいてもチームメンバー同士の関係を良好に保ち、意見を積極的に交換できるような関係性を築くような取り組みがなされています。</p>\n<h3>お互いの強み/弱みを知る</h3>\n<p>(チームメンバーが私にしてくれたこと)</p>\n<p>チームメンバーがお互いの強み/弱みを知るために「ドラッカー風エクササイズ」という手法のチームビルディングのためのワークショップを開催していただきました。これは私がチームメンバーと相互理解を深めることに役立った出来事の1つでしょう。\n「ドラッカー風エクササイズ」はお互いの特徴の自己認識と他者認識を書き出して、期待値をすり合わせるための手法です。\n自らの思っている強み/弱みを伝えるきっかけになりますし、自分以外のチームメンバー同士でどのような関係が築かれているかを知る機会になります。\nペパボにおけるドラッカー風エクササイズの取り組みは会社のブログに紹介がありますので以下の記事をご覧になると良いかと思います。</p>\n<p>参考: <a href=\"https://tech.pepabo.com/2017/07/07/the-drucker-exercise/\">「ドラッカー風エクササイズ」で期待をすりあわせて安全なチームに - ペパボテックブログ</a></p>\n<h3>コミュニケーションの場を用意する</h3>\n<p>(チームメンバーが私にしてくれたこと)</p>\n<ul>\n<li>フードコート</li>\n</ul>\n<p>私の事業部のいくつかのチームにはフードコートという取り組みがあります。いつでも開かれているビデオミーティング会場で、お互いが好きな時に入ることができます。私の所属するチームのメンバーの多くは予定がない時などはここにいて、チームメンバーに話したい時にマイクをonにするといった運用がなされています。\nフードコートに居る義務はなく、集中して業務に取り組みたいときなどには入らないという選択肢をとることもできます。\n仕事を始めたて且つチームに参加したての自分にとって、発話のハードルが下がったのでありがたい取り組みでした。</p>\n<ul>\n<li>事業部お茶会</li>\n</ul>\n<p>リモートワークの中では、偶発的な同期コミュニケーションの機会はあまりありません。\nこのためチームメンバーが事業部の人を招いた座談会を定期的に開催してくれています。\n他チームの人と業務に関係あるかどうかに関係なくいろいろな話をする機会が生まれることは、視野が広がる機会となっています。</p>\n<h3>日報を書く</h3>\n<p>(自らが意識していること)</p>\n<p>チームメンバーとの相互理解を深めるために大事なことの一つに自己開示があります。\n日報を書くことで、自らがどんなことを考えて仕事をしているか、どんな感情であるか、何を理解していて何を理解していないのかを知ってもらう機会となります。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>\nまた、チームメンバー以外の人が見てコメントをくれることもあります。</p>\n<p>日報のフォーマットとしては「今の気持ち」「やったこと」「わかったこと」「次にやること」の4つに分けて記述するようにしています。</p>\n<h2>3.新しいメンバーが開発の提案をするには</h2>\n<h3>複数の選択肢を挙げる</h3>\n<p>(自らが意識していること)</p>\n<p>開発において、要件を達成する手法を自分で決められない/決めないとき、複数の選択肢を提案することで、自らに足りない業務知識や技術的知見を補ってもらえるようにしています。</p>\n<p>このとき、あわせて自分が最も良いと思う選択肢を1つ選ぶよう心がけています。\n自分が選んだものと実際に選ばれたものの差異が学びになるので、自分で1つ選ぶことはこれからも続けていきたいと思っています。</p>\n<h3>テストコードを書く</h3>\n<p>(自らが意識していること)</p>\n<p>Pull Requestを開発における実装の提案の場として考えると、Pull Requestも新しいメンバーが開発の提案をうまくやる必要のある場の一つでしょう。\n適当なPull Requestを投げてばかりではレビュアーの負担は増大するばかりです。</p>\n<p>レビューしやすい Pull Request にするという意味でテストコードは有用です。\nコードの一定の質が担保されるだけでなく、入出力が明確になったり、依存が明らかになったりするという利点が考えられるでしょう。</p>\n<p>ちなみにテストコードの書き方については新卒研修の中でのカリキュラムがとても役に立ちました。\nペパボの2021年度の新卒エンジニア研修では、<a href=\"https://railstutorial.jp/chapters/beginning?version=6.0\">Railsチュートリアル内</a>でのMinitestによる自動テスト、<a href=\"https://tech.pepabo.com/2021/09/22/igaiga-workshop/\">RSpec書き方講座</a>、<a href=\"https://tech.pepabo.com/2021/06/18/tdd-workshop-2021/\">TDDワークショップ</a>など、ソフトウェア開発における自動テストがどのような役割を持ちどのように作るべきかを学ぶことができました。\n今はRSpecだけでなくPHPUnitやJestを用いたテストコードを書く機会がありますが、これらのテストフレームワークを使う上でも研修で学んだ内容が役に立っています。</p>\n<h2>おわりに</h2>\n<p>以上のような取り組みを通して、開発チームに新しくエンジニアとして加わったメンバーが、業務知識を素早く獲得し、チームに馴染み、開発の提案をして、ユーザへの価値提供に取り組んでいます。\nチームメンバーが新しく私を迎え入れるためにしてくれたことが今の開発に生きていると感じています。</p>\n<p>これらの事例が、チームに新しく加わる人や、新しい人を迎えるチームにとって参考になれば幸いです。また、チームに加わった3ヶ月で自分がどのように感じ何が役に立っていたかの取り組みを残しておくことで、将来チームメンバーを迎え入れる側になったときにこれを見返してよい環境を提供できるようになれればと思います。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">同時にこれら (どんなことを考えて仕事をしているか、どんな感情であるか、何を理解していて何を理解していないのか) を言語化することで自らに対して明らかにする機会ともなります。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"こんにちは、2021/12/09に開催されたペパボECテックカンファレンスにて、記事名と同じタイトルで発表をしました。\n当日のスライドはSpeaker Deckで公開しています。\n\n\n\n今日はその発表の内容を記事として紹介します。\n\n開発チームの新しいエンジニアメンバーがうまくやるには\n\n私は4月に新卒でWebアプリケーションエンジニアとして入社し、今は10人弱のチームに配属となってから3ヶ月ほどが経ちました。\n会社のGitHub Enterprise Server上では、配属からこれまでで約60のPull Requestを開き、マージし、デプロイされました。\nPull Requestの数と成果は必ずしも一致しませんが、配属から今日までの間、昨日を細かく分割して実装しデプロイするということを続けています。\n\nチームメンバーが私を迎え入れるにあたってしてくれたことは、業務経験の無い自分が開発に取り組むにあたってとても役に立つものでした。\n以下では自らが意識的に取り組んだことと合わせて「新しいメンバーが〇〇するには」という題目で紹介します。\n\n1.新しいメンバーが業務知識を素早く獲得するには\n\nWebサービスのアプリケーション開発において、業務知識への理解は欠かせません。\nここでいう業務知識とは、そのサービスを成立させるためのアプリケーションの構成やそれらのアプリケーション固有の仕様などをはじめとした、エンジニアが業務を進める上で必要なそのサービス特有の知識のことを指しています。\n\nこのような知識は開発チームに参加したのちに獲得する必要があり、素早く獲得すればより早く広範囲のタスクを扱えるようになるでしょう。\n\nアプリケーションの構成に関する共有会を開く\n\n(チームメンバーが私にしてくれたこと)\n\nチームメンバーに業務知識の共有会を開いていただいたことは、業務知識の獲得に直接的に大きく影響を与えました。\n独自のアーキテクチャを持つアプリケーションのディレクトリごとの構成や各レイヤの関係性をざっくりと説明をしてもらったことでその後のコードリーディングが捗ったように思います。\n\n他にもリレーショナルデータベースの重要なテーブルの関係性についてレクチャーをいただいたことも良い機会でした。\n私の開発するサービスは多数のロールがデータベースを介して連携をしています。即ち特定のロールの処理を見てもそれ自体がサービスの動作を表しているわけではなく、他ロールでどのように使われているかを知る必要があります。\nこういった広い範囲の挙動を把握するためには、全体感をつかむ説明を受けた方がアプリケーションの挙動を把握するのが楽になります。\n\n少しずつ取り組む領域を広げる\n\n(チームメンバーが私にしてくれたこと)\n\n配属初期にいただいたタスクに関連するコード上の領域が少しずつ広がっていったことも業務知識を素早く獲得するに寄与しました。私は元々フロントエンド寄りのスキルセットであったので、Webフロントエンド領域のテンプレートやVueコンポーネントの実装からはじめて、次にWebサーバサイド領域のController層、Model層の開発に関わり、さらに他のロールや外部APIとの通信、バッチといった部分へ手を広げていきました。\n大きなコードベースの中で少しずつコードリーディングの範囲を広げられたことはスムーズに開発に参加できた要因のひとつでした。\n\nチームに回ってくるタスクに「やります」と言う\n\n(自らが意識していること)\n\n業務知識を素早く獲得するために私が心掛けていることの1つとして、チームに回ってくるタスクに積極的に「やります」と手を挙げることがあります。\n開発チームにおいて、お問い合わせやパートナー (社員のこと) からの依頼に起因して、もともとの計画に含まれない突発的なタスクが発生することがときどきあります。\nこういったタスクの中には配属後少し時間が経ち慣れてくればある程度対応できそうなものもあります。\n自らのできることが少ないからこそ、できることは積極的に巻き取ることでチームに貢献しようとしています。\n\nチームとしての生産性を高めるという点だけでなく、こういったタスクはときに自らの知っている領域を広げるきっかけになることがあります。\n例えば私はあるロールのDockerを用いた開発環境を作成するタスクに取り組みましたが、これはまさに自らの知っている領域を広げるものでした。\n\n普段はコードベースの大きい中心的なロールに対して開発を行なっており、CI/CD環境が整備され、Gitの操作やSlackとの連携によって、深く知らずとも簡単にデプロイできる環境が整っています。\n\n一方開発環境の作成では、そのようなCI/CD環境が普段どのようなことを行なっているのかを一定程度追う必要がありました。\nまた、Webアプリケーションのエントリポイントに到達する前に、インフラレベルでHTTPリクエストがどのようにルーティングされているかといったことについても一定程度理解する必要がありました。\nこれらの知識は中心的なロールを含む他のロールにも適用でき、ブラックボックスとして扱っていたサービスを構成する要素の一部がどんなことをしているかを知ることができました。\n\n手を挙げてタスクを受け取ることで、こういった毛色の違うタスクに触れる\n\n2.新しいメンバーがチームに馴染むには\n\n昨今は心理的安全性という言葉が取り沙汰され、開発チームのメンバー同士の関係もプロダクトの提供する価値に影響を与えることが広く知られていることと思います。\n私の所属するチームにおいてもチームメンバー同士の関係を良好に保ち、意見を積極的に交換できるような関係性を築くような取り組みがなされています。\n\nお互いの強み/弱みを知る\n\n(チームメンバーが私にしてくれたこと)\n\nチームメンバーがお互いの強み/弱みを知るために「ドラッカー風エクササイズ」という手法のチームビルディングのためのワークショップを開催していただきました。これは私がチームメンバーと相互理解を深めることに役立った出来事の1つでしょう。\n「ドラッカー風エクササイズ」はお互いの特徴の自己認識と他者認識を書き出して、期待値をすり合わせるための手法です。\n自らの思っている強み/弱みを伝えるきっかけになりますし、自分以外のチームメンバー同士でどのような関係が築かれているかを知る機会になります。\nペパボにおけるドラッカー風エクササイズの取り組みは会社のブログに紹介がありますので以下の記事をご覧になると良いかと思います。\n\n参考: 「ドラッカー風エクササイズ」で期待をすりあわせて安全なチームに - ペパボテックブログ\n\nコミュニケーションの場を用意する\n\n(チームメンバーが私にしてくれたこと)\n\nフードコート\n\n私の事業部のいくつかのチームにはフードコートという取り組みがあります。いつでも開かれているビデオミーティング会場で、お互いが好きな時に入ることができます。私の所属するチームのメンバーの多くは予定がない時などはここにいて、チームメンバーに話したい時にマイクをonにするといった運用がなされています。\nフードコートに居る義務はなく、集中して業務に取り組みたいときなどには入らないという選択肢をとることもできます。\n仕事を始めたて且つチームに参加したての自分にとって、発話のハードルが下がったのでありがたい取り組みでした。\n\n事業部お茶会\n\nリモートワークの中では、偶発的な同期コミュニケーションの機会はあまりありません。\nこのためチームメンバーが事業部の人を招いた座談会を定期的に開催してくれています。\n他チームの人と業務に関係あるかどうかに関係なくいろいろな話をする機会が生まれることは、視野が広がる機会となっています。\n\n日報を書く\n\n(自らが意識していること)\n\nチームメンバーとの相互理解を深めるために大事なことの一つに自己開示があります。\n日報を書くことで、自らがどんなことを考えて仕事をしているか、どんな感情であるか、何を理解していて何を理解していないのかを知ってもらう機会となります。[^1]\nまた、チームメンバー以外の人が見てコメントをくれることもあります。\n\n日報のフォーマットとしては「今の気持ち」「やったこと」「わかったこと」「次にやること」の4つに分けて記述するようにしています。\n\n3.新しいメンバーが開発の提案をするには\n\n複数の選択肢を挙げる\n\n(自らが意識していること)\n\n開発において、要件を達成する手法を自分で決められない/決めないとき、複数の選択肢を提案することで、自らに足りない業務知識や技術的知見を補ってもらえるようにしています。\n\nこのとき、あわせて自分が最も良いと思う選択肢を1つ選ぶよう心がけています。\n自分が選んだものと実際に選ばれたものの差異が学びになるので、自分で1つ選ぶことはこれからも続けていきたいと思っています。\n\nテストコードを書く\n\n(自らが意識していること)\n\nPull Requestを開発における実装の提案の場として考えると、Pull Requestも新しいメンバーが開発の提案をうまくやる必要のある場の一つでしょう。\n適当なPull Requestを投げてばかりではレビュアーの負担は増大するばかりです。\n\nレビューしやすい Pull Request にするという意味でテストコードは有用です。\nコードの一定の質が担保されるだけでなく、入出力が明確になったり、依存が明らかになったりするという利点が考えられるでしょう。\n\nちなみにテストコードの書き方については新卒研修の中でのカリキュラムがとても役に立ちました。\nペパボの2021年度の新卒エンジニア研修では、Railsチュートリアル内でのMinitestによる自動テスト、RSpec書き方講座、TDDワークショップなど、ソフトウェア開発における自動テストがどのような役割を持ちどのように作るべきかを学ぶことができました。\n今はRSpecだけでなくPHPUnitやJestを用いたテストコードを書く機会がありますが、これらのテストフレームワークを使う上でも研修で学んだ内容が役に立っています。\n\nおわりに\n\n以上のような取り組みを通して、開発チームに新しくエンジニアとして加わったメンバーが、業務知識を素早く獲得し、チームに馴染み、開発の提案をして、ユーザへの価値提供に取り組んでいます。\nチームメンバーが新しく私を迎え入れるためにしてくれたことが今の開発に生きていると感じています。\n\nこれらの事例が、チームに新しく加わる人や、新しい人を迎えるチームにとって参考になれば幸いです。また、チームに加わった3ヶ月で自分がどのように感じ何が役に立っていたかの取り組みを残しておくことで、将来チームメンバーを迎え入れる側になったときにこれを見返してよい環境を提供できるようになれればと思います。\n\n[^1]: 同時にこれら (どんなことを考えて仕事をしているか、どんな感情であるか、何を理解していて何を理解していないのか) を言語化することで自らに対して明らかにする機会ともなります。\n"},{"id":"http://localhost:3000/posts/layered-dotfiles","url":"http://localhost:3000/posts/layered-dotfiles","title":"複数の環境に適応する、階層構造のdotfiles","summary":"こんにちは、やんまーです。 もう師走、早いですね... この記事はGMOペパボアドベントカレンダーの2日目のものです。 昨日はdaikiさんの「社会人エンジニアな僕が研究を続ける理由」でした。 記事の中の研究を通して自己表現をされているという表現が印象的でした。仕事に精を出しながらも、仕事とは異なるところで時間をとって継続的に物事に取り組むということに尊敬の念を持ちます。 私も見習いたいものです。 今日は変わって実践的な内容です。私の開発環境 dotfilesを紹介します。 dotfiles とは Unix / Linux の環境において、\\~/.bashrc、 \\~/.vimrc、 \\~/.","date_published":"2021-12-02T14:00:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%A4%87%E6%95%B0%E3%81%AE%E7%92%B0%E5%A2%83%E3%81%AB%E9%81%A9%E5%BF%9C%E3%81%99%E3%82%8B%E3%80%81%E9%9A%8E%E5%B1%A4%E6%A7%8B%E9%80%A0%E3%81%AEdotfiles,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["dotfiles","bash"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ca6edf3aaef534b7a78e695b95e86408cc670645","comment":"Post:「複数の環境に適応する、階層構造のdotfiles」\n","date_modified":"2021-12-02T14:03:04+09:00"}],"content_html":"<p>こんにちは、やんまーです。\nもう師走、早いですね...\nこの記事は<a href=\"https://adventar.org/calendars/6375\">GMOペパボアドベントカレンダー</a>の2日目のものです。</p>\n<p>昨日は<a href=\"https://twitter.com/_doew\">daiki</a>さんの「<a href=\"https://blog.d-sato.net/?p=116\">社会人エンジニアな僕が研究を続ける理由</a>」でした。\n記事の中の研究を通して自己表現をされているという表現が印象的でした。仕事に精を出しながらも、仕事とは異なるところで時間をとって継続的に物事に取り組むということに尊敬の念を持ちます。\n私も見習いたいものです。</p>\n<p>今日は変わって実践的な内容です。私の開発環境 dotfilesを紹介します。</p>\n<h2>dotfiles とは</h2>\n<p>Unix / Linux の環境において、<code>~/.bashrc</code>、 <code>~/.vimrc</code>、 <code>~/.gitconfig</code> のように <code>.</code> から始まる各アプリケーションの設定ファイルが <code>$HOME</code> ディレクトリに配置されることがよくあります。\nこれらの設定ファイルを自分の持っている複数のPCに適用したいというモチベーションや、PCを乗り換えた時のためにバックアップして復元したいというモチベーションから、ローカルのストレージ以外にも保存するということが行われています。</p>\n<p>こういった設定ファイル群とこれらをローカルストレージ以外の場所に保存することを指して dotfiles と呼び、GitHubのリポジトリで公開するなどしている人もいます。\nかくいう私も自らの設定ファイルを保存・公開している人の一人で、GitHubのリポジトリ (<a href=\"https://github.com/yammerjp/dotfiles\">yammerjp/dotfiles</a>) から誰でも見れるようにしています。</p>\n<h2>単純なdotfiles</h2>\n<p>本記事で後述する複数環境に対応した構成のまえに、単純なdotfilesの構成として <a href=\"https://github.com/yammerjp/dotfiles-mini\">yammerjp/dotfiles-mini</a> をみてみましょう。\nこのリポジトリには次のようなファイルがあります。</p>\n<table>\n<thead>\n<tr>\n<th>ファイル名</th>\n<th>ファイルの役割</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.gitconfig</code></td>\n<td>gitの設定</td>\n</tr>\n<tr>\n<td><code>.tmux.conf</code></td>\n<td>tmuxの設定</td>\n</tr>\n<tr>\n<td><code>.vimrc</code></td>\n<td>vimの設定</td>\n</tr>\n<tr>\n<td><code>.zshrc</code></td>\n<td>zshの設定</td>\n</tr>\n<tr>\n<td><code>README.md</code></td>\n<td>リポジトリ全体の説明</td>\n</tr>\n<tr>\n<td><code>run.sh</code></td>\n<td>dotfilesを適用するシェルスクリプト</td>\n</tr>\n</tbody>\n</table>\n<p>ここで注目するのは <code>run.sh</code> というシェルスクリプトです。\n内容の一部を抜粋すると以下のようになっています。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># リポジトリをダウンロードする</span>\n<span class=\"hljs-comment\"># ========================================</span>\n<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$HOME</span>\"</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/yammerjp/dotfiles-mini.git\n<span class=\"hljs-built_in\">cd</span> dotfiles-mini\n\n\n<span class=\"hljs-comment\"># シンボリックリンクを貼る</span>\n<span class=\"hljs-comment\"># ========================================</span>\nDOTFILES_DIR=`<span class=\"hljs-built_in\">pwd</span>`\nln -s <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$DOTFILES_DIR</span>/.zshrc\"</span> ~/.zshrc\nln -s <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$DOTFILES_DIR</span>/.vimrc\"</span> ~/.vimrc\nln -s <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$DOTFILES_DIR</span>/.gitconfig\"</span> ~/.gitconfig\nln -s <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$DOTFILES_DIR</span>/.tmux.conf\"</span> ~/.tmux.conf</code></pre>\n<p>GitHubからダウンロードしてくることと、設定を適用すること (シンボリックリンクを作成し <code>~/.zshrc</code> などで参照できるようにすること) を行なっています。\nこのように設定を保存・公開するだけでなく、あわせて設定を適用するスクリプトを付属させておくと便利に使えます。</p>\n<h2>複数環境にする需要</h2>\n<p>さてさて、上記のように各アプリケーションの設定を保存・公開し、適用するスクリプトも用意できたのですが、しばらくするとさらに欲が出てきてしまいます。</p>\n<ul>\n<li>複数のOSの環境 (片方がLinux、片方がmacOS) が手元にあり、それぞれの設定を管理したい <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></li>\n<li>同じOSの複数の環境 (職場のPCと自宅のPC) が手元にあり、それぞれの設定を管理したい</li>\n<li>会社で使っている設定は公開したくないが、自宅で使っている設定は公開したい</li>\n<li>複数の環境の設定の一部を共通化したい</li>\n</ul>\n<p>このように複数の環境が存在しそれぞれ異なる設定を保持したい場合や、設定の公開範囲を制御したい場合に役立つのが、今回紹介する複数環境に適応した階層構造のdotfilesです。</p>\n<h2>階層構造の実装</h2>\n<p>公開範囲や適用環境を複数定めることができるように、以下のような構成をつくります。</p>\n<ul>\n<li>いくつかの設定ファイルを含むディレクトリを複数用意する (階層とよぶ)</li>\n<li>用意した階層の中から任意の順番で任意の個数の階層を選び、順番に適用する。</li>\n</ul>\n<p>複数の階層 (ディレクトリ) に分割することで、一部はGitHubのパブリックリポジトリに置かないという選択肢もとれますし、一部のPCでは特定の階層を適用しないという選択肢もとれます。\nまた、<code>順番に適用する</code> とあるように、各階層で設定ファイルが重複するとき、優先順位を指定することができるようにしています。</p>\n<p>具体的に私の環境は以下のようなディレクトリの階層構造になっています。</p>\n<ul>\n<li>自宅のMacbook Air\n<ul>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/Darwin--arm64\"><code>Darwin--arm64</code> 階層</a></li>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/Darwin\"><code>Darwin</code> 階層</a></li>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/common\"><code>common</code> 階層</a></li>\n</ul>\n</li>\n<li>会社のMacbook Pro\n<ul>\n<li><code>company</code> 階層</li>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/Darwin--x86_64\"><code>Darwin--x86_64</code> 階層</a></li>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/Darwin\"><code>Darwin</code> 階層</a></li>\n<li><a href=\"https://github.com/yammerjp/dotfiles/tree/f246a47414789fb17372fe6ee44f238405d7c194/env/common\"><code>common</code> 階層</a></li>\n</ul>\n</li>\n</ul>\n<p>全ての環境に共通の設定を集めた最も下の階層として <code>common</code> 階層を配置しています。\nその上の階層として、macOSのみに必要な設定を <code>Darwin</code> 階層に、さらに上の階層として arm64 / x86_64 の macOS に必要な設定をそれぞれ <code>Darwin--arm64</code> 階層, <code>Darwin--x86_64</code> 階層に配置し、commonなどの下の階層の設定を一部上書きます。\n加えて最上位の階層として、会社のPCで利用している公開できない設定などを含んだ <code>company</code> 階層を配置し、これは会社のGitサーバで管理するようにしています。</p>\n<p><img src=\"https://blob.yammer.jp/layered-dotfiles.png\" alt=\"階層構造のdotfilesのイメージ図\"></p>\n<p>このような階層構造は、各設定ファイルを適用する (シンボリックリンクを貼る) スクリプトを工夫することで実現しています。\n実際に実行されるスクリプトの動作とともに紹介します。\n例えば以下のようなコマンドを実行することを考えます。</p>\n<pre><code class=\"hljs language-sh\">DOTFILE_DIRS=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$HOME</span>/src/github.com/yammerjp/dotfiles/env/Darwin--arm64:<span class=\"hljs-variable\">$HOME</span>/src/github.com/yammerjp/dotfiles/env/Darwin:<span class=\"hljs-variable\">$HOME</span>/src/github.com/yammerjp/dotfiles/env/common\"</span> ./bin/dotfiles link</code></pre>\n<p><a href=\"https://github.com/yammerjp/dotfiles/blob/baa8cd1ecc183481ab29a402607cdc638864f6f5/bin/dotfiles\"><code>bin/dotfiles</code></a> は変数 <code>$DOTFILE_DIRS</code> に <code>:</code> で区切られたディレクトリの列が指定されることを期待します。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>\nまた指定されたディレクトリ列がそのまま、各階層のルートディレクトリとなります。なお先に記述されたものが上位の階層として扱われます。</p>\n<p>今回でいえば上位から順に3つの階層をもちます。</p>\n<ul>\n<li><code>Darwin--arm64</code> 階層 <a href=\"https://github.com/yammerjp/dotfiles/tree/baa8cd1ecc183481ab29a402607cdc638864f6f5/env/Darwin--arm64\"><code>$HOME/src/github.com/yammerjp/dotfiles/env/Darwin--arm64</code></a></li>\n<li><code>Darwin</code> 階層 <a href=\"https://github.com/yammerjp/dotfiles/tree/baa8cd1ecc183481ab29a402607cdc638864f6f5/env/Darwin\"><code>$HOME/src/github.com/yammerjp/dotfiles/env/Darwin</code></a></li>\n<li><code>common</code> 階層 <a href=\"https://github.com/yammerjp/dotfiles/tree/baa8cd1ecc183481ab29a402607cdc638864f6f5/env/common\"><code>$HOME/src/github.com/yammerjp/dotfiles/env/common</code></a></li>\n</ul>\n<p>それぞれの階層のディレクトリにあるファイルからホームディレクトリへ、シンボリックリンクが作成されます。\nこのとき、それぞれの階層のディレクトリの中で、階層の起点となるディレクトリから同名の相対パスのファイルがあれば、その中で最も上位の階層のファイルのみホームディレクトリへシンボリックリンクが貼られます。</p>\n<p>例えば各階層 (<code>Darwin--arm64</code>, <code>Darwin</code>, <code>common</code>) に <code>.zshrc</code> があるとき、最も上位の階層のものである <a href=\"https://github.com/yammerjp/dotfiles/blob/baa8cd1ecc183481ab29a402607cdc638864f6f5/env/Darwin--arm64/.zshrc\"><code>Darwin--arm64</code> 階層の <code>.zshrc</code></a> から <code>$HOME/.zshrc</code> へシンボリックリンクが貼られます。</p>\n<h2>各設定ファイルでの工夫</h2>\n<p>上述のように同名のファイルは上位階層が優先されてしまうので、設定ファイルの一部を共通化したいときは、ファイルを分割して用意することで対応しています。</p>\n<p>例えば <a href=\"https://github.com/yammerjp/dotfiles/blob/f246a47414789fb17372fe6ee44f238405d7c194/env/common/.zshrc\"><code>common</code> 階層の <code>.zshrc</code></a> は無視されてしまうので、設定の中身は同階層の <a href=\"https://github.com/yammerjp/dotfiles/blob/f246a47414789fb17372fe6ee44f238405d7c194/env/common/.zshrc-common\"><code>.zshrc-common</code></a> に切り出し、<code>.zshrc</code> ではそれを読み込むだけにします。\n同様に <code>Darwin</code> 階層では内容を <code>.zshrc-darwin</code> に、 <code>Darwin--arm64</code> 階層では内容を <code>.zshrc-darwin-arm64</code> に記述し、各 <code>.zshrc</code> は自身の階層と下位階層の <code>~/.zshrc-*</code> を読み込むだけにして、上書きされても問題ないようにしています。</p>\n<p><img src=\"https://blob.yammer.jp/layered-dotfiles-overwriting.png\" alt=\".zshrcは上書きされるので、.zshrc-*に切り出している様子のイメージ図\"></p>\n<p>このような行為は他の設定ファイルでも行なっていて、例えば <code>.gitconfig</code> にも include の仕組みがあるので、<code>.gitconfig</code> は上書きされてもいいように <a href=\"https://github.com/yammerjp/dotfiles/blob/f246a47414789fb17372fe6ee44f238405d7c194/env/common/.gitconfig-common\"><code>.gitconfig-common</code></a> に設定を書いて <a href=\"https://github.com/yammerjp/dotfiles/blob/f246a47414789fb17372fe6ee44f238405d7c194/env/common/.gitconfig\"><code>.gitconfig</code></a> はそれを読み込むだけにしています。</p>\n<h2>おわりに</h2>\n<p>こうして工夫をすることで、自宅のUbuntuでも、会社のMacbookでも、サクッと用意したEC2でもすぐに自分の環境が用意できる仕組みを作っています。\n設定ファイルだけでなく、パッケージのインストールやOSの設定の変更などのスクリプトも管理しようとしています。\nこれは生産性を向上させるためというより、それを歌いながらもdotfilesを育てていくのが楽しいだけなのですが、少しばかりは便利になっているはずです。\n今日は私のdotfilesを紹介したので、ぜひ皆さんのご自慢のdotfilesがあれば教えてください。</p>\n<p>というわけでアドベントカレンダー2日目の記事を終わりにします。\n何も考えずに「ええやろ！」という気持ちで2日目にエントリーしましたがひとまず書き終え安心しています。\n明日は<a href=\"https://twitter.com/ch11aki\">akichan</a>さんです、バトンを託します！</p>\n<hr>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">このことだけであれば、OSごとに設定が違うときは各設定ファイルの中で分岐するように記述すれば解決できるものもあるでしょう。例えば <code>~/.zshrc</code> などは if 文で分岐すれば済みます。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">実際には <code>common</code> や <code>Darwin</code>, <code>Darwin--arm64</code> といったディレクトリはデフォルトで指定されるようにしています。OS(とLinuxならディストリビューション名) とCPUのアーキテクチャから、<a href=\"https://github.com/yammerjp/dotfiles/blob/f246a47414789fb17372fe6ee44f238405d7c194/bin/link-list.sh#L37-L42\">それぞれの環境に即した3-4階層を定めています</a>。会社のGitリポジトリで管理している設定やGitHubのプライベートリポジトリで管理している設定を適用したいときに、 <code>$DOTFILE_DIR</code> などの変数にそのディレクトリのパスを与えると、デフォルトの3-4層に上位階層としてこれを加えた状態となるようにしています。階層の追加は後からでもできる (コマンドを叩けばシンボリックリンクを貼り直せる) ので、新しい環境では (そのOSとアーキテクチャに即した設定を用意していれば) <code>./bin/dotfiles link</code> とするだけでよくて、あとから必要な階層を足していくようにして運用しています。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"こんにちは、やんまーです。\nもう師走、早いですね...\nこの記事はGMOペパボアドベントカレンダーの2日目のものです。\n\n昨日はdaikiさんの「社会人エンジニアな僕が研究を続ける理由」でした。\n記事の中の研究を通して自己表現をされているという表現が印象的でした。仕事に精を出しながらも、仕事とは異なるところで時間をとって継続的に物事に取り組むということに尊敬の念を持ちます。\n私も見習いたいものです。\n\n今日は変わって実践的な内容です。私の開発環境 dotfilesを紹介します。\n\ndotfiles とは\n\nUnix / Linux の環境において、\\~/.bashrc、 \\~/.vimrc、 \\~/.gitconfig のように . から始まる各アプリケーションの設定ファイルが $HOME ディレクトリに配置されることがよくあります。\nこれらの設定ファイルを自分の持っている複数のPCに適用したいというモチベーションや、PCを乗り換えた時のためにバックアップして復元したいというモチベーションから、ローカルのストレージ以外にも保存するということが行われています。\n\nこういった設定ファイル群とこれらをローカルストレージ以外の場所に保存することを指して dotfiles と呼び、GitHubのリポジトリで公開するなどしている人もいます。\nかくいう私も自らの設定ファイルを保存・公開している人の一人で、GitHubのリポジトリ (yammerjp/dotfiles) から誰でも見れるようにしています。\n\n単純なdotfiles\n\n本記事で後述する複数環境に対応した構成のまえに、単純なdotfilesの構成として yammerjp/dotfiles-mini をみてみましょう。\nこのリポジトリには次のようなファイルがあります。\n\n\n\nここで注目するのは run.sh というシェルスクリプトです。\n内容の一部を抜粋すると以下のようになっています。\n\n\n\nGitHubからダウンロードしてくることと、設定を適用すること (シンボリックリンクを作成し \\~/.zshrc などで参照できるようにすること) を行なっています。\nこのように設定を保存・公開するだけでなく、あわせて設定を適用するスクリプトを付属させておくと便利に使えます。\n\n複数環境にする需要\n\nさてさて、上記のように各アプリケーションの設定を保存・公開し、適用するスクリプトも用意できたのですが、しばらくするとさらに欲が出てきてしまいます。\n\n複数のOSの環境 (片方がLinux、片方がmacOS) が手元にあり、それぞれの設定を管理したい [^1]\n\n同じOSの複数の環境 (職場のPCと自宅のPC) が手元にあり、それぞれの設定を管理したい\n\n会社で使っている設定は公開したくないが、自宅で使っている設定は公開したい\n\n複数の環境の設定の一部を共通化したい\n\nこのように複数の環境が存在しそれぞれ異なる設定を保持したい場合や、設定の公開範囲を制御したい場合に役立つのが、今回紹介する複数環境に適応した階層構造のdotfilesです。\n\n階層構造の実装\n\n公開範囲や適用環境を複数定めることができるように、以下のような構成をつくります。\n\nいくつかの設定ファイルを含むディレクトリを複数用意する (階層とよぶ)\n\n用意した階層の中から任意の順番で任意の個数の階層を選び、順番に適用する。\n\n複数の階層 (ディレクトリ) に分割することで、一部はGitHubのパブリックリポジトリに置かないという選択肢もとれますし、一部のPCでは特定の階層を適用しないという選択肢もとれます。\nまた、順番に適用する とあるように、各階層で設定ファイルが重複するとき、優先順位を指定することができるようにしています。\n\n具体的に私の環境は以下のようなディレクトリの階層構造になっています。\n\n自宅のMacbook Air\n\nDarwin--arm64 階層\n\nDarwin 階層\n\ncommon 階層\n\n会社のMacbook Pro\n\ncompany 階層\n\nDarwin--x86\\_64 階層\n\nDarwin 階層\n\ncommon 階層\n\n全ての環境に共通の設定を集めた最も下の階層として common 階層を配置しています。\nその上の階層として、macOSのみに必要な設定を Darwin 階層に、さらに上の階層として arm64 / x86\\_64 の macOS に必要な設定をそれぞれ Darwin--arm64 階層, Darwin--x86\\_64 階層に配置し、commonなどの下の階層の設定を一部上書きます。\n加えて最上位の階層として、会社のPCで利用している公開できない設定などを含んだ company 階層を配置し、これは会社のGitサーバで管理するようにしています。\n\n階層構造のdotfilesのイメージ図\n\nこのような階層構造は、各設定ファイルを適用する (シンボリックリンクを貼る) スクリプトを工夫することで実現しています。\n実際に実行されるスクリプトの動作とともに紹介します。\n例えば以下のようなコマンドを実行することを考えます。\n\n\n\nbin/dotfiles は変数 $DOTFILE_DIRS に : で区切られたディレクトリの列が指定されることを期待します。[^2]\nまた指定されたディレクトリ列がそのまま、各階層のルートディレクトリとなります。なお先に記述されたものが上位の階層として扱われます。\n\n今回でいえば上位から順に3つの階層をもちます。\n\nDarwin--arm64 階層 $HOME/src/github.com/yammerjp/dotfiles/env/Darwin--arm64\n\nDarwin 階層 $HOME/src/github.com/yammerjp/dotfiles/env/Darwin\n\ncommon 階層 $HOME/src/github.com/yammerjp/dotfiles/env/common\n\nそれぞれの階層のディレクトリにあるファイルからホームディレクトリへ、シンボリックリンクが作成されます。\nこのとき、それぞれの階層のディレクトリの中で、階層の起点となるディレクトリから同名の相対パスのファイルがあれば、その中で最も上位の階層のファイルのみホームディレクトリへシンボリックリンクが貼られます。\n\n例えば各階層 (Darwin--arm64, Darwin, common) に .zshrc があるとき、最も上位の階層のものである Darwin--arm64 階層の .zshrc から $HOME/.zshrc へシンボリックリンクが貼られます。\n\n各設定ファイルでの工夫\n\n上述のように同名のファイルは上位階層が優先されてしまうので、設定ファイルの一部を共通化したいときは、ファイルを分割して用意することで対応しています。\n\n例えば common 階層の .zshrc は無視されてしまうので、設定の中身は同階層の .zshrc-common に切り出し、.zshrc ではそれを読み込むだけにします。\n同様に Darwin 階層では内容を .zshrc-darwin に、 Darwin--arm64 階層では内容を .zshrc-darwin-arm64 に記述し、各 .zshrc は自身の階層と下位階層の \\~/.zshrc-\\* を読み込むだけにして、上書きされても問題ないようにしています。\n\n.zshrcは上書きされるので、.zshrc-\\*に切り出している様子のイメージ図\n\nこのような行為は他の設定ファイルでも行なっていて、例えば .gitconfig にも include の仕組みがあるので、.gitconfig は上書きされてもいいように .gitconfig-common に設定を書いて .gitconfig はそれを読み込むだけにしています。\n\nおわりに\n\nこうして工夫をすることで、自宅のUbuntuでも、会社のMacbookでも、サクッと用意したEC2でもすぐに自分の環境が用意できる仕組みを作っています。\n設定ファイルだけでなく、パッケージのインストールやOSの設定の変更などのスクリプトも管理しようとしています。\nこれは生産性を向上させるためというより、それを歌いながらもdotfilesを育てていくのが楽しいだけなのですが、少しばかりは便利になっているはずです。\n今日は私のdotfilesを紹介したので、ぜひ皆さんのご自慢のdotfilesがあれば教えてください。\n\nというわけでアドベントカレンダー2日目の記事を終わりにします。\n何も考えずに「ええやろ！」という気持ちで2日目にエントリーしましたがひとまず書き終え安心しています。\n明日はakichanさんです、バトンを託します！\n\n\n\n[^1]: このことだけであれば、OSごとに設定が違うときは各設定ファイルの中で分岐するように記述すれば解決できるものもあるでしょう。例えば \\~/.zshrc などは if 文で分岐すれば済みます。\n\n[^2]: 実際には common や Darwin, Darwin--arm64 といったディレクトリはデフォルトで指定されるようにしています。OS(とLinuxならディストリビューション名) とCPUのアーキテクチャから、それぞれの環境に即した3-4階層を定めています。会社のGitリポジトリで管理している設定やGitHubのプライベートリポジトリで管理している設定を適用したいときに、 $DOTFILE_DIR などの変数にそのディレクトリのパスを与えると、デフォルトの3-4層に上位階層としてこれを加えた状態となるようにしています。階層の追加は後からでもできる (コマンドを叩けばシンボリックリンクを貼り直せる) ので、新しい環境では (そのOSとアーキテクチャに即した設定を用意していれば) ./bin/dotfiles link とするだけでよくて、あとから必要な階層を足していくようにして運用しています。\n"},{"id":"http://localhost:3000/posts/restrict-git-master-push","url":"http://localhost:3000/posts/restrict-git-master-push","title":"master push をしないために","summary":"昨日、master push をしてしまいましたので懺悔します。 私の会社の開発は、GitHub Enterprise Server上のPull Requestベースで行われており、開発した機能をPull Reqeustにしてレビューを貰ってからマージすることとなっています。 しかしながら昨日の私は、ローカルで作ったcommitをそのままリモートリポジトリのmasterブランチにpushしてしまいました。 masterにマージするだけでは本番にはデプロイされませんが、複数のチームが開発しているリポジトリであり、各方面に迷惑をおかけしました。 私がやらかした後、master pushを防ぐ術を教","date_published":"2021-11-09T10:31:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:master%20push%20%E3%82%92%E3%81%97%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%81%AB,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["git","GitHub","Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/d9d24ca3074ce42bce687a6bce8cd5479fc69cdb","comment":"Post: 「master pushしないために」\n","date_modified":"2021-11-09T10:36:33+09:00"}],"content_html":"<p>昨日、master push をしてしまいましたので懺悔します。</p>\n<p>私の会社の開発は、GitHub Enterprise Server上のPull Requestベースで行われており、開発した機能をPull Reqeustにしてレビューを貰ってからマージすることとなっています。\nしかしながら昨日の私は、ローカルで作ったcommitをそのままリモートリポジトリのmasterブランチにpushしてしまいました。\nmasterにマージするだけでは本番にはデプロイされませんが、複数のチームが開発しているリポジトリであり、各方面に迷惑をおかけしました。</p>\n<p>私がやらかした後、master pushを防ぐ術を教えていただいたので、以下に記します。</p>\n<h2>GitHub上で branch protection を行う</h2>\n<p>ルールを設定し、force pushできないようにしたり、レビュー必須としたりすることで特定のブランチが不当に変更されることを防ぎます。</p>\n<p>(当該リポジトリでは masterブランチに対し branch protection は設定されていましたが、私が管理者権限を持っていたのでpushできてしまいました。)</p>\n<p><a href=\"https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/managing-a-branch-protection-rule\">ブランチ保護ルールを管理する - GitHub Docs</a></p>\n<h2>\"include administrators\" を有効にする</h2>\n<p>GitHubのbranch protectionの設定の中で、\"include administrators\" (管理者を含める) という項目が設定できます。\nこれにより、管理者権限を持つ人であっても、branch protectionのルールが適用されるようになります。</p>\n<p><a href=\"https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#include-administrators\">保護されたブランチについて - GitHub Docs</a></p>\n<h2>ローカルのGit Hooksでmaster/mainへのpushを制限する</h2>\n<p>gitには特定の操作の前後にスクリプトを実行できるhooksという機能があります。\nhooksは、グローバルに有効なスクリプトを指定することもできるので、これを用いて以下のような設定を記述します。</p>\n<h3><code>~/.gitconfig</code> にグローバルに有効なhooksのディレクトリを指定</h3>\n<p><code>~/.gitconfig</code> に以下のように記述することで、そのコンピュータでgitコマンドを実行したとき、常に <code>~/.config/git/hooks</code> 以下のhooksが参照されるようになります。</p>\n<pre><code>[core]\n        hooksPath = ~/.config/git/hooks\n</code></pre>\n<h3><code>~/.config/git/hooks/pre-push</code> にmaster/mainブランチへのpushを禁止するよう記述 / ローカルフックを呼び出すよう記述</h3>\n<p>グローバルなhooksに指定されたディレクトリの下に、実行権限をもつ <code>~/.config/git/hooks/pre-push</code> というファイルを配置し、以下のような記述をします。</p>\n<p><code>~/.config/git/hooks</code></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash -e</span>\n\nlines=<span class=\"hljs-string\">\"<span class=\"hljs-subst\">$(cat)</span>\"</span>\n\n<span class=\"hljs-comment\"># branch protection</span>\n<span class=\"hljs-comment\"># 標準入力 $lines にブランチ名などが渡される</span>\n<span class=\"hljs-comment\"># $lines をもとに、master/mainブランチへのpushであれば、終了コードを1としてpushを中断</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">restrict_master_push</span></span>() {\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$lines</span>\"</span> | <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> local_ref local_sha1 remote_ref remote_sha1\n  <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$remote_ref</span>\"</span> = <span class=\"hljs-string\">\"refs/heads/master\"</span> ]]; <span class=\"hljs-keyword\">then</span>\n      <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Do not push to master branch!!!\"</span> 1>&#x26;2\n      <span class=\"hljs-built_in\">exit</span> 1\n    <span class=\"hljs-keyword\">fi</span>\n\n    <span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">${remote_ref}</span>\"</span> = <span class=\"hljs-string\">\"refs/heads/main\"</span> ]]; <span class=\"hljs-keyword\">then</span>\n      <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Do not push to main branch!!!\"</span> 1>&#x26;2\n      <span class=\"hljs-built_in\">exit</span> 1\n    <span class=\"hljs-keyword\">fi</span>\n  <span class=\"hljs-keyword\">done</span>\n}\n\n<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"<span class=\"hljs-subst\">$(git config remote.origin.url)</span>\"</span> <span class=\"hljs-keyword\">in</span>\n  <span class=\"hljs-comment\"># 自分しか使わないリポジトリなど、master/mainにpushしてよいものはskipするようにする</span>\n  <span class=\"hljs-string\">\"git@github.com:yammer/dotfiles.git\"</span> )\n    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'skip restrict_master_push()'</span> 1>&#x26;2\n    ;;\n  * )\n    restrict_master_push\n    ;;\n<span class=\"hljs-keyword\">esac</span>\n\n\n<span class=\"hljs-comment\"># kick local hooks</span>\n<span class=\"hljs-comment\"># グローバルにgit hooksを指定してしまうと、各リポジトリのhooksは実行されない</span>\n<span class=\"hljs-comment\"># そこで、このシェルスクリプト内で、各リポジトリのhooksを読み込んで実行するようにする</span>\ngit_root=`git rev-parse --show-superproject-working-tree --show-toplevel | head -1`\nhook_name=`basename <span class=\"hljs-variable\">$0</span>`\nlocal_hook=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">${git_root}</span>/.git/hooks/<span class=\"hljs-variable\">${hook_name}</span>\"</span>\n\n<span class=\"hljs-keyword\">if</span> [ -e <span class=\"hljs-variable\">$local_hook</span> ]; <span class=\"hljs-keyword\">then</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$lines</span>\"</span> | bash <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$local_hook</span>\"</span> $*\n  <span class=\"hljs-built_in\">exit</span> <span class=\"hljs-string\">\"$?\"</span>\n<span class=\"hljs-keyword\">fi</span></code></pre>\n<h3><code>~/.config/git/hooks</code> 以下の他のhooksにも、ローカルフックを呼び出すよう記述</h3>\n<p>以下のファイル名の実行ファイルを作成し、スクリプトを記述します。</p>\n<ul>\n<li><code>~/.config/git/hooks/applypatch-msg</code></li>\n<li><code>~/.config/git/hooks/commit-msg</code></li>\n<li><code>~/.config/git/hooks/fsmonitor-watchman</code></li>\n<li><code>~/.config/git/hooks/post-update</code></li>\n<li><code>~/.config/git/hooks/pre-applypatch</code></li>\n<li><code>~/.config/git/hooks/pre-commit</code></li>\n<li><code>~/.config/git/hooks/pre-merge-commit</code></li>\n<li><code>~/.config/git/hooks/pre-rebase</code></li>\n<li><code>~/.config/git/hooks/pre-receive</code></li>\n<li><code>~/.config/git/hooks/prepare-commit-msg</code></li>\n<li><code>~/.config/git/hooks/push-to-checkout</code></li>\n<li><code>~/.config/git/hooks/update</code></li>\n</ul>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash -e</span>\n\nlines=<span class=\"hljs-string\">\"<span class=\"hljs-subst\">$(cat)</span>\"</span>\n\n<span class=\"hljs-comment\"># anything</span>\n\n<span class=\"hljs-comment\"># kick local hooks</span>\n<span class=\"hljs-comment\"># グローバルにgit hooksを指定してしまうと、各リポジトリのhooksは実行されない</span>\n<span class=\"hljs-comment\"># そこで、このシェルスクリプト内で、各リポジトリのhooksを読み込んで実行するようにする</span>\ngit_root=`git rev-parse --show-superproject-working-tree --show-toplevel | head -1`\nhook_name=`basename <span class=\"hljs-variable\">$0</span>`\nlocal_hook=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">${git_root}</span>/.git/hooks/<span class=\"hljs-variable\">${hook_name}</span>\"</span>\n\n<span class=\"hljs-keyword\">if</span> [ -e <span class=\"hljs-variable\">$local_hook</span> ]; <span class=\"hljs-keyword\">then</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$lines</span>\"</span> | bash <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$local_hook</span>\"</span> $*\n  <span class=\"hljs-built_in\">exit</span> <span class=\"hljs-string\">\"$?\"</span>\n<span class=\"hljs-keyword\">if</span></code></pre>\n","content_text":"昨日、master push をしてしまいましたので懺悔します。\n\n私の会社の開発は、GitHub Enterprise Server上のPull Requestベースで行われており、開発した機能をPull Reqeustにしてレビューを貰ってからマージすることとなっています。\nしかしながら昨日の私は、ローカルで作ったcommitをそのままリモートリポジトリのmasterブランチにpushしてしまいました。\nmasterにマージするだけでは本番にはデプロイされませんが、複数のチームが開発しているリポジトリであり、各方面に迷惑をおかけしました。\n\n私がやらかした後、master pushを防ぐ術を教えていただいたので、以下に記します。\n\nGitHub上で branch protection を行う\n\nルールを設定し、force pushできないようにしたり、レビュー必須としたりすることで特定のブランチが不当に変更されることを防ぎます。\n\n(当該リポジトリでは masterブランチに対し branch protection は設定されていましたが、私が管理者権限を持っていたのでpushできてしまいました。)\n\nブランチ保護ルールを管理する - GitHub Docs\n\n\"include administrators\" を有効にする\n\nGitHubのbranch protectionの設定の中で、\"include administrators\" (管理者を含める) という項目が設定できます。\nこれにより、管理者権限を持つ人であっても、branch protectionのルールが適用されるようになります。\n\n保護されたブランチについて - GitHub Docs\n\nローカルのGit Hooksでmaster/mainへのpushを制限する\n\ngitには特定の操作の前後にスクリプトを実行できるhooksという機能があります。\nhooksは、グローバルに有効なスクリプトを指定することもできるので、これを用いて以下のような設定を記述します。\n\n\\~/.gitconfig にグローバルに有効なhooksのディレクトリを指定\n\n\\~/.gitconfig に以下のように記述することで、そのコンピュータでgitコマンドを実行したとき、常に \\~/.config/git/hooks 以下のhooksが参照されるようになります。\n\n\n\n\\~/.config/git/hooks/pre-push にmaster/mainブランチへのpushを禁止するよう記述 / ローカルフックを呼び出すよう記述\n\nグローバルなhooksに指定されたディレクトリの下に、実行権限をもつ \\~/.config/git/hooks/pre-push というファイルを配置し、以下のような記述をします。\n\n\\~/.config/git/hooks\n\n\n\n\\~/.config/git/hooks 以下の他のhooksにも、ローカルフックを呼び出すよう記述\n\n以下のファイル名の実行ファイルを作成し、スクリプトを記述します。\n\n\\~/.config/git/hooks/applypatch-msg\n\n\\~/.config/git/hooks/commit-msg\n\n\\~/.config/git/hooks/fsmonitor-watchman\n\n\\~/.config/git/hooks/post-update\n\n\\~/.config/git/hooks/pre-applypatch\n\n\\~/.config/git/hooks/pre-commit\n\n\\~/.config/git/hooks/pre-merge-commit\n\n\\~/.config/git/hooks/pre-rebase\n\n\\~/.config/git/hooks/pre-receive\n\n\\~/.config/git/hooks/prepare-commit-msg\n\n\\~/.config/git/hooks/push-to-checkout\n\n\\~/.config/git/hooks/update\n\n"},{"id":"http://localhost:3000/posts/competing-with-unicorns","url":"http://localhost:3000/posts/competing-with-unicorns","title":"ユニコーン企業のひみつを読んだ","summary":"8月も折り返し、いかがお過ごしでしょうか？8月は夏ですね。夏といえば夏休み、夏休みといえば宿題、読書感想文[^1]。ということで読んだ本の感想を綴ります。読書メモが下書きに溜まってしまっているので消化する試みです。 書籍「ユニコーン企業のひみつ」を読みました。 本書はSpotify をはじめとするテック企業が、スタートアップのような勢いのある価値提供をどうやってスケールさせているかを説明する、ソフトウェア開発企業の組織づくりについて説明されたものです。 今年の4月に日本語訳版が発売され、私の所属する会社の社内で広く読まれているようです。 本書籍内でも言及されるSpotifyモデルと呼ばれる組織","date_published":"2021-08-18T22:28:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%A6%E3%83%8B%E3%82%B3%E3%83%BC%E3%83%B3%E4%BC%81%E6%A5%AD%E3%81%AE%E3%81%B2%E3%81%BF%E3%81%A4%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/20ac6fedeef46ffb01b8be3f77b7f34de6bed7ea","comment":"Post: 「ユニコーン企業のひみつを読んだ」\n","date_modified":"2021-08-18T22:28:09+09:00"}],"content_html":"<p>8月も折り返し、いかがお過ごしでしょうか？8月は夏ですね。夏といえば夏休み、夏休みといえば宿題、読書感想文<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>。ということで読んだ本の感想を綴ります。読書メモが下書きに溜まってしまっているので消化する試みです。</p>\n<p>書籍「ユニコーン企業のひみつ」を読みました。\n本書はSpotify をはじめとするテック企業が、スタートアップのような勢いのある価値提供をどうやってスケールさせているかを説明する、ソフトウェア開発企業の組織づくりについて説明されたものです。</p>\n<p>今年の4月に日本語訳版が発売され、私の所属する会社の社内で広く読まれているようです。\n本書籍内でも言及されるSpotifyモデルと呼ばれる組織体制を、社内でもいくつかの事業部で取り入れています。\nそういった背景から書籍内で用いられている「スクワット」「チャプター」「トライブ」といった言葉が会話に出現するので、知っていないとコミュニケーションコストが高くなってしまいもったいないと感じ、7月の4連休にガッと読みました。</p>\n<p>書籍内では次のようなことが言及されています。</p>\n<ul>\n<li>権限を持つ職能横断の小さなチーム(スクワット)によって組織を構成することで、自己組織化が進み、強力なデリバリーを届ける</li>\n<li>イテレーションを回そう</li>\n<li>スクワットが価値提供する際の障壁を、組織として排除することで、本質的な課題に注力できる</li>\n<li>今日のソフトウェア開発はマラソンであり、一朝一夕にて成立するものではない</li>\n<li>目的(ミッション)をかかげ、それに至る方法はチームが考えることが大切。スクラムをただやるだけでは開発者はチケットを消化する機械になってしまう。それでは競争に勝てない</li>\n<li>会社組織におけるこれらの事柄は文化と深い関わりがある。文化の醸成も重要</li>\n</ul>\n<p>書籍の内容を通して、マネジメントを行う立場ではない一介のジュニアエンジニアとしては、次のことがまず自分にできることに思います。</p>\n<ul>\n<li>そういた背景をもって組織づくりがされていると知る</li>\n<li>目的を見て本質的な課題解決には何が必要かを考える</li>\n<li>局所最適化しない。会社として価値提供するためには自分の仕事を限定しない</li>\n</ul>\n<p>より良いサービスを届けるために文化は維持したまま、構成やあり方を変革し続けられる柔軟な組織は魅力的ですし、そういった組織の一翼を担う人として力が発揮できるようになりたいものです。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">昔は宿題を最終日にまとめてやってやる人間で、宿題の定番である読書感想文もあまり好んでおりませんでした。そんな人間も10年したら備忘録や思考整理のために自主的に読書の感想をWebに投稿しているのだから不思議です。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"8月も折り返し、いかがお過ごしでしょうか？8月は夏ですね。夏といえば夏休み、夏休みといえば宿題、読書感想文[^1]。ということで読んだ本の感想を綴ります。読書メモが下書きに溜まってしまっているので消化する試みです。\n\n書籍「ユニコーン企業のひみつ」を読みました。\n本書はSpotify をはじめとするテック企業が、スタートアップのような勢いのある価値提供をどうやってスケールさせているかを説明する、ソフトウェア開発企業の組織づくりについて説明されたものです。\n\n今年の4月に日本語訳版が発売され、私の所属する会社の社内で広く読まれているようです。\n本書籍内でも言及されるSpotifyモデルと呼ばれる組織体制を、社内でもいくつかの事業部で取り入れています。\nそういった背景から書籍内で用いられている「スクワット」「チャプター」「トライブ」といった言葉が会話に出現するので、知っていないとコミュニケーションコストが高くなってしまいもったいないと感じ、7月の4連休にガッと読みました。\n\n書籍内では次のようなことが言及されています。\n\n権限を持つ職能横断の小さなチーム(スクワット)によって組織を構成することで、自己組織化が進み、強力なデリバリーを届ける\n\nイテレーションを回そう\n\nスクワットが価値提供する際の障壁を、組織として排除することで、本質的な課題に注力できる\n\n今日のソフトウェア開発はマラソンであり、一朝一夕にて成立するものではない\n\n目的(ミッション)をかかげ、それに至る方法はチームが考えることが大切。スクラムをただやるだけでは開発者はチケットを消化する機械になってしまう。それでは競争に勝てない\n\n会社組織におけるこれらの事柄は文化と深い関わりがある。文化の醸成も重要\n\n書籍の内容を通して、マネジメントを行う立場ではない一介のジュニアエンジニアとしては、次のことがまず自分にできることに思います。\n\nそういた背景をもって組織づくりがされていると知る\n\n目的を見て本質的な課題解決には何が必要かを考える\n\n局所最適化しない。会社として価値提供するためには自分の仕事を限定しない\n\nより良いサービスを届けるために文化は維持したまま、構成やあり方を変革し続けられる柔軟な組織は魅力的ですし、そういった組織の一翼を担う人として力が発揮できるようになりたいものです。\n\n[^1]: 昔は宿題を最終日にまとめてやってやる人間で、宿題の定番である読書感想文もあまり好んでおりませんでした。そんな人間も10年したら備忘録や思考整理のために自主的に読書の感想をWebに投稿しているのだから不思議です。\n"},{"id":"http://localhost:3000/posts/english-for-apps","url":"http://localhost:3000/posts/english-for-apps","title":"アプリケーションをつくる英語を読んだ","summary":"会社の先輩に教えていただいた「アプリケーションをつくる英語」を読んだ。 この本はアプリケーション開発においてUIに表示される言葉を中心に、それらを英語でどう表現すればよいかのヒントが書かれている本である。 三部構成で前半の二部は辞書的に単語や表現が紹介され、最後の一部が読み物になっている。 前半の辞書的な部分は、プログラムを書く中で命名に迷ったり、エラーメッセージを書いたりするときに役立ちそうだった。 紹介されている単語や言い回しは比較的厳選されている。 自分の表したいニュアンスの言葉が確実にあるわけではないと思うが、ソフトウェアやUIに関係する言い回しに絞って書かれている。 迷ったときには和","date_published":"2021-07-14T23:54:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B%E8%8B%B1%E8%AA%9E%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本","プログラミング"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ba8f5194906a83871d9624e1e4e4bfd93b04e445","comment":"Post: 「アプリケーションをつくる英語を読んだ」\n","date_modified":"2021-07-14T23:54:41+09:00"}],"content_html":"<p>会社の先輩に教えていただいた「アプリケーションをつくる英語」を読んだ。</p>\n<p>この本はアプリケーション開発においてUIに表示される言葉を中心に、それらを英語でどう表現すればよいかのヒントが書かれている本である。\n三部構成で前半の二部は辞書的に単語や表現が紹介され、最後の一部が読み物になっている。</p>\n<p>前半の辞書的な部分は、プログラムを書く中で命名に迷ったり、エラーメッセージを書いたりするときに役立ちそうだった。\n紹介されている単語や言い回しは比較的厳選されている。\n自分の表したいニュアンスの言葉が確実にあるわけではないと思うが、ソフトウェアやUIに関係する言い回しに絞って書かれている。\n迷ったときには和英辞書と合わせて、本書のPDF版を検索して参照したい。</p>\n<br />\n<p>後半の読み物のなかでは、35.3.2節 キャピタリゼーション (どの文字を大文字にするか) が特に気になった。</p>\n<p>恥ずかしながら本書を読んで明確なルールを初めて知ったのだが、文頭を大文字にするセンテンススタイル (通常の文に用いられる) の他に、より大文字にする単語数が多いタイトルスタイル/ヘッドラインスタイルと呼ばれるスタイルがある。\n名前の通り本のタイトルなどに使われるスタイルで、以下のようなルールがある。</p>\n<blockquote>\n<ul>\n<li>名詞、形容詞、副詞、代名詞はキャピタリゼーションする</li>\n<li>文の最初と最後の単語はキャピタリゼーションする</li>\n<li>冠詞 (a、an、the) と接続詞 (and、butなど) はキャピタリゼーションしない。ただし文の最初と最後の場合はする</li>\n<li>4文字以内の前置詞 (at、by、for、inなど) はキャピタリゼーションしない。ただし文の最初と最後の最後の場合はする</li>\n</ul>\n</blockquote>\n<div style=\"text-align: center; width: 100%; color: #505050; font-size: 14px;\">\n(アプリケーションをつくる英語 西野竜太郎著 p262)\n</div>\n<p>たとえばPCのGUIアプリケーションであればウィンドウのタイトルやメニューバーなどにタイトルスタイルが用いられている場合もあるだろう。\n例えばREADMEの章ごとのタイトルなどにも用いられるかもしれない。</p>\n<p>UIなどにおいては完全な文を書くというシチュエーションと同じかそれ以上に単語や連文節で物事を表す機会があるだろうから、どういった規則で表せれば良いかのルールを学べたのはありがたい。</p>\n<br />\n<p>後半の読み物の部分はそれほど分量がなくすぐに読めて、前半の辞書的な部分は長く使える、ひと粒で二度美味しい本だった。\nコンピュータと戯れている限り英語とは離れられないので、もっと仲良くなっていかねばならない。</p>\n","content_text":"会社の先輩に教えていただいた「アプリケーションをつくる英語」を読んだ。\n\nこの本はアプリケーション開発においてUIに表示される言葉を中心に、それらを英語でどう表現すればよいかのヒントが書かれている本である。\n三部構成で前半の二部は辞書的に単語や表現が紹介され、最後の一部が読み物になっている。\n\n前半の辞書的な部分は、プログラムを書く中で命名に迷ったり、エラーメッセージを書いたりするときに役立ちそうだった。\n紹介されている単語や言い回しは比較的厳選されている。\n自分の表したいニュアンスの言葉が確実にあるわけではないと思うが、ソフトウェアやUIに関係する言い回しに絞って書かれている。\n迷ったときには和英辞書と合わせて、本書のPDF版を検索して参照したい。\n\n\n\n後半の読み物のなかでは、35.3.2節 キャピタリゼーション (どの文字を大文字にするか) が特に気になった。\n\n恥ずかしながら本書を読んで明確なルールを初めて知ったのだが、文頭を大文字にするセンテンススタイル (通常の文に用いられる) の他に、より大文字にする単語数が多いタイトルスタイル/ヘッドラインスタイルと呼ばれるスタイルがある。\n名前の通り本のタイトルなどに使われるスタイルで、以下のようなルールがある。\n\n名詞、形容詞、副詞、代名詞はキャピタリゼーションする\n\n文の最初と最後の単語はキャピタリゼーションする\n\n冠詞 (a、an、the) と接続詞 (and、butなど) はキャピタリゼーションしない。ただし文の最初と最後の場合はする\n\n4文字以内の前置詞 (at、by、for、inなど) はキャピタリゼーションしない。ただし文の最初と最後の最後の場合はする\n\n\n\nたとえばPCのGUIアプリケーションであればウィンドウのタイトルやメニューバーなどにタイトルスタイルが用いられている場合もあるだろう。\n例えばREADMEの章ごとのタイトルなどにも用いられるかもしれない。\n\nUIなどにおいては完全な文を書くというシチュエーションと同じかそれ以上に単語や連文節で物事を表す機会があるだろうから、どういった規則で表せれば良いかのルールを学べたのはありがたい。\n\n\n\n後半の読み物の部分はそれほど分量がなくすぐに読めて、前半の辞書的な部分は長く使える、ひと粒で二度美味しい本だった。\nコンピュータと戯れている限り英語とは離れられないので、もっと仲良くなっていかねばならない。\n"},{"id":"http://localhost:3000/posts/software-is-not-ghost","url":"http://localhost:3000/posts/software-is-not-ghost","title":"ソフトウェアは幽霊などではない。👻","summary":"ソフトウェアを開発していると、ときどき幽霊に出会うことがある。正確にはまるで幽霊のしわざかに思えるような謎の挙動に悩まされるときがある。 実際には幽霊などおらずコンピュータは書かれたとおりに動作しているだけで、さらに大抵は自分がプロトコルや仕様を把握していないか誤ったプログラムを書いているのだが。 複数の要因が重なっていたりして挙動の説明がすぐにはつかないとき、原因を追求するためにだいたい次のようなことをする。 原因を考える (現状を整理する、アタリをつける) 挙動を確認するためにプログラムを実行する (手を動かす) 仕様やドキュメント等を調べる 人に聞く ここでは特に1つめの原因を考える事と","date_published":"2021-07-07T09:15:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AF%E5%B9%BD%E9%9C%8A%E3%81%AA%E3%81%A9%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%80%82%F0%9F%91%BB,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["プログラミング"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/f7a57a8bc24b1b0a8e87f73d299451e05baf2804","comment":"Post: 「ソフトウェアは幽霊などではない。👻」\n","date_modified":"2021-07-07T09:20:45+09:00"}],"content_html":"<p>ソフトウェアを開発していると、ときどき幽霊に出会うことがある。正確にはまるで幽霊のしわざかに思えるような謎の挙動に悩まされるときがある。</p>\n<p>実際には幽霊などおらずコンピュータは書かれたとおりに動作しているだけで、さらに大抵は自分がプロトコルや仕様を把握していないか誤ったプログラムを書いているのだが。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">幽霊</p>&mdash; やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1412326675157688326?ref_src=twsrc%5Etfw\">July 6, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<div style=\"text-align: center; width: 100%; color: #505050; font-size: 14px;\">\n  これは私がOAuth2.0の仕様を把握していなかったが故に謎と思った挙動になやまされたとき。\n</div>\n<p>複数の要因が重なっていたりして挙動の説明がすぐにはつかないとき、原因を追求するためにだいたい次のようなことをする。</p>\n<ol>\n<li>原因を考える (現状を整理する、アタリをつける)</li>\n<li>挙動を確認するためにプログラムを実行する (手を動かす)</li>\n<li>仕様やドキュメント等を調べる</li>\n<li>人に聞く</li>\n</ol>\n<p>ここでは特に1つめの原因を考える事と2つめの手を動かす事について注目する。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>\nこれらは、手を動かさないとわからない事を考えても意味は無いし、逆に無鉄砲に手を動かしても意味はない。現状を整理すること、アタリをつけること、手を動かしてみること、これらを組み合わせてやっていく必要がある。</p>\n<p>しかしながら特に昨日の私は原因を考えることと手を動かすことの比率が悪かった。またそもそも、目下の謎な挙動に対峙するとき、あまり自分の行動を分解して自らで認識せず全部一緒くたにしてやっているところがある。それですぐ解決できれば良いが、深みにハマったときに困る。</p>\n<p>二分探索的に考えていた筈が条件に漏れがあったり、試せばすぐにわかったことを最後まで放置していたりする <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> のはこういったところに原因があるかもしれないと思っていて、だとすると改善の余地がある。</p>\n<p>そこで、次に対峙するときは今整理してアタリをつけるべきなのか、情報が足りないから手を動かすべきなのか、自分の現状を認識して意識的に切り替えることを試してみたい。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>\nそのとき脳内で私が発すべき言葉は「現状を整理したいのか？新たな情報を得たいのか？ (=手を動かすべきか) 」という二択の自らへの問いかけである。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">3 のドキュメントを調べるという行為についても英語の仕様書をさくっとしっかり理解できるようにするだとかライブラリのコードを読み込むといった部分ががまだまだだし、4の人に聞くという行為も業務の中で最適なタイミングを逃していたり状況を整理して伝えるのが下手で時間がかかったりと、結局全部未熟なので粛々とやっていくしかない。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">解決したあとだからそう思うだけかもしれないが。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">実際には脳の力をそんなところに使う余裕はないのかもしれない。一方で業務でエンジニアリングに取り組むなら、時間的な見積もりをすべきである点と、再現可能な手法で行動して成果をあげるために自分の状態を認識するのは大切だろう点から、無心に対峙するのではなく上記の方法を試してみるべきだと感じた。<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"ソフトウェアを開発していると、ときどき幽霊に出会うことがある。正確にはまるで幽霊のしわざかに思えるような謎の挙動に悩まされるときがある。\n\n実際には幽霊などおらずコンピュータは書かれたとおりに動作しているだけで、さらに大抵は自分がプロトコルや仕様を把握していないか誤ったプログラムを書いているのだが。\n\n\n\n複数の要因が重なっていたりして挙動の説明がすぐにはつかないとき、原因を追求するためにだいたい次のようなことをする。\n\n原因を考える (現状を整理する、アタリをつける)\n\n挙動を確認するためにプログラムを実行する (手を動かす)\n\n仕様やドキュメント等を調べる\n\n人に聞く\n\nここでは特に1つめの原因を考える事と2つめの手を動かす事について注目する。[^1]\nこれらは、手を動かさないとわからない事を考えても意味は無いし、逆に無鉄砲に手を動かしても意味はない。現状を整理すること、アタリをつけること、手を動かしてみること、これらを組み合わせてやっていく必要がある。\n\nしかしながら特に昨日の私は原因を考えることと手を動かすことの比率が悪かった。またそもそも、目下の謎な挙動に対峙するとき、あまり自分の行動を分解して自らで認識せず全部一緒くたにしてやっているところがある。それですぐ解決できれば良いが、深みにハマったときに困る。\n\n二分探索的に考えていた筈が条件に漏れがあったり、試せばすぐにわかったことを最後まで放置していたりする [^2] のはこういったところに原因があるかもしれないと思っていて、だとすると改善の余地がある。\n\nそこで、次に対峙するときは今整理してアタリをつけるべきなのか、情報が足りないから手を動かすべきなのか、自分の現状を認識して意識的に切り替えることを試してみたい。[^3]\nそのとき脳内で私が発すべき言葉は「現状を整理したいのか？新たな情報を得たいのか？ (=手を動かすべきか) 」という二択の自らへの問いかけである。\n\n[^1]: 3 のドキュメントを調べるという行為についても英語の仕様書をさくっとしっかり理解できるようにするだとかライブラリのコードを読み込むといった部分ががまだまだだし、4の人に聞くという行為も業務の中で最適なタイミングを逃していたり状況を整理して伝えるのが下手で時間がかかったりと、結局全部未熟なので粛々とやっていくしかない。\n\n[^2]: 解決したあとだからそう思うだけかもしれないが。\n\n[^3]: 実際には脳の力をそんなところに使う余裕はないのかもしれない。一方で業務でエンジニアリングに取り組むなら、時間的な見積もりをすべきである点と、再現可能な手法で行動して成果をあげるために自分の状態を認識するのは大切だろう点から、無心に対峙するのではなく上記の方法を試してみるべきだと感じた。\n"},{"id":"http://localhost:3000/posts/20210624","url":"http://localhost:3000/posts/20210624","title":"初出社、ワクチン接種","summary":"日記です。雑多なトピックが以下に続きます。 4月に入社した会社に、今日はじめて出社しました。 新型コロナウィルスのワクチン接種が主な理由で、くわえて同期をはじめとして何人かに出会うなどしました。 今日の主なイベントであるワクチン接種ですが、大変スムーズで拍子抜けしました。 受付をして打つのは一瞬、15分経過観察しておわり。 職域接種のためいわゆるモデルナ筋注といわれるものを打って今は9時間ほど、腕が重いですね。 社の方々と会うのはちょっと緊張。 人との接触は抑える必要もあるのであまりたくさん会話できるわけでもなく、会えていない人もたくさんいて、それらは未来の機会に託しました。 新型コロナウィル","date_published":"2021-06-24T23:19:00+09:00","date_modified":"2021-06-24T23:26:20+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E5%88%9D%E5%87%BA%E7%A4%BE%E3%80%81%E3%83%AF%E3%82%AF%E3%83%81%E3%83%B3%E6%8E%A5%E7%A8%AE,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/09ce0b2d5b3f1a89c344d18d7924b7fd18ecf978","comment":"Update: 表現の修正\n","date_modified":"2021-06-24T23:26:20+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/72e42dd9b4f3a095371d5b01c77d48b81fdfee6f","comment":"Post: 「初出社、ワクチン接種」\n","date_modified":"2021-06-24T23:19:31+09:00"}],"content_html":"<p>日記です。雑多なトピックが以下に続きます。</p>\n<p>4月に入社した会社に、今日はじめて出社しました。\n新型コロナウィルスのワクチン接種が主な理由で、くわえて同期をはじめとして何人かに出会うなどしました。</p>\n<p>今日の主なイベントであるワクチン接種ですが、大変スムーズで拍子抜けしました。\n受付をして打つのは一瞬、15分経過観察しておわり。\n職域接種のためいわゆるモデルナ筋注といわれるものを打って今は9時間ほど、腕が重いですね。</p>\n<p>社の方々と会うのはちょっと緊張。\n人との接触は抑える必要もあるのであまりたくさん会話できるわけでもなく、会えていない人もたくさんいて、それらは未来の機会に託しました。\n新型コロナウィルスが一日でも早く収束することを願います。</p>\n<p>初出社してみたものの、持っていく荷物がまだあんまりまとまっていないですね。\nバッグが重く、荷物も取り出しづらく、もうちょっと減らしたいです。\n16インチMacBookは家で使うには最高なんだがなあ。</p>\n<hr>\n<p>今日を経て、出社は大変だなという気持ちとともにリモートワーク環境の有り難さを改めて感じます。\n出社を前提にしていない場所に住んでることもあり、会社までは2時間弱かかります。\n通勤ラッシュを避けれたものの人出は多く、ちょっとこれが毎日は厳しい気がします。</p>\n<p>最近、社会人になって最初の仕事がリモートワークでは社会人としての能力が身につかないという話をいただきました。\n私は社会人をまだ2ヶ月しか経験していないので社会人としての能力が何を指すのかも、リモートワークしか経験していないのでその真偽も、毎日の出社に使うエネルギーやコストが有用でそれだけの価値のあるものかどうかもわかりません。</p>\n<p>ただしリモートワークは、コミュニケーションの工夫や自己管理が求められる反面、出社しないことで体力的/時間的な余裕はきっと大きいでしょうから、それを有効に生かしていかねばという思いです。</p>\n<p>そんなこんなで会社に行った報告です。\n次の出社もワクチン接種でしょうか。\nその頃には梅雨が明けていますかね。</p>\n","content_text":"日記です。雑多なトピックが以下に続きます。\n\n4月に入社した会社に、今日はじめて出社しました。\n新型コロナウィルスのワクチン接種が主な理由で、くわえて同期をはじめとして何人かに出会うなどしました。\n\n今日の主なイベントであるワクチン接種ですが、大変スムーズで拍子抜けしました。\n受付をして打つのは一瞬、15分経過観察しておわり。\n職域接種のためいわゆるモデルナ筋注といわれるものを打って今は9時間ほど、腕が重いですね。\n\n社の方々と会うのはちょっと緊張。\n人との接触は抑える必要もあるのであまりたくさん会話できるわけでもなく、会えていない人もたくさんいて、それらは未来の機会に託しました。\n新型コロナウィルスが一日でも早く収束することを願います。\n\n初出社してみたものの、持っていく荷物がまだあんまりまとまっていないですね。\nバッグが重く、荷物も取り出しづらく、もうちょっと減らしたいです。\n16インチMacBookは家で使うには最高なんだがなあ。\n\n\n\n今日を経て、出社は大変だなという気持ちとともにリモートワーク環境の有り難さを改めて感じます。\n出社を前提にしていない場所に住んでることもあり、会社までは2時間弱かかります。\n通勤ラッシュを避けれたものの人出は多く、ちょっとこれが毎日は厳しい気がします。\n\n最近、社会人になって最初の仕事がリモートワークでは社会人としての能力が身につかないという話をいただきました。\n私は社会人をまだ2ヶ月しか経験していないので社会人としての能力が何を指すのかも、リモートワークしか経験していないのでその真偽も、毎日の出社に使うエネルギーやコストが有用でそれだけの価値のあるものかどうかもわかりません。\n\nただしリモートワークは、コミュニケーションの工夫や自己管理が求められる反面、出社しないことで体力的/時間的な余裕はきっと大きいでしょうから、それを有効に生かしていかねばという思いです。\n\nそんなこんなで会社に行った報告です。\n次の出社もワクチン接種でしょうか。\nその頃には梅雨が明けていますかね。\n"},{"id":"http://localhost:3000/posts/curldoc-development","url":"http://localhost:3000/posts/curldoc-development","title":"curldocというWeb APIの仕様書形式 兼 モックサーバを作っている","summary":"こんにちは。最近は会社の技術研修を粛々と受けています。 6月に入ってからはRailsチュートリアルを進めていて、ちょうど先週に終わりました。Railsは大変多機能であるとヒシヒシ感じています。 Ruby自体も今まで書いたことがなかったので、私の経験のある言語とは結構毛色が違っていて面白い気分です。 残業も特になく給料をいただきながら勉強している謎の身分ですが、権利をありがたく享受してスーパーエンジニアに成長したいと思います。 そんなこんなとは別で、趣味で最近作り始めたのがcurldocというツールです。 curldoc curldocのcurlはコマンドのcurlから来ています。 平たく言うと","date_published":"2021-06-21T09:40:00+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:curldoc%E3%81%A8%E3%81%84%E3%81%86Web%20API%E3%81%AE%E4%BB%95%E6%A7%98%E6%9B%B8%E5%BD%A2%E5%BC%8F%20%E5%85%BC%20%E3%83%A2%E3%83%83%E3%82%AF%E3%82%B5%E3%83%BC%E3%83%90%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","TypeScript","curl","HTTP"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/5c1e1eb6ee8e6f4efe27e587a78d4317530eb2ab","comment":"Post: 「curldocというWeb APIの仕様書形式 兼 モックサーバを作っている」\n","date_modified":"2021-06-21T09:40:24+09:00"}],"content_html":"<p>こんにちは。最近は会社の技術研修を粛々と受けています。\n6月に入ってからはRailsチュートリアルを進めていて、ちょうど先週に終わりました。Railsは大変多機能であるとヒシヒシ感じています。\nRuby自体も今まで書いたことがなかったので、私の経験のある言語とは結構毛色が違っていて面白い気分です。\n残業も特になく給料をいただきながら勉強している謎の身分ですが、権利をありがたく享受してスーパーエンジニアに成長したいと思います。</p>\n<p>そんなこんなとは別で、趣味で最近作り始めたのがcurldocというツールです。</p>\n<h2><a href=\"https://github.com/yammerjp/curldoc.git\">curldoc</a></h2>\n<p>curldocのcurlはコマンドの<a href=\"https://curl.se\">curl</a>から来ています。\n平たく言うと、curlコマンドとそのレスポンスを記述したMarkdownファイルを読み込んで立ち上がるモックサーバを作っています。</p>\n<p>そもそもcurlはHTTPリクエスト<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>を送ることができるコマンドですが、実はこれ、ただ単なるコマンドだけでなく、HTTPリクエストを表す汎用的なフォーマットなのではないかと思っています。\nPostmanやChrome開発者ツールにも、送信したリクエストをcurl形式で書き出す機能があったりします。</p>\n<h2>curldocの仕様書の形式</h2>\n<p>これをもとに、curlコマンドとその実行結果を書いたら簡易的なAPI仕様書になります。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>\n例えば次のような、リクエストとレスポンスのペアをひたすらMarkdownファイルに記述します。</p>\n<pre>\n\nリクエストを以下に記す。\n\n```curldoc-request\ncurl http://localhost:3000/hello --header 'Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l'\n```\n\nレスポンスを以下に記す。\n\n```curldoc-response\n{\n    \"message\": \"hello\"\n}\n```\n\n</pre>\n<p>この形式のよいところは2つあります。</p>\n<h3>シンプル</h3>\n<p>１つ目はシンプルであることです。\ncurlコマンドは前述のようにGUIアプリケーションから書き出せるし、広く普及しているフォーマットでもあります。</p>\n<p>APIドキュメントを記述する形式としては例えばSwaggerなどが既にあります。\n大変良くできたツールであると思いますが、どうしても記法を学んだり、対応するツールがある言語やフレームワークの上でしか使えなかったりと、場合によっては多機能すぎることもあるでしょう。\n小さなアプリケーションを作る場合やハッカソンで素早く作る場合、社内向けツールでドキュメント整備の優先順位が低い場合など、APIの仕様を簡単にテキストにまとめるほうが良い場合もあるのではないでしょうか。\ncurldocはまさにそれです。\nなるべく知識を必要とせず、簡単に、しかし齟齬無く最低限の要求を満たすAPIドキュメントの形式がcurldocです。</p>\n<p>シンプルであるからこそ、JSONだろうがXMLだろうがHTMLだろうがHTTPであれば自由に記述できます。</p>\n<h3>実行可能</h3>\n<p>2つ目は実行可能であることです。\ncurlコマンドは本来はコマンドですから実行可能です。\nシェルに貼り付けてエンターを押せば試せます。\nHTTPサーバを開発してデバッグする時、テストする時、既に開発されたものを使ってみるとき、コピペしてエンターを押すだけで試せるなんてなんと素晴らしい仕様書でしょうか。</p>\n<h2>片手落ちの「実行可能」の片手を作る</h2>\n<p>ここまでは単に「curlコマンドの形式でドキュメントを記述すると楽だよ」という話でした。\nしかし、2つ目の実行可能であるという点は片手落ちです。\nもともとAPI仕様書はクライアント側とサーバ側で認識を合わせるため、双方のためにあります。\nしかしながらcurlコマンドはクライアントなので、実行可能であるのは片方の立場だけです。\nサーバを開発する人はcurlコマンドで確認できますが、クライアントを開発する人は実際のサーバができあがるまで実行できません。</p>\n<p>そこで出現するのがcurldocです。\ncurldocはAPI仕様の書かれたMarkdwonファイルを元にモックサーバを立ち上げます。\nMarkdownファイルに書かれたものと同様のリクエストが来たら、対応するレスポンスを返すだけのモックサーバです。\ncurldocというアプリケーションによって、上記の形式のAPI仕様書が、クライアントサイドにとってもサーバサイドにとっても実行可能になることでしょう。</p>\n<p>モックサーバなので、開発にもテストにも用いることができるはずです。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<h2>これから</h2>\n<p>まだ作りかけのアプリケーションについて雄弁に語ってしまいました。\n現状でも一応ベーシックな機能としては動いていて、Markdownファイル上でHTTPのヘッダやボディを指定すると比較してくれたりします。\nとはいえやりたいことは以下のようにまだまだあります。</p>\n<ul>\n<li>JSON形式のリクエストボディの比較を柔軟に行う</li>\n<li>指定されなかったHTTPレスポンスヘッダをよしなに埋める</li>\n<li>ライブラリとして提供できるインタフェースを追加する</li>\n<li>ドキュメントを書く</li>\n<li>npm publishする</li>\n<li>curlオプションのサポートを増やす</li>\n</ul>\n<p>頑張って作るぞ。</p>\n<p><a href=\"https://github.com/yammerjp/curldoc.git\">https://github.com/yammerjp/curldoc.git</a></p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">curlはHTTPに限らず様々なプロトコルをサポートしているようです。なんでも出来すぎてびっくりするくらい。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">もともと5月末にハッカソン的にWebアプリケーション開発をやったときの感想から生まれたアイデアのツールです。サーバサイドとフロントエンドを別の人間が開発するとき、APIの認識をさくっとあわせるにはcurlコマンドによるリクエスト例を記述していく方法が結構はかどりました。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">モックサーバを必要とするのはクライントアプリケーションだろう。→クライアントアプリケーションといえば特にWebではJavaScriptだろう。→ JavaScriptのテストで用いるならJavaScriptから起動できたほうが良いよねということでNode.jsで作っています。コマンドだけでなくライブラリとして提供したいと思っています。<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">別に作っているAtomPubのクライアントのテストが結構汚くて、JSONではないAPIクライアントのモックサーバが欲しくて作っている側面もあります。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"こんにちは。最近は会社の技術研修を粛々と受けています。\n6月に入ってからはRailsチュートリアルを進めていて、ちょうど先週に終わりました。Railsは大変多機能であるとヒシヒシ感じています。\nRuby自体も今まで書いたことがなかったので、私の経験のある言語とは結構毛色が違っていて面白い気分です。\n残業も特になく給料をいただきながら勉強している謎の身分ですが、権利をありがたく享受してスーパーエンジニアに成長したいと思います。\n\nそんなこんなとは別で、趣味で最近作り始めたのがcurldocというツールです。\n\ncurldoc\n\ncurldocのcurlはコマンドのcurlから来ています。\n平たく言うと、curlコマンドとそのレスポンスを記述したMarkdownファイルを読み込んで立ち上がるモックサーバを作っています。\n\nそもそもcurlはHTTPリクエスト[^1]を送ることができるコマンドですが、実はこれ、ただ単なるコマンドだけでなく、HTTPリクエストを表す汎用的なフォーマットなのではないかと思っています。\nPostmanやChrome開発者ツールにも、送信したリクエストをcurl形式で書き出す機能があったりします。\n\ncurldocの仕様書の形式\n\nこれをもとに、curlコマンドとその実行結果を書いたら簡易的なAPI仕様書になります。[^2]\n例えば次のような、リクエストとレスポンスのペアをひたすらMarkdownファイルに記述します。\n\n\n\nこの形式のよいところは2つあります。\n\nシンプル\n\n１つ目はシンプルであることです。\ncurlコマンドは前述のようにGUIアプリケーションから書き出せるし、広く普及しているフォーマットでもあります。\n\nAPIドキュメントを記述する形式としては例えばSwaggerなどが既にあります。\n大変良くできたツールであると思いますが、どうしても記法を学んだり、対応するツールがある言語やフレームワークの上でしか使えなかったりと、場合によっては多機能すぎることもあるでしょう。\n小さなアプリケーションを作る場合やハッカソンで素早く作る場合、社内向けツールでドキュメント整備の優先順位が低い場合など、APIの仕様を簡単にテキストにまとめるほうが良い場合もあるのではないでしょうか。\ncurldocはまさにそれです。\nなるべく知識を必要とせず、簡単に、しかし齟齬無く最低限の要求を満たすAPIドキュメントの形式がcurldocです。\n\nシンプルであるからこそ、JSONだろうがXMLだろうがHTMLだろうがHTTPであれば自由に記述できます。\n\n実行可能\n\n2つ目は実行可能であることです。\ncurlコマンドは本来はコマンドですから実行可能です。\nシェルに貼り付けてエンターを押せば試せます。\nHTTPサーバを開発してデバッグする時、テストする時、既に開発されたものを使ってみるとき、コピペしてエンターを押すだけで試せるなんてなんと素晴らしい仕様書でしょうか。\n\n片手落ちの「実行可能」の片手を作る\n\nここまでは単に「curlコマンドの形式でドキュメントを記述すると楽だよ」という話でした。\nしかし、2つ目の実行可能であるという点は片手落ちです。\nもともとAPI仕様書はクライアント側とサーバ側で認識を合わせるため、双方のためにあります。\nしかしながらcurlコマンドはクライアントなので、実行可能であるのは片方の立場だけです。\nサーバを開発する人はcurlコマンドで確認できますが、クライアントを開発する人は実際のサーバができあがるまで実行できません。\n\nそこで出現するのがcurldocです。\ncurldocはAPI仕様の書かれたMarkdwonファイルを元にモックサーバを立ち上げます。\nMarkdownファイルに書かれたものと同様のリクエストが来たら、対応するレスポンスを返すだけのモックサーバです。\ncurldocというアプリケーションによって、上記の形式のAPI仕様書が、クライアントサイドにとってもサーバサイドにとっても実行可能になることでしょう。\n\nモックサーバなので、開発にもテストにも用いることができるはずです。[^3][^4]\n\nこれから\n\nまだ作りかけのアプリケーションについて雄弁に語ってしまいました。\n現状でも一応ベーシックな機能としては動いていて、Markdownファイル上でHTTPのヘッダやボディを指定すると比較してくれたりします。\nとはいえやりたいことは以下のようにまだまだあります。\n\nJSON形式のリクエストボディの比較を柔軟に行う\n\n指定されなかったHTTPレスポンスヘッダをよしなに埋める\n\nライブラリとして提供できるインタフェースを追加する\n\nドキュメントを書く\n\nnpm publishする\n\ncurlオプションのサポートを増やす\n\n頑張って作るぞ。\n\nhttps\\://github.com/yammerjp/curldoc.git\n\n[^1]: curlはHTTPに限らず様々なプロトコルをサポートしているようです。なんでも出来すぎてびっくりするくらい。\n\n[^2]: もともと5月末にハッカソン的にWebアプリケーション開発をやったときの感想から生まれたアイデアのツールです。サーバサイドとフロントエンドを別の人間が開発するとき、APIの認識をさくっとあわせるにはcurlコマンドによるリクエスト例を記述していく方法が結構はかどりました。\n\n[^3]: モックサーバを必要とするのはクライントアプリケーションだろう。→クライアントアプリケーションといえば特にWebではJavaScriptだろう。→ JavaScriptのテストで用いるならJavaScriptから起動できたほうが良いよねということでNode.jsで作っています。コマンドだけでなくライブラリとして提供したいと思っています。\n\n[^4]: 別に作っているAtomPubのクライアントのテストが結構汚くて、JSONではないAPIクライアントのモックサーバが欲しくて作っている側面もあります。\n"},{"id":"http://localhost:3000/posts/pepabo-11th-training","url":"http://localhost:3000/posts/pepabo-11th-training","title":"リモートワークの馴染む、4月の新卒研修 (GMOペパボ)","summary":"2021年4月1日にGMOペパボ株式会社 (以下ペパボ) に入社しました。 これからソフトウェアエンジニアとして成長し活躍することを夢見てやる気に満ち溢れています。 その第一歩として4月9日から4月30日までの約3週間、全職種で取り組むペパボの新卒研修に参加したので感想を記します[^1]。 ええ、それはその、大変楽しい研修期間でした。 新卒メンバー全員のイラスト リモートワークでうまくやる ペパボは2020年6月にリモートワークを基本とした働き方に移行し、今年の研修は全てオンラインで実施されました。 私自身、入社後にまだ一度も出社していません。 リモートワークの環境で新卒入社することに少なから","date_published":"2021-05-11T22:38:00+09:00","date_modified":"2021-05-11T22:38:26+09:00","banner_image":"https://blob.yammer.jp/pepabo-11th-training-ogp.png","tags":["ペパボ","新卒研修","リモートワーク","日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/3422910d9ffdb505877da5d3e67d2bc37766b36b","comment":"リモートワークの馴染む、4月の新卒研修 (GMOペパボ)\n","date_modified":"2021-05-11T22:38:26+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c9f6228e67fa9d22c22bd4dfe2bad1fa0f43576","comment":"[WIP] Add: URLを確保\n","date_modified":"2021-05-10T14:49:20+09:00"}],"content_html":"<p>2021年4月1日にGMOペパボ株式会社 (以下ペパボ) に入社しました。</p>\n<p>これからソフトウェアエンジニアとして成長し活躍することを夢見てやる気に満ち溢れています。\nその第一歩として4月9日から4月30日までの約3週間、全職種で取り組むペパボの新卒研修に参加したので感想を記します<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>。\nええ、それはその、大変楽しい研修期間でした。</p>\n<p><img src=\"https://blob.yammer.jp/pepabo-11th-training-ogp.png\" alt=\"新卒メンバー全員のイラスト\"></p>\n<div style=\"text-align: center; width: 100%; color: #505050; font-size: 14px;\">\nCS研修でお世話になった<a href=\"https://twitter.com/_wtmy\">ワタミユ</a>さんが書いてくださった新卒の我々のイラスト\n</div>\n<h2>リモートワークでうまくやる</h2>\n<p>ペパボは2020年6月にリモートワークを基本とした働き方に移行し、今年の研修は全てオンラインで実施されました。\n私自身、入社後にまだ一度も出社していません。</p>\n<p>リモートワークの環境で新卒入社することに少なからず不安はありました。\n大学のときはオンラインによるコミュニケーションのとりにくさや物理的な距離感を強く感じることも多かったからです。</p>\n<p>しかしながらその些細な不安は全くの杞憂で、リモートワークを前提として、それを当たり前のものとして過ごしていました。\nただただ、たった一本のイーサネットケーブルを介してよくもこれだけの情報や感情をやりとりできるものだと驚きを感じています。</p>\n<h2>情報がオープンであること</h2>\n<p>リモートワークでうまくやれている理由の一つとして社内の情報がオープンであることが挙げられます。\n<a href=\"https://tech.pepabo.com/2021/03/18/documentation-in-pepabo/\">社内規定や手続・制度の情報にアクセスしやすい</a> だけでなく、サービスに関する情報 (お客様の個人情報などは除く)、はたまた<a href=\"https://hr.pepabo.com/column/2020/02/07/3330\">人事評価資料</a>までもが社内でひろく公開されています。</p>\n<p>オンラインで活動する上で情報の非対称性は非常につらくて、大学時代に研究室で「昔の研究に関する情報が必要だったら声をかけて」と言われていたがそもそもどんな情報があるのかがわからない.. といった経験をした身からすると、入社後にすぐに様々な情報にアクセスでき会社のことをよく知れることはリモートワークでの安心感を生みました。</p>\n<h2>Slackの流れる早さ</h2>\n<p>物理的なオフィスに出社していない私は、Slackに出社していると言っても過言ではないでしょう。\nSlackでの会話が活発で円滑であるからこそ、オンラインでも距離感を感じずにコミュニケーションをとることができます。</p>\n<p><img src=\"https://blob.yammer.jp/pepabo-11th-training-morning.png\" alt=\"出社に相当するSlackのメッセージ\"></p>\n<div style=\"text-align: center; width: 100%; color: #505050; font-size: 14px;\">\n出社の様子\n</div>\n<p>研修についてもSlackをフルに活用しています。\n講義をきく機会も多かったのですが、そういったときに講義の解釈を話しあったり、他の人が知る関連情報を得られたり、些細な疑問を話してみたりといった会話が生まれます。\n同期の<a href=\"https://twitter.com/yagijinjin\">やぎじん</a>の言葉を借りるとまさに「<strong>隣の人と話しながら講義を受けることができる、新しい研修のかたち</strong>」でした。</p>\n<p>講義を担当されたパートナー<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>の方にも「リアクションがあるので話しやすい」と言っていただけたし、ただ聞いてメモをするより話も広がり講義を振り返る補足資料にもなり、加えて記憶の定着も良いように感じ、楽しいだけでなく大変有意義な時間でした。\nオンラインだからこそできた研修であったように思います。</p>\n<p><img src=\"https://blob.yammer.jp/pepabo-11th-training-res.jpg\" alt=\"講義中にたくさんのコメントが付き、返信件数が1時間で100件を超えているSlackのスクリーンショット\"></p>\n<div style=\"text-align: center; width: 100%; color: #505050; font-size: 14px;\">\n1時間程の講義でどんどん流れるSlack\n</div>\n<h2>意識していたこと</h2>\n<p>リモートワークの環境において、新卒として入社した自分もうまくやるために「自分の感情・状況を相手に伝える」ことを意識していました。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<p>例えばMeetやZoomでは伝わりづらいので大きく🙆‍♂️と意思表示するなどジェスチャーしたり。\n日報では自分の感情を正直に書くことも、困っていることや疑問があったら自発的にSlackに書き込むこともその一つです。\n発言しやすいように複数のチャネルを使いこなす意味で、Slackの個人用パブリックチャンネルを作ってみたりもしました。\nほかには<a href=\"https://note.com/ayanck/n/n976ecaf220c4\">背景で遊んだ</a>のも新卒11期生のパートナーの方々と仲良くなりたい気持ちだったと思います。</p>\n<p>オンラインではどうしても些細な気持ちの変化は伝わりづらいし一対一でコミュニケーションをする機会も減ってしまいます。\nだからこそ自己開示が必要であると思うし、より自分から状況や感情を伝える必要があります。</p>\n<p>新卒研修においてオンラインでのコミュニケーションが円滑に進んだのはきっと、入社前から培われたペパボの文化と既に日常となっていたリモートワークの土壌があったからでしょう。\nリモートワークには様々なツールの活用や制度の整備ももちろんですが、個々人がオンラインに即したコミュニケーション方法や振る舞いに適応していくことがとても大切であると感じました。</p>\n<p>オンラインに即したコミュニケーションはきっと社内でたくさんの人が実践していることではないかと思います。\n他の人や同期を見て学び、真似て、上記のような意識していたことに繋がりました。</p>\n<h2>まとめ</h2>\n<p>とても楽しく充実した一ヶ月でした。\n研修の中で新しく学んで吸収すること、業務の難しさとそれに取り組まれるパートナーの方々の凄さを知ることなど、多面的な切り口からの研修を通して、目的とされていた「ペパボで働く土台をつくる」は達成されたと思います。<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<p>入社を歓迎してくださったパートナーの皆さん、研修を企画・実施してくださったパートナーの皆さん、一緒に盛り上げてくれた同期の仲間、本当にありがとうございました。</p>\n<p>一ヶ月働いた実感として、ペパボの人々はとてもおもしろくて親切であるし、サービスを使う意味でも働く意味でもおすすめできる会社です。</p>\n<p>技術研修は5月以降も続きます。\nサービスを、ペパボを、世の中をもっとおもしろくできるよう<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>、まずは目の前の研修に一つ一つ取り組んでいきます。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">記事内であまり触れていない研修内容については他の人が書いたブログが参考になります。「<a href=\"https://note.com/asuka_okochi_131/n/na15e6e7dbcde\">🌸【21卒】ペパボでの新卒研修を終えて🌸｜きなこ｜note</a>」 や 「<a href=\"https://blog.yagijin.com/blog/2021-05-10-%E7%A4%BE%E5%86%85%E7%A0%94%E4%BF%AE%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8A/\">社内研修振り返り | YAGIJIN'S BLOG</a>」 など。 その他にも子育てと新卒研修に触れたブログ記事「<a href=\"https://note.com/rimomonga/n/n1fb576224805\">子育て新卒、ペパボで働き始めて1ヶ月｜うえだり｜note</a>」も読み応えがあります。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">ペパボでは働く仲間のことをパートナーと呼びます。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">入社前にも教えていただき、新卒研修の中でも触れられていたブログ記事 (<a href=\"https://diary.shu-cream.net/2020/07/06/01.html\">自分の気持ちを正しく表現する | けんちゃんくんさんのWeb日記</a>)がもとになっています。新卒の私が正直な感情を伝えるとそれを受け止めてくださるパートナーの方々がいることは本当にありがたいことです。<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">各研修内容のそれぞれに目的や目標が設定され何のために研修に参加するかが明確であったこと、定期的に時間を設けて振り返ることなど、研修を有意義なものにするための工夫が随所に凝らされていたと振り返りながら感じました。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\">「もっとおもしろくできる」は<a href=\"https://pepabo.com/company/vision/\">ペパボの企業理念</a>)です。<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"2021年4月1日にGMOペパボ株式会社 (以下ペパボ) に入社しました。\n\nこれからソフトウェアエンジニアとして成長し活躍することを夢見てやる気に満ち溢れています。\nその第一歩として4月9日から4月30日までの約3週間、全職種で取り組むペパボの新卒研修に参加したので感想を記します[^1]。\nええ、それはその、大変楽しい研修期間でした。\n\n新卒メンバー全員のイラスト\n\n\n\nリモートワークでうまくやる\n\nペパボは2020年6月にリモートワークを基本とした働き方に移行し、今年の研修は全てオンラインで実施されました。\n私自身、入社後にまだ一度も出社していません。\n\nリモートワークの環境で新卒入社することに少なからず不安はありました。\n大学のときはオンラインによるコミュニケーションのとりにくさや物理的な距離感を強く感じることも多かったからです。\n\nしかしながらその些細な不安は全くの杞憂で、リモートワークを前提として、それを当たり前のものとして過ごしていました。\nただただ、たった一本のイーサネットケーブルを介してよくもこれだけの情報や感情をやりとりできるものだと驚きを感じています。\n\n情報がオープンであること\n\nリモートワークでうまくやれている理由の一つとして社内の情報がオープンであることが挙げられます。\n社内規定や手続・制度の情報にアクセスしやすい だけでなく、サービスに関する情報 (お客様の個人情報などは除く)、はたまた人事評価資料までもが社内でひろく公開されています。\n\nオンラインで活動する上で情報の非対称性は非常につらくて、大学時代に研究室で「昔の研究に関する情報が必要だったら声をかけて」と言われていたがそもそもどんな情報があるのかがわからない.. といった経験をした身からすると、入社後にすぐに様々な情報にアクセスでき会社のことをよく知れることはリモートワークでの安心感を生みました。\n\nSlackの流れる早さ\n\n物理的なオフィスに出社していない私は、Slackに出社していると言っても過言ではないでしょう。\nSlackでの会話が活発で円滑であるからこそ、オンラインでも距離感を感じずにコミュニケーションをとることができます。\n\n出社に相当するSlackのメッセージ\n\n\n\n研修についてもSlackをフルに活用しています。\n講義をきく機会も多かったのですが、そういったときに講義の解釈を話しあったり、他の人が知る関連情報を得られたり、些細な疑問を話してみたりといった会話が生まれます。\n同期のやぎじんの言葉を借りるとまさに「隣の人と話しながら講義を受けることができる、新しい研修のかたち」でした。\n\n講義を担当されたパートナー[^2]の方にも「リアクションがあるので話しやすい」と言っていただけたし、ただ聞いてメモをするより話も広がり講義を振り返る補足資料にもなり、加えて記憶の定着も良いように感じ、楽しいだけでなく大変有意義な時間でした。\nオンラインだからこそできた研修であったように思います。\n\n講義中にたくさんのコメントが付き、返信件数が1時間で100件を超えているSlackのスクリーンショット\n\n\n\n意識していたこと\n\nリモートワークの環境において、新卒として入社した自分もうまくやるために「自分の感情・状況を相手に伝える」ことを意識していました。[^3]\n\n例えばMeetやZoomでは伝わりづらいので大きく🙆‍♂️と意思表示するなどジェスチャーしたり。\n日報では自分の感情を正直に書くことも、困っていることや疑問があったら自発的にSlackに書き込むこともその一つです。\n発言しやすいように複数のチャネルを使いこなす意味で、Slackの個人用パブリックチャンネルを作ってみたりもしました。\nほかには背景で遊んだのも新卒11期生のパートナーの方々と仲良くなりたい気持ちだったと思います。\n\nオンラインではどうしても些細な気持ちの変化は伝わりづらいし一対一でコミュニケーションをする機会も減ってしまいます。\nだからこそ自己開示が必要であると思うし、より自分から状況や感情を伝える必要があります。\n\n新卒研修においてオンラインでのコミュニケーションが円滑に進んだのはきっと、入社前から培われたペパボの文化と既に日常となっていたリモートワークの土壌があったからでしょう。\nリモートワークには様々なツールの活用や制度の整備ももちろんですが、個々人がオンラインに即したコミュニケーション方法や振る舞いに適応していくことがとても大切であると感じました。\n\nオンラインに即したコミュニケーションはきっと社内でたくさんの人が実践していることではないかと思います。\n他の人や同期を見て学び、真似て、上記のような意識していたことに繋がりました。\n\nまとめ\n\nとても楽しく充実した一ヶ月でした。\n研修の中で新しく学んで吸収すること、業務の難しさとそれに取り組まれるパートナーの方々の凄さを知ることなど、多面的な切り口からの研修を通して、目的とされていた「ペパボで働く土台をつくる」は達成されたと思います。[^4]\n\n入社を歓迎してくださったパートナーの皆さん、研修を企画・実施してくださったパートナーの皆さん、一緒に盛り上げてくれた同期の仲間、本当にありがとうございました。\n\n一ヶ月働いた実感として、ペパボの人々はとてもおもしろくて親切であるし、サービスを使う意味でも働く意味でもおすすめできる会社です。\n\n技術研修は5月以降も続きます。\nサービスを、ペパボを、世の中をもっとおもしろくできるよう[^5]、まずは目の前の研修に一つ一つ取り組んでいきます。\n\n[^1]: 記事内であまり触れていない研修内容については他の人が書いたブログが参考になります。「🌸【21卒】ペパボでの新卒研修を終えて🌸｜きなこ｜note」 や 「社内研修振り返り | YAGIJIN'S BLOG」 など。 その他にも子育てと新卒研修に触れたブログ記事「子育て新卒、ペパボで働き始めて1ヶ月｜うえだり｜note」も読み応えがあります。\n\n[^2]: ペパボでは働く仲間のことをパートナーと呼びます。\n\n[^3]: 入社前にも教えていただき、新卒研修の中でも触れられていたブログ記事 (自分の気持ちを正しく表現する | けんちゃんくんさんのWeb日記)がもとになっています。新卒の私が正直な感情を伝えるとそれを受け止めてくださるパートナーの方々がいることは本当にありがたいことです。\n\n[^4]: 各研修内容のそれぞれに目的や目標が設定され何のために研修に参加するかが明確であったこと、定期的に時間を設けて振り返ることなど、研修を有意義なものにするための工夫が随所に凝らされていたと振り返りながら感じました。\n\n[^5]: 「もっとおもしろくできる」はペパボの企業理念)です。\n"},{"id":"http://localhost:3000/posts/blog-with-nextjs","url":"http://localhost:3000/posts/blog-with-nextjs","title":"ブログをNext.jsに置き換える","summary":"ゴールデンウィーク明けの平日、いかがお過ごしだろうか。 私の場合は新卒研修のブログ記事を書こうと思ったものの、その記事を投稿するためのブログを弄っているうちにゴールデンウィークが終わってしまった。 そんなわけでここ数日は、「そろそろちゃんと触るか〜」と思っていたNext.jsを使ってこのブログを作り変えていた。 見た目は似ているけど中身はイチから作ったので別物である。[^1] 機能追加をしたいことがあったりしたので前々からJavaScriptのフレームワークに載せ替えたいと思っていて、やっと腰が上がった次第。[^2] 本当は1,2日でサクッと終わらせてしまってブログ投稿用のエディタを作ろうと思","date_published":"2021-05-07T22:07:57+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%96%E3%83%AD%E3%82%B0%E3%82%92Next.js%E3%81%AB%E7%BD%AE%E3%81%8D%E6%8F%9B%E3%81%88%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Next.js","JavaScript","TypeScript","ブログ"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/89a4fee32cb15873c56338636f2d4cfb3ea4a31b","comment":"Post: 「ブログをNext.jsに置き換える」\n","date_modified":"2021-05-07T22:09:42+09:00"}],"content_html":"<p>ゴールデンウィーク明けの平日、いかがお過ごしだろうか。\n私の場合は新卒研修のブログ記事を書こうと思ったものの、その記事を投稿するためのブログを弄っているうちにゴールデンウィークが終わってしまった。</p>\n<p>そんなわけでここ数日は、「そろそろちゃんと触るか〜」と思っていたNext.jsを使ってこのブログを作り変えていた。\n見た目は似ているけど中身はイチから作ったので別物である。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>機能追加をしたいことがあったりしたので前々からJavaScriptのフレームワークに載せ替えたいと思っていて、やっと腰が上がった次第。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>\n本当は1,2日でサクッと終わらせてしまってブログ投稿用のエディタを作ろうと思っていたのだけど全然思うようには進まず、結局閲覧画面だけ作って終わった。</p>\n<p>以下にここ数日の感想をいくつかの話題に分けて記す。</p>\n<h3>ブログのデザイン</h3>\n<p>デザインは変わっていないようで細かいところが少し変化したり、機能追加されていたりする。\nつくりながら他のブログを眺めるなどして、見やすそうな部分を参考にしたりした。</p>\n<p>具体的には例えば、記事ページ末尾にある隣の記事へのリンクについて。\nよくこういったリンクは next / prev とやってしまいがちだけれど、どっちが古い投稿へのリンクでどっちが新しい投稿へのリンクかわからなくなったりするので、「古い記事」「新しい記事」と書いてあるのをみて「良いな」と思ったので真似た。</p>\n<p><img src=\"https://blob.yammer.jp/blog-with-nextjs-neighbor-articles-link.png\" alt=\"記事ページ末尾の隣の記事へのリンクの新旧比較\"></p>\n<p>ブログのデザインといえば、完成の見た目が定まっていなかったので結構作っては壊してを繰り返していたのは効率が悪かったのかもしれない。\n例えば記事一覧ページは記事ごとにカバー画像を表示するように作ってみたあと、やっぱりみづらそうで止めた。\nfigmaなどを使って事前にどんなものを定めるなど、そういうのをやったほうがよかったかもなあ。\n(やったことない。)</p>\n<h3>remarkがよき</h3>\n<p>Hugoから置き換えた理由の一つに、Markdownのパースを改造できるようにしたかったからというモチベーションが有った。\n今回使ったMarkdownパーサのremarkがよく出来ていて、プラグインを追加するとパース時の機能や記法を追加できる。\n既によくあるMarkdown記法は既存のプラグインで対応できるし、新たな記法を追加するときはプラグインを作ってMarkdownやHTMLのASTに介入できるようで夢が広がる。</p>\n<p>本当はここらへんを重点的に開発して記事の執筆時に使える記法や記事の出力時の見た目をもっとリッチにしたかったのだけど、Next.jsでブログを作る時点で時間切れになってしまった。</p>\n<h3>Next.jsのよさ</h3>\n<p>Nuxt.jsみたいにフォルダ構成をはじめとした規約が定まっていて、秩序を感じるのはよい。</p>\n<p>簡単なAPIが書けるのもよい。Vercelを使えば一緒にデプロイもできそうで、ここらへんは開発元がホスティングサービスをやっている強みだなと感じた。</p>\n<p>getStaticPropsとかgetServerSideProps、getStaticPathsとかの関数があるのもよくて、何処に何を書けば良いのか、いつ何処で実行されるのかがわかりやすいのが良い。\nNuxt.jsではここらへんどうなってたっけ？configでSPAかSSRかSSGか選べたのは覚えているんだけど...</p>\n<h3>ReactとJSXの記法への小言</h3>\n<p>Reactに触ったのも久しぶりで、JSXと後述するCSS-moduleに一言ずつ。</p>\n<p>JSXを久々に書いたがちょっと書きづらい。\n特にDOMを条件分岐したいとき、その部分のJSXElementは変数に入れるのが良いのか最後のReturn文に埋め込むのが良いのか迷うなどした。\n埋め込むとしたら即時実行関数の中でifを書くか三項演算子を使うかだと思うけど、どちらも記号だらけであんまり見やすい表記じゃなさそうと思った。\nVue.jsのv-ifとかのほうがみやすさを感じる。</p>\n<p>Vue.jsの独自記法を覚えなくていいといえばそうだけど、その意味で言えばVue.js/Nuxt.jsはJSX覚えなくていいからな。\n(逆にJSXElementを繰り返すときは配列をmapできるのでスッキリ書けて気持ちいい。)\n記法は慣れの要素が多分に含まれるので、小言を言っても仕方ないね。</p>\n<h3>CSS-moduleはつらくないか？</h3>\n<p>前項のJSX記法は好みの問題と思うが、一方でCSSの適用方法については根が深い。\nもともとReact/Next.jsでコンポーネントにCSSを適用するならCSS-moduleかCSS in JS (Styled components)の2種類の方法から選ぶらしい。\n特にNext.jsはパフォーマンスの理由でCSS-moduleを推してるのだけどこれがあんまり良いと思えなかった。\n一般的なCSSはセレクタを使って適用する要素を決めるが、CSS-moduleはCSSのスタイルの集合(<code>{</code>から<code>}</code>まで)を、HTML要素で指定して指し示すような形になる。</p>\n<p>CSSが多重に適用されることはなくなるのでシンプルになるけれど、一方で宣言的に書けていたCSSの良さを殺しているのでは？と感じた。\nあとメディアクエリが使えない/使いづらかったり、するのも気になった。\n結局移行前のものを活かすという意味もあって、CSS-moduleもCSS in JSも使わずに1枚のCSSにすべてを書き込んで作っていて、途中でCSS-moduleで分割するかとなったのだけど上述のつらみを感じて止めてしまった。</p>\n<p>今回の開発を通して改めてVue.jsのシングルファイルコンポーネント好きだなあと感じた。</p>\n<p>---</p>\n<p>そんなこんなで予定がなくなってずっと家にいたゴールデンウィークだけれどコンピュータと仲良くなろうと遊んでいたのでよき休日だった。</p>\n<p>このブログへの機能追加はまだまだやりたいことだらけですが、もし見づらい、バグってる、勘違いしたなどあったらフィードバックをくださると喜びます。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">前はHugoのテーマに手を入れたものをNetlifyでホストしていたけど、今回はNext.jsとTypeScriptで作ったサイトをSSGしてVercelにホストしている。 どちらも記事はGitHub上にMarkdownで保存している。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">先月と先々月に作っていたバージョン管理システムのarcivは、とりあえず動くけどなんか動作が遅いよなという状態で放置されている... そっちはどうしようか...<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"ゴールデンウィーク明けの平日、いかがお過ごしだろうか。\n私の場合は新卒研修のブログ記事を書こうと思ったものの、その記事を投稿するためのブログを弄っているうちにゴールデンウィークが終わってしまった。\n\nそんなわけでここ数日は、「そろそろちゃんと触るか〜」と思っていたNext.jsを使ってこのブログを作り変えていた。\n見た目は似ているけど中身はイチから作ったので別物である。[^1]\n\n機能追加をしたいことがあったりしたので前々からJavaScriptのフレームワークに載せ替えたいと思っていて、やっと腰が上がった次第。[^2]\n本当は1,2日でサクッと終わらせてしまってブログ投稿用のエディタを作ろうと思っていたのだけど全然思うようには進まず、結局閲覧画面だけ作って終わった。\n\n以下にここ数日の感想をいくつかの話題に分けて記す。\n\nブログのデザイン\n\nデザインは変わっていないようで細かいところが少し変化したり、機能追加されていたりする。\nつくりながら他のブログを眺めるなどして、見やすそうな部分を参考にしたりした。\n\n具体的には例えば、記事ページ末尾にある隣の記事へのリンクについて。\nよくこういったリンクは next / prev とやってしまいがちだけれど、どっちが古い投稿へのリンクでどっちが新しい投稿へのリンクかわからなくなったりするので、「古い記事」「新しい記事」と書いてあるのをみて「良いな」と思ったので真似た。\n\n記事ページ末尾の隣の記事へのリンクの新旧比較\n\nブログのデザインといえば、完成の見た目が定まっていなかったので結構作っては壊してを繰り返していたのは効率が悪かったのかもしれない。\n例えば記事一覧ページは記事ごとにカバー画像を表示するように作ってみたあと、やっぱりみづらそうで止めた。\nfigmaなどを使って事前にどんなものを定めるなど、そういうのをやったほうがよかったかもなあ。\n(やったことない。)\n\nremarkがよき\n\nHugoから置き換えた理由の一つに、Markdownのパースを改造できるようにしたかったからというモチベーションが有った。\n今回使ったMarkdownパーサのremarkがよく出来ていて、プラグインを追加するとパース時の機能や記法を追加できる。\n既によくあるMarkdown記法は既存のプラグインで対応できるし、新たな記法を追加するときはプラグインを作ってMarkdownやHTMLのASTに介入できるようで夢が広がる。\n\n本当はここらへんを重点的に開発して記事の執筆時に使える記法や記事の出力時の見た目をもっとリッチにしたかったのだけど、Next.jsでブログを作る時点で時間切れになってしまった。\n\nNext.jsのよさ\n\nNuxt.jsみたいにフォルダ構成をはじめとした規約が定まっていて、秩序を感じるのはよい。\n\n簡単なAPIが書けるのもよい。Vercelを使えば一緒にデプロイもできそうで、ここらへんは開発元がホスティングサービスをやっている強みだなと感じた。\n\ngetStaticPropsとかgetServerSideProps、getStaticPathsとかの関数があるのもよくて、何処に何を書けば良いのか、いつ何処で実行されるのかがわかりやすいのが良い。\nNuxt.jsではここらへんどうなってたっけ？configでSPAかSSRかSSGか選べたのは覚えているんだけど...\n\nReactとJSXの記法への小言\n\nReactに触ったのも久しぶりで、JSXと後述するCSS-moduleに一言ずつ。\n\nJSXを久々に書いたがちょっと書きづらい。\n特にDOMを条件分岐したいとき、その部分のJSXElementは変数に入れるのが良いのか最後のReturn文に埋め込むのが良いのか迷うなどした。\n埋め込むとしたら即時実行関数の中でifを書くか三項演算子を使うかだと思うけど、どちらも記号だらけであんまり見やすい表記じゃなさそうと思った。\nVue.jsのv-ifとかのほうがみやすさを感じる。\n\nVue.jsの独自記法を覚えなくていいといえばそうだけど、その意味で言えばVue.js/Nuxt.jsはJSX覚えなくていいからな。\n(逆にJSXElementを繰り返すときは配列をmapできるのでスッキリ書けて気持ちいい。)\n記法は慣れの要素が多分に含まれるので、小言を言っても仕方ないね。\n\nCSS-moduleはつらくないか？\n\n前項のJSX記法は好みの問題と思うが、一方でCSSの適用方法については根が深い。\nもともとReact/Next.jsでコンポーネントにCSSを適用するならCSS-moduleかCSS in JS (Styled components)の2種類の方法から選ぶらしい。\n特にNext.jsはパフォーマンスの理由でCSS-moduleを推してるのだけどこれがあんまり良いと思えなかった。\n一般的なCSSはセレクタを使って適用する要素を決めるが、CSS-moduleはCSSのスタイルの集合({から}まで)を、HTML要素で指定して指し示すような形になる。\n\nCSSが多重に適用されることはなくなるのでシンプルになるけれど、一方で宣言的に書けていたCSSの良さを殺しているのでは？と感じた。\nあとメディアクエリが使えない/使いづらかったり、するのも気になった。\n結局移行前のものを活かすという意味もあって、CSS-moduleもCSS in JSも使わずに1枚のCSSにすべてを書き込んで作っていて、途中でCSS-moduleで分割するかとなったのだけど上述のつらみを感じて止めてしまった。\n\n今回の開発を通して改めてVue.jsのシングルファイルコンポーネント好きだなあと感じた。\n\n\\---\n\nそんなこんなで予定がなくなってずっと家にいたゴールデンウィークだけれどコンピュータと仲良くなろうと遊んでいたのでよき休日だった。\n\nこのブログへの機能追加はまだまだやりたいことだらけですが、もし見づらい、バグってる、勘違いしたなどあったらフィードバックをくださると喜びます。\n\n[^1]: 前はHugoのテーマに手を入れたものをNetlifyでホストしていたけど、今回はNext.jsとTypeScriptで作ったサイトをSSGしてVercelにホストしている。 どちらも記事はGitHub上にMarkdownで保存している。\n\n[^2]: 先月と先々月に作っていたバージョン管理システムのarcivは、とりあえず動くけどなんか動作が遅いよなという状態で放置されている... そっちはどうしようか...\n"},{"id":"http://localhost:3000/posts/tokeru-design","url":"http://localhost:3000/posts/tokeru-design","title":"融けるデザインを読んだ","summary":"このまえ教えてもらった本、「融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論」(著: 渡邊恵太) を読んだ。 以下はその解釈と感想である。 融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論 | 渡邊恵太 |本 | 通販 | Amazon 本書では「自己帰属感」という言葉を通して良いインターフェイスとはどのようなものかを述べている。 自分の与えた動作に伴ってリアルタイムに反応があると自己帰属感が生まれ、自己帰属感が高まると身体が拡張したかのように思いのままに操作できるようになる。 例えばキーボードは、慣れるまではひどく使いにくいが、慣れてしまえば文字を打つときに自然と手が動き","date_published":"2021-04-29T17:01:00+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%9E%8D%E3%81%91%E3%82%8B%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/897dd0bbebbd54c1da4a7bdf49cb3ad17e0e68ba","comment":"注釈のフォーマットを修正\n","date_modified":"2021-04-29T23:54:15+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4b8fbeb1ab6d511b1574db240273abb609bc8649","comment":"Add a post 'tokeru-design'\n","date_modified":"2021-04-29T17:29:02+09:00"}],"content_html":"<p>このまえ教えてもらった本、「融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論」(著: 渡邊恵太) を読んだ。\n以下はその解釈と感想である。</p>\n<p><a href=\"https://www.amazon.co.jp/%E8%9E%8D%E3%81%91%E3%82%8B%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3-%E2%80%95%E3%83%8F%E3%83%BC%E3%83%89%C3%97%E3%82%BD%E3%83%95%E3%83%88%C3%97%E3%83%8D%E3%83%83%E3%83%88%E6%99%82%E4%BB%A3%E3%81%AE%E6%96%B0%E3%81%9F%E3%81%AA%E8%A8%AD%E8%A8%88%E8%AB%96-%E6%B8%A1%E9%82%8A%E6%81%B5%E5%A4%AA/dp/4861009383/ref=as_li_ss_tl?_encoding=UTF8&#x26;qid=&#x26;sr=&#x26;linkCode=sl1&#x26;tag=niche-22&#x26;linkId=65214e156cf3fb0219ea72f5cc293b7a&#x26;language=ja_JP\">融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論 | 渡邊恵太 |本 | 通販 | Amazon</a></p>\n<p>本書では「自己帰属感」という言葉を通して良いインターフェイスとはどのようなものかを述べている。\n自分の与えた動作に伴ってリアルタイムに反応があると自己帰属感が生まれ、自己帰属感が高まると<strong>身体が拡張したかのように思いのままに操作できる</strong>ようになる。</p>\n<p>例えばキーボードは、慣れるまではひどく使いにくいが、慣れてしまえば文字を打つときに自然と手が動き自分の身体の延長のように扱える入力機器だと思う。\n車だって自分で運転することに慣れてくれば車体感覚が身につき狭い道路でもなんとなく車を端に寄せたりできるようになる。\nキーボードも車も、手で握るハンマー等よりよっぽど複雑な道具だけれど、慣れてしまえばそこそこの自己帰属感を得られるようになる。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>こういった自己帰属感の有無には<strong>自分が与える動作に対する遅延ない応答</strong>が必要なようだ。\n一方、動作の方向や方法は、慣れが要求できる範囲においては遅延ない応答ほどは重要度が高くなさそうに思う。\nたとえば車のアクセルもブレーキもペダルを踏む動作だが加速と減速という正反対のものを扱うし、キーボードもボタンを押下することで抽象的な概念である文字の入力を行う。</p>\n<p>本書を読んだうえで、じゃあ<strong>自分がソフトウェア開発 (特にWeb開発) を行うときにどう活かせるか</strong>というと結構難しい。\n本書ではどうやって作るかやGUIにおいて何が良いのかを具体的に示しているわけではなくもっと抽象度の高い話をしている。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>その中で\"遅延\"がユーザに与える自己帰属感の低下はWeb開発でもイメージしやすいものだろう。\nたとえば遅延ない応答の具体的な例といえば、いいねボタンを押したときに押した瞬間に表示を変更しサーバへのリクエストは裏で送るといった実装がその１つかもしれない。</p>\n<p>そういったユーザとのインタラクションにおいて遅延がいかにユーザに自分の思い通りに操作する感覚を失わせるかを知ることができた。\n開発者からすると微々たる違いであるのにユーザには大きな違いとして現れることは意識して開発するとよいだろうと感じた。</p>\n<p>本書を読んだ解釈が「全然ちげえぞ！」と思ったら教えて下さい。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">もちろん慣れが必要ないに越したことはない。しかしながらキーボードも車も、ユーザ体験が優れている設計かは別として、世界的に共通のインタフェースを備えているのは一定の自己帰属感が感じられる道具だからだろう。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">本書の「融けるデザイン」というタイトルにもなっている主題は「ハードウェアかソフトウェアといった違いに縛られず、自己帰属感という尺度をもとに人間と環境との相互的な作用を考えてプロダクトを設計しよう」といった話だと思う。しかしながらここでは画面内で描画されるWebブラウザとそれをタッチパネルやマウスやキーボードで操作する入力機器に限定した話を取り上げた。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"このまえ教えてもらった本、「融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論」(著: 渡邊恵太) を読んだ。\n以下はその解釈と感想である。\n\n融けるデザイン ―ハード×ソフト×ネット時代の新たな設計論 | 渡邊恵太 |本 | 通販 | Amazon\n\n本書では「自己帰属感」という言葉を通して良いインターフェイスとはどのようなものかを述べている。\n自分の与えた動作に伴ってリアルタイムに反応があると自己帰属感が生まれ、自己帰属感が高まると身体が拡張したかのように思いのままに操作できるようになる。\n\n例えばキーボードは、慣れるまではひどく使いにくいが、慣れてしまえば文字を打つときに自然と手が動き自分の身体の延長のように扱える入力機器だと思う。\n車だって自分で運転することに慣れてくれば車体感覚が身につき狭い道路でもなんとなく車を端に寄せたりできるようになる。\nキーボードも車も、手で握るハンマー等よりよっぽど複雑な道具だけれど、慣れてしまえばそこそこの自己帰属感を得られるようになる。[^1]\n\nこういった自己帰属感の有無には自分が与える動作に対する遅延ない応答が必要なようだ。\n一方、動作の方向や方法は、慣れが要求できる範囲においては遅延ない応答ほどは重要度が高くなさそうに思う。\nたとえば車のアクセルもブレーキもペダルを踏む動作だが加速と減速という正反対のものを扱うし、キーボードもボタンを押下することで抽象的な概念である文字の入力を行う。\n\n本書を読んだうえで、じゃあ自分がソフトウェア開発 (特にWeb開発) を行うときにどう活かせるかというと結構難しい。\n本書ではどうやって作るかやGUIにおいて何が良いのかを具体的に示しているわけではなくもっと抽象度の高い話をしている。[^2]\n\nその中で\"遅延\"がユーザに与える自己帰属感の低下はWeb開発でもイメージしやすいものだろう。\nたとえば遅延ない応答の具体的な例といえば、いいねボタンを押したときに押した瞬間に表示を変更しサーバへのリクエストは裏で送るといった実装がその１つかもしれない。\n\nそういったユーザとのインタラクションにおいて遅延がいかにユーザに自分の思い通りに操作する感覚を失わせるかを知ることができた。\n開発者からすると微々たる違いであるのにユーザには大きな違いとして現れることは意識して開発するとよいだろうと感じた。\n\n本書を読んだ解釈が「全然ちげえぞ！」と思ったら教えて下さい。\n\n[^1]: もちろん慣れが必要ないに越したことはない。しかしながらキーボードも車も、ユーザ体験が優れている設計かは別として、世界的に共通のインタフェースを備えているのは一定の自己帰属感が感じられる道具だからだろう。\n\n[^2]: 本書の「融けるデザイン」というタイトルにもなっている主題は「ハードウェアかソフトウェアといった違いに縛られず、自己帰属感という尺度をもとに人間と環境との相互的な作用を考えてプロダクトを設計しよう」といった話だと思う。しかしながらここでは画面内で描画されるWebブラウザとそれをタッチパネルやマウスやキーボードで操作する入力機器に限定した話を取り上げた。\n"},{"id":"http://localhost:3000/posts/foot-switch-mic-mute","url":"http://localhost:3000/posts/foot-switch-mic-mute","title":"足でマイクのミュートを解除しよう for 在宅勤務","summary":"私はいま、在宅勤務をしている。 特に研修中だからかオンライン通話の機会が多く、通話しながら作業や調べ物をするので、マイクのミュート/ミュート解除に手こずることに悩みを抱えている。 そんな中、ふとしたときに気づいたのである。「足が空いているではないか」と。 家に左クリックが壊れたマウスが有ったのでこれをフットスイッチ代わりにして、押しているときだけミュート解除するようにしてみた。 どのように実現しているかは後半の「つくりかた」に書く。 良いところ 細かくミュート/ミュート解除できる 目論見どおりうまく動いており、概ね快適である。 鼻をすする音など些細な音が入らずに済むのがすこぶる良い。 例えば相","date_published":"2021-04-27T09:41:29+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://blob.yammer.jp/foot-switch-mic-mute-irasutoya.png","tags":["macOS","在宅勤務","作業環境","Karabiner-Elements"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1741da28aa87b809153d2c6799f500b28fc236a8","comment":"注釈内の改行を削除してremark-footnoteで正しく変換されるよう修正\n","date_modified":"2021-05-05T19:47:55+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/39f6a6b0c1810582a361802ac37c2df32019d56f","comment":"Update the post 'foot-switch-mic-mute.md'\n","date_modified":"2021-04-27T09:42:47+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/fbf7e63c8f5cb3f172a2461e494ba46a175283f1","comment":"Add a post 'foot-switch-mic-mute.md'\n","date_modified":"2021-04-27T09:33:30+09:00"}],"content_html":"<p>私はいま、在宅勤務をしている。\n特に研修中だからかオンライン通話の機会が多く、通話しながら作業や調べ物をするので、マイクのミュート/ミュート解除に手こずることに悩みを抱えている。\nそんな中、ふとしたときに気づいたのである。「足が空いているではないか」と。</p>\n<p>家に左クリックが壊れたマウスが有ったのでこれをフットスイッチ代わりにして、押しているときだけミュート解除するようにしてみた。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">こちら、机の下に置かれた不審なマウスです。 <a href=\"https://t.co/DWxn3oxcLM\">pic.twitter.com/DWxn3oxcLM</a></p>&mdash; やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1386699716356837380?ref_src=twsrc%5Etfw\">April 26, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>どのように実現しているかは後半の「<a href=\"#%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%8B%E3%81%9F\">つくりかた</a>」に書く。</p>\n<h2>良いところ</h2>\n<ul>\n<li><strong>細かくミュート/ミュート解除できる</strong></li>\n</ul>\n<p>目論見どおりうまく動いており、概ね快適である。\n鼻をすする音など些細な音が入らずに済むのがすこぶる良い。\n例えば相槌をうちながらキーボードを打つときや、ZoomやGoogle Meet以外のウィンドウ・タブを操作しながら話すときなどに助かる。\nスムーズにミュート解除できるので、些細なリアクションのときだけミュート解除するみたいなことができる。\nスイッチを押したとき/離した時のタイムラグも (周りに聞く限り) 問題ないようでで常用できそう。</p>\n<h2>改善すべきところ</h2>\n<ul>\n<li><strong>ペダルが踏みづらい</strong></li>\n</ul>\n<p>良いところもある一方、まだ道半ばだと感じる部分もある。\n例えばマウスの右クリックボタンは小さいため、少し足を離していると何処にあるかわからなくなる。\nすると目視で確認しないと踏めないので発話がワンテンポ遅れる。\nピアノのペダルのようなもっと踏みやすいものに変えたほうがよさそう。</p>\n<ul>\n<li><strong>慣れないので間違える</strong></li>\n</ul>\n<p>ペダル操作は慣れが必要で、踏み忘れて話しはじめてしまったり、逆に足を外して音を立ててしまったりすることも有った。\n「キーボードや手元のマウスを操作すること」「足でミュート解除すること」「話すこと」の3つを同時にやろうとすると頭の中がついていかずスムーズにできない。\n慣れればペダル操作が無意識でできるようになることを期待しているのでしばらく使っていきたい。</p>\n<ul>\n<li><strong>ミュート/ミュート解除のソフトウェア制御が怪しい</strong></li>\n</ul>\n<p>もうひとつ、ミュート/ミュート解除をソフトウェア的に制御する方法が怪しい。\nmacOSの仕様がよくわからないのだが、OS側でマイクをミュートにする方法が見つけられずボリュームを最小にすることで擬似的にミュートにしている。\nアプリケーションの種類に左右されずに、さらにウィンドウがアクティブでないときも操作したいので、いまは OS 側の設定をシェルから叩いている。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># マイクをミュート</span>\n$ osascript -e <span class=\"hljs-string\">\"tell application \\\"System Events\\\" to set volume input volume 0\"</span>\n<span class=\"hljs-comment\"># マイクをミュート解除</span>\n$ osascript -e <span class=\"hljs-string\">\"tell application \\\"System Events\\\" to set volume input volume 100\"</span></code></pre>\n<p>今日Google Meetで話した感じではミュートされているようだったが、Zoomで試した感じだと最小でもすこし音が入っていた。\nもし他にいい方法があれば知りたい。\n(電子工作つよつよマンならマイクケーブルをスイッチで電気的に切断してミュートできそうだけれど、操作時のノイズなども出てきそうなので一旦ソフトウェア的に切り替える方式で考えている。)</p>\n<h2>感想</h2>\n<p>働き始めて3週間、在宅勤務にはきっと在宅勤務なりのスキルが必要だなあと感じる。\nたぶん自分がいままで属してきた他のコミュニティでは今の会社のようなオンラインコミュニケーションを取るのは難しかったように思う。\n何が難しいのかは言語化しづらいのだが、きっと会社の中で今まで積み上げられてきた様々な知見や文化が関与していそう。</p>\n<p>在宅勤務なりのスキルとは、チャットコミュニケーションの円滑さや、オンライン通話のテクニックも含まれるだろう。\n例えば画面越しでは感情が伝わりづらいので大きなリアクションをするとか、話し始めがかぶりやすいので細かいところでも誰かがファシリテーションしたり事前に挙手したりするとか、そういったことの積み重ねが大切に感じる。\nその要素のひとつにミュートを使いこなすこともあって、 雑音を入れない意味でも大きなリアクションを伝える意味でもスムーズに切り替えられるとよさそう。\n今回のペダルでの操作がうまい方法かわからないが、画面上のボタンだとミュート解除が遅れて困る機会がときどき有ったのでそれらを解消できるとよいね！</p>\n<h2>つくりかた</h2>\n<p>既にだいぶ書いたが、やっとここからつくりかたを説明する。</p>\n<p>今回の仕掛けは、macOS に接続した USB マウスと Karabiner-Elements というソフトウェアから成る。\n<strong>足元に置いたマウスの右クリックを検知し、マウス押下時にミュート解除のシェルコマンドを、押下を止めたときにミュートのシェルコマンドを実行している。</strong></p>\n<p><img src=\"https://blob.yammer.jp/foot-switch-mic-mute-irasutoya.png\" alt=\"マウス押下時にミュートする仕組みの外観図\"></p>\n<div style=\"margin-top:0px; text-align:center; width:100%; color: #888888; margin-bottom: 20px;\">これは私がいらすとやの画像を使いたかったことを表す図です。</div>\n<p>さあ作っていこう。</p>\n<h3>1. Karabiner-Elements をインストール</h3>\n<p>Karabiner-Elementsはもともとキーボードの操作を書き換えるソフトウェアで、例えばCapsLockキーをCtrlキーに置き換えるだとか、Spaceキーを長押しするとShiftキーが押されたことにするといった設定ができる。\nついでにマウスの入力も扱えるので、今回は特定のマウスがクリックされた時にコマンドを実行するよう設定ファイルを書くことにする。</p>\n<p>まず <a href=\"https://karabiner-elements.pqrs.org\">Karabiner-Elements のサイト</a> からファイルをダウンロードしインストールする。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p><img src=\"https://blob.yammer.jp/foot-switch-mic-mute-security-and-privacy.png\" alt=\"macOS 環境設定のセキュリティとプライバシーの項目で、Karabiner-Elementsによる入力監視を有効化する\"></p>\n<p>初回起動すると、macOS のセキュリティ許可などを設定しろだとか再起動しろだとかいわれるはずなので従う。\n以降はログインすると勝手に Karabiner-Elements も起動して、メニューバーに四角形のアイコン (<img src=\"https://blob.yammer.jp/foot-switch-mic-mute-karabiner-icon.png\" style=\"width:1em; height:1em;\" />)が表示されて常駐する。</p>\n<h3>2. デバイスを有効化する</h3>\n<p>メニューバーの Karabiner-Elements アイコンをクリック > Preferences... > Devices タブを開く。</p>\n<p>この状態で足のスイッチにしたいマウス<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>をコンピュータに挿して、新たに表示されたデバイスの行の左端のチェックボックスを有効にする。\n他デバイスのチェックボックスを有効にすると、他デバイスの入力も奪って設定を反映してしまう可能性がある。\n入力を上書きしたいデバイスのみにチェックをいれること。</p>\n<p><img src=\"https://blob.yammer.jp/foot-switch-mic-mute-devices.png\" alt=\"Karabiner-ElementsのDevicesタブで、当該のマウスにチェックを入れる\"></p>\n<h3>3. 設定ファイルを記述</h3>\n<p><code>~/.config/karabiner/assets/complex_modifications/mouse_mic_mute.json</code> を作成し、次の内容を書き込む。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"title\"</span>: <span class=\"hljs-string\">\"Unmute/Mute mic with clicking mouse\"</span>,\n  <span class=\"hljs-attr\">\"rules\"</span>: [\n    {\n      <span class=\"hljs-attr\">\"description\"</span>: <span class=\"hljs-string\">\"Unmute/Mute with mouse button down/up\"</span>,\n      <span class=\"hljs-attr\">\"manipulators\"</span>: [ {\n        <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"basic\"</span>,\n        <span class=\"hljs-attr\">\"from\"</span>: {\n          <span class=\"hljs-attr\">\"pointing_button\"</span>: <span class=\"hljs-string\">\"button2\"</span>,\n          <span class=\"hljs-attr\">\"modifiers\"</span>: { <span class=\"hljs-attr\">\"optional\"</span>: [ <span class=\"hljs-string\">\"any\"</span> ] }\n        },\n        <span class=\"hljs-attr\">\"to\"</span>: [ {\n          <span class=\"hljs-attr\">\"shell_command\"</span>: <span class=\"hljs-string\">\"osascript -e \\\"tell application \\\\\\\"System Events\\\\\\\" to set volume input volume 70\\\"\"</span>\n        } ],\n        <span class=\"hljs-attr\">\"to_after_key_up\"</span>: [ {\n          <span class=\"hljs-attr\">\"shell_command\"</span>: <span class=\"hljs-string\">\"osascript -e \\\"tell application \\\\\\\"System Events\\\\\\\" to set volume input volume 0\\\"\"</span>\n        } ]\n      } ]\n    }\n  ]\n}</code></pre>\n<p>設定をカスタマイズするとすれば、たとえば <code>pointing_button</code> を <code>button1</code> にすれば、左クリックを対象にできる。\nその他の設定は<a href=\"https://karabiner-elements.pqrs.org/docs/json/complex-modifications-manipulator-definition/\">公式の説明</a>や <a href=\"https://qiita.com/s-show/items/a1fd228b04801477729c\">Qiita の記事</a> を参考に。</p>\n<h3>4. 設定を有効化</h3>\n<p>メニューバーの Karabiner-Elements アイコンをクリック > Preferences... > Complex modifications タブを開く。</p>\n<p>右下の「Add rule」を押し、「Unmute/Mute with mouse button down/up」を「Enable」する。</p>\n<p><img src=\"https://blob.yammer.jp/foot-switch-mic-mute-complex-modifications.png\" alt=\"Karabiner-ElementsのComplex modificationタブで、記述したJSONファイルの項目を読み込む\"></p>\n<div style=\"margin-top:5em;\"></div>\n<p>ここまでの操作でミュートをいい感じに操作できるはず。\nなお、マウスの裏側には黒い紙を貼ってポインタが反応しないようにしている。\n左クリックなどが反応しないのはマウス自体が壊れているからっぽい。\nもし通常のマウスを使う場合はKarabiner-Elementsの設定で、各ボタンの入力について<code>\"to\": [{}]</code>といった何もしない設定を追加すると良さそう。</p>\n<p>以上。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><code>$ brew install karabiner-elements</code>でもインストールできるはず<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">今回は手元に壊れかけのマウスが有ったのでこれをスイッチとして使ったが、キーボードなどでも同様のことを実現できるはず。また何も足で押さなくてもよくて、机の上にスイッチがあるとか既存のキーボードにショートカットキーを定義するとかでもよいかもしれない。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">既にマウスに関する Karabiner-Elements の設定が存在する場合は、ぶつからないように、Vendor ID と Product ID をメモして設定に書き込むと良さそう。<a href=\"https://github.com/yammerjp/dotfiles/blob/cf0f3eaa6bce79b984cdcc53a42ed1ea65711f90/.config/karabiner/assets/complex_modifications/mouse_mic_mute.json\">参考までに私の設定ファイルはこれ。</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"私はいま、在宅勤務をしている。\n特に研修中だからかオンライン通話の機会が多く、通話しながら作業や調べ物をするので、マイクのミュート/ミュート解除に手こずることに悩みを抱えている。\nそんな中、ふとしたときに気づいたのである。「足が空いているではないか」と。\n\n家に左クリックが壊れたマウスが有ったのでこれをフットスイッチ代わりにして、押しているときだけミュート解除するようにしてみた。\n\n\n\nどのように実現しているかは後半の「つくりかた」に書く。\n\n良いところ\n\n細かくミュート/ミュート解除できる\n\n目論見どおりうまく動いており、概ね快適である。\n鼻をすする音など些細な音が入らずに済むのがすこぶる良い。\n例えば相槌をうちながらキーボードを打つときや、ZoomやGoogle Meet以外のウィンドウ・タブを操作しながら話すときなどに助かる。\nスムーズにミュート解除できるので、些細なリアクションのときだけミュート解除するみたいなことができる。\nスイッチを押したとき/離した時のタイムラグも (周りに聞く限り) 問題ないようでで常用できそう。\n\n改善すべきところ\n\nペダルが踏みづらい\n\n良いところもある一方、まだ道半ばだと感じる部分もある。\n例えばマウスの右クリックボタンは小さいため、少し足を離していると何処にあるかわからなくなる。\nすると目視で確認しないと踏めないので発話がワンテンポ遅れる。\nピアノのペダルのようなもっと踏みやすいものに変えたほうがよさそう。\n\n慣れないので間違える\n\nペダル操作は慣れが必要で、踏み忘れて話しはじめてしまったり、逆に足を外して音を立ててしまったりすることも有った。\n「キーボードや手元のマウスを操作すること」「足でミュート解除すること」「話すこと」の3つを同時にやろうとすると頭の中がついていかずスムーズにできない。\n慣れればペダル操作が無意識でできるようになることを期待しているのでしばらく使っていきたい。\n\nミュート/ミュート解除のソフトウェア制御が怪しい\n\nもうひとつ、ミュート/ミュート解除をソフトウェア的に制御する方法が怪しい。\nmacOSの仕様がよくわからないのだが、OS側でマイクをミュートにする方法が見つけられずボリュームを最小にすることで擬似的にミュートにしている。\nアプリケーションの種類に左右されずに、さらにウィンドウがアクティブでないときも操作したいので、いまは OS 側の設定をシェルから叩いている。\n\n\n\n今日Google Meetで話した感じではミュートされているようだったが、Zoomで試した感じだと最小でもすこし音が入っていた。\nもし他にいい方法があれば知りたい。\n(電子工作つよつよマンならマイクケーブルをスイッチで電気的に切断してミュートできそうだけれど、操作時のノイズなども出てきそうなので一旦ソフトウェア的に切り替える方式で考えている。)\n\n感想\n\n働き始めて3週間、在宅勤務にはきっと在宅勤務なりのスキルが必要だなあと感じる。\nたぶん自分がいままで属してきた他のコミュニティでは今の会社のようなオンラインコミュニケーションを取るのは難しかったように思う。\n何が難しいのかは言語化しづらいのだが、きっと会社の中で今まで積み上げられてきた様々な知見や文化が関与していそう。\n\n在宅勤務なりのスキルとは、チャットコミュニケーションの円滑さや、オンライン通話のテクニックも含まれるだろう。\n例えば画面越しでは感情が伝わりづらいので大きなリアクションをするとか、話し始めがかぶりやすいので細かいところでも誰かがファシリテーションしたり事前に挙手したりするとか、そういったことの積み重ねが大切に感じる。\nその要素のひとつにミュートを使いこなすこともあって、 雑音を入れない意味でも大きなリアクションを伝える意味でもスムーズに切り替えられるとよさそう。\n今回のペダルでの操作がうまい方法かわからないが、画面上のボタンだとミュート解除が遅れて困る機会がときどき有ったのでそれらを解消できるとよいね！\n\nつくりかた\n\n既にだいぶ書いたが、やっとここからつくりかたを説明する。\n\n今回の仕掛けは、macOS に接続した USB マウスと Karabiner-Elements というソフトウェアから成る。\n足元に置いたマウスの右クリックを検知し、マウス押下時にミュート解除のシェルコマンドを、押下を止めたときにミュートのシェルコマンドを実行している。\n\nマウス押下時にミュートする仕組みの外観図\n\n\n\nさあ作っていこう。\n\n1\\. Karabiner-Elements をインストール\n\nKarabiner-Elementsはもともとキーボードの操作を書き換えるソフトウェアで、例えばCapsLockキーをCtrlキーに置き換えるだとか、Spaceキーを長押しするとShiftキーが押されたことにするといった設定ができる。\nついでにマウスの入力も扱えるので、今回は特定のマウスがクリックされた時にコマンドを実行するよう設定ファイルを書くことにする。\n\nまず Karabiner-Elements のサイト からファイルをダウンロードしインストールする。[^1]\n\nmacOS 環境設定のセキュリティとプライバシーの項目で、Karabiner-Elementsによる入力監視を有効化する\n\n初回起動すると、macOS のセキュリティ許可などを設定しろだとか再起動しろだとかいわれるはずなので従う。\n以降はログインすると勝手に Karabiner-Elements も起動して、メニューバーに四角形のアイコン ()が表示されて常駐する。\n\n2\\. デバイスを有効化する\n\nメニューバーの Karabiner-Elements アイコンをクリック > Preferences... > Devices タブを開く。\n\nこの状態で足のスイッチにしたいマウス[^2]をコンピュータに挿して、新たに表示されたデバイスの行の左端のチェックボックスを有効にする。\n他デバイスのチェックボックスを有効にすると、他デバイスの入力も奪って設定を反映してしまう可能性がある。\n入力を上書きしたいデバイスのみにチェックをいれること。\n\nKarabiner-ElementsのDevicesタブで、当該のマウスにチェックを入れる\n\n3\\. 設定ファイルを記述\n\n\\~/.config/karabiner/assets/complex_modifications/mouse_mic_mute.json を作成し、次の内容を書き込む。[^3]\n\n\n\n設定をカスタマイズするとすれば、たとえば pointing_button を button1 にすれば、左クリックを対象にできる。\nその他の設定は公式の説明や Qiita の記事 を参考に。\n\n4\\. 設定を有効化\n\nメニューバーの Karabiner-Elements アイコンをクリック > Preferences... > Complex modifications タブを開く。\n\n右下の「Add rule」を押し、「Unmute/Mute with mouse button down/up」を「Enable」する。\n\nKarabiner-ElementsのComplex modificationタブで、記述したJSONファイルの項目を読み込む\n\n\n\nここまでの操作でミュートをいい感じに操作できるはず。\nなお、マウスの裏側には黒い紙を貼ってポインタが反応しないようにしている。\n左クリックなどが反応しないのはマウス自体が壊れているからっぽい。\nもし通常のマウスを使う場合はKarabiner-Elementsの設定で、各ボタンの入力について\"to\": \\[{}]といった何もしない設定を追加すると良さそう。\n\n以上。\n\n[^1]: $ brew install karabiner-elementsでもインストールできるはず\n\n[^2]: 今回は手元に壊れかけのマウスが有ったのでこれをスイッチとして使ったが、キーボードなどでも同様のことを実現できるはず。また何も足で押さなくてもよくて、机の上にスイッチがあるとか既存のキーボードにショートカットキーを定義するとかでもよいかもしれない。\n\n[^3]: 既にマウスに関する Karabiner-Elements の設定が存在する場合は、ぶつからないように、Vendor ID と Product ID をメモして設定に書き込むと良さそう。参考までに私の設定ファイルはこれ。\n"},{"id":"http://localhost:3000/posts/backup-lolipop-wordpress-with-docker","url":"http://localhost:3000/posts/backup-lolipop-wordpress-with-docker","title":"ロリポップ上に公開された WordPress サイトを、ローカルの docker-compose 上で再現する","summary":"表題の通り、ロリポップ！レンタルサーバ上に公開されている自身のWebサイトをバックアップし、さらに手元のPC上にdocker-composeで動作するように配置する。 前提の環境 ロリポップ！レンタルサーバ上で WordPress を用いた Webサイトを構築している。 macOS 10.15 Catalina Docker Desktop for Mac がインストールされている wget がインストールされている。 (Homebrew を用いて brew install wget でインストール) 手順1: ロリポップ上の情報をダウンロード 1-1: ファイルを抜き出す はじめにロリポップ","date_published":"2021-04-24T03:41:20+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%AD%E3%83%AA%E3%83%9D%E3%83%83%E3%83%97%E4%B8%8A%E3%81%AB%E5%85%AC%E9%96%8B%E3%81%95%E3%82%8C%E3%81%9F%20WordPress%20%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E3%80%81%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%AE%20docker-compose%20%E4%B8%8A%E3%81%A7%E5%86%8D%E7%8F%BE%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9555a90785e82772193aef3be56d58a7477dfb5c","comment":"Add a post\n","date_modified":"2021-04-24T04:15:44+09:00"}],"content_html":"<p>表題の通り、ロリポップ！レンタルサーバ上に公開されている自身のWebサイトをバックアップし、さらに手元のPC上にdocker-composeで動作するように配置する。</p>\n<h2>前提の環境</h2>\n<ul>\n<li>ロリポップ！レンタルサーバ上で WordPress を用いた Webサイトを構築している。</li>\n<li>macOS 10.15 Catalina</li>\n<li><a href=\"https://matsuand.github.io/docs.docker.jp.onthefly/docker-for-mac/install/\">Docker Desktop for Mac がインストールされている</a></li>\n<li>wget がインストールされている。 (Homebrew を用いて <code>brew install wget</code> でインストール)</li>\n</ul>\n<h2>手順1: ロリポップ上の情報をダウンロード</h2>\n<h3>1-1: ファイルを抜き出す</h3>\n<p>はじめにロリポップ！ユーザ専用ページ > ユーザー設定 > アカウント情報 を開いてアカウント情報を確認する。\n今回は以下の内容であったとする。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FTPS サーバー</td>\n<td><code>ftp.lolipop.jp</code></td>\n</tr>\n<tr>\n<td>FTP ・WebDAV アカウント</td>\n<td><code>chu.jp-user</code></td>\n</tr>\n<tr>\n<td>FTP ・WebDAV パスワード</td>\n<td><code>password</code></td>\n</tr>\n</tbody>\n</table>\n<p>次に、ターミナルから以下のコマンドを実行する。\nftp を使って、階層の深さ制限なしに再帰的にファイルをダウンロードする。</p>\n<pre><code class=\"hljs language-sh\">$ mkdir -p ~/lolipop-backup/download &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> ~/lolipop-backup/download\n$ wget -r -l 0 <span class=\"hljs-string\">\"ftp://chu.jp-user:password@ftp.lolipop.jp\"</span>\n<span class=\"hljs-comment\"># (ホスト名、ユーザ名、パスワードは適宜置き換えていただくとよし)</span></code></pre>\n<p>ちなみに私の場合は8分で200MB弱をダウンロードした。</p>\n<h3>1-2: データベースを抜き出す</h3>\n<ol>\n<li>ロリポップ！ユーザ専用ページ > サーバの管理・設定 > データベース を開く。</li>\n<li>データベース名をメモする。今回は <code>LAA0000000-xxxxxx</code> であるとする。</li>\n<li>phpMyAdmin を開く。</li>\n<li>ログインして、画面左のデータベース名を選択 (今回で言えば <code>LAA0000000-xxxxxx</code>)。</li>\n<li>\"エクスポート\" タブを開く。</li>\n<li>エクスポート方法: \"詳細 - 可能なオプションを全て表示\" のラジオボタンを選択。</li>\n<li>生成オプションより追加コマンド: \"CREATE DATABASE / USE コマンドを追加する\" にもチェックを入れる。</li>\n<li>他はデフォルトのままで、ページ左下の \"実行\" をクリック。</li>\n<li>ファイルがダウンロードされるので <code>~/lolipop-backup/downlaod/LAA0000000-xxxxxx.sql</code> に移動させる。</li>\n</ol>\n<h2>手順2: ローカルにWordPress環境を構築</h2>\n<h3>2-1: docker-compose.ymlを整備する</h3>\n<p><code>~/lolipop-backup/docker-compose.yml</code> を作成し、以下の内容を記述する。\n<code>- MYSQL_DATABASE=LAA0000000-xxxxxx</code>の行についてのみ、イコール以降に各自のデータベース名を書き込む必要がある。</p>\n<div class=\"remark-code-title\">docker-compose.yml</div>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">\"3\"</span>\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:5.6</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">\"mysql\"</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./db:/var/lib/mysql</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./db-init:/docker-entrypoint-initdb.d</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">MYSQL_DATABASE=LAA0000000-xxxxxx</span> <span class=\"hljs-comment\"># この行は各自で記述</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">MYSQL_USER=user</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">MYSQL_PASSWORD=password</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">MYSQL_ROOT_PASSWORD=root</span>\n  <span class=\"hljs-attr\">wordpress:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">wordpress:5.7.1</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">\"wordpress\"</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./wp:/var/www/html</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n    <span class=\"hljs-attr\">depends_on:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">db</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">8080</span><span class=\"hljs-string\">:80</span>\n  <span class=\"hljs-attr\">phpmyadmin:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">phpmyadmin/phpmyadmin:latest</span>\n    <span class=\"hljs-attr\">container_name:</span> <span class=\"hljs-string\">\"phpmyadmin\"</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n    <span class=\"hljs-attr\">depends_on:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">db</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">8888</span><span class=\"hljs-string\">:80</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PMA_ARBITRARY=1</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PMA_HOSTS=mysql</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PMA_USER=user</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">PMA_PASSWORD=password</span></code></pre>\n<h3>2-2: 抜き出したファイルを設置する</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 抜き出したファイル群を設置</span>\n$ cp -r ~/lolipop-backup/download/ftp.lolipop.jp ~/lolipop-backup/wp\n<span class=\"hljs-comment\"># 上の行はロリポップ側でルートディレクトリに WordPress を設置している場合である</span>\n<span class=\"hljs-comment\"># ルートディレクトリ以外に WordPress を設置している場合は、index.php が wp ディレクトリの直下に配置されるようにコピー元のディレクトリを指定する</span>\n\n<span class=\"hljs-comment\"># 抜き出したデータベース初期化情報を設置</span>\n$ mkdir db-init\n$ cp ~/lolipop-backup/download/LAA0000000-xxxxxx.sql ~/lolipop-backup/db-init/</code></pre>\n<h3>2-3: WordPressの設定を変更</h3>\n<p>WordPress の設定が記述されたファイル <code>~/lolipop-backup/wp/wp-config.php</code> を編集し、WordPress が正しくデータベースに接続できるようにする。</p>\n<ul>\n<li><code>define('DB_USER', '...');</code> →<code>define('DB_USER', 'user');</code></li>\n<li><code>define('DB_PASSWORD', '...');</code> →<code>define('DB_PASSWORD', 'password');</code></li>\n<li><code>define('DB_HOST', '...');</code> →<code>define('DB_HOST', 'mysql:3306');</code></li>\n</ul>\n<h3>2-4: Search-Replace-DB を設置</h3>\n<p>のちほど、データベース内のURLを書き換える必要があるため、書き換えに用いるツールを配置する。</p>\n<pre><code>$ git clone https://github.com/interconnectit/Search-Replace-DB.git ~/lolipop-backup/wp/Search-Replace-DB\n</code></pre>\n<h3>2-5: Apache の設定を変更</h3>\n<p>トップページ以外のページのURIを開いた時も、ApacheではなくWordPressに処理して欲しいので、リクエスト先をindex.phpに向ける必要がある。\n<code>~/lolipop-backup/wp/.htaccess</code> に以下を記述する。</p>\n<div class=\"remark-code-title\">.htaccess</div>\n<pre><code class=\"hljs language-plaintext\"># BEGIN WordPress\n\nRewriteEngine On\nRewriteBase /\nRewriteRule ^index\\.php$ - [L]\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule . /index.php [L]\n\n# END WordPress</code></pre>\n<h2>手順3: 起動する</h2>\n<h3>3-1. Dockerコンテナ群の立ち上げ</h3>\n<p>Dockerコンテナを立ち上げて、バックアップしたページが表示されることを確認する。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> ~/lolipop-backup\n$ docker-compose up -d\n<span class=\"hljs-comment\"># 少し待つ (10秒とか。初回起動時はDBを初期化するので、立ち上げた瞬間にアクセスするとエラーが発生して開けない。開けないだけだが)</span>\n\n$ open http://localhost:8080\n<span class=\"hljs-comment\"># トップページが開けることを確認する</span>\n<span class=\"hljs-comment\"># この状態ではリンクを踏むと、localhost ではなくWeb上のページに飛んでしまう</span></code></pre>\n<h3>3-2. データベース内のURLの置換</h3>\n<p>WordPressのデータベース内では、URLが絶対パスで保持されているらしく、ここまでの手順では、ページ内リンクを踏むと、バックアップ元のWebサーバのページに飛んでしまう。この手順では、データベースを書き換えて、リンクを踏んでもローカルのページを回遊できるようにする。</p>\n<p>今回は <code>www.example.com</code> に設置されたWebサイトをバックアップしているものとする。</p>\n<p>1.Search Replace について</p>\n<ul>\n<li><code>http://localhost:8080/Search-Replace-DB</code> を開く。</li>\n<li>replace (search for...) に <code>http://www.example.com</code>、with (replace with...) に <code>http://localhost:8080</code> を入力</li>\n<li>\n<ul>\n<li>add more search terms をクリック</li>\n</ul>\n</li>\n<li>replace (search for...) に <code>https://www.example.com</code>、with (replace with...) に <code>http://localhost:8080</code> を入力</li>\n</ul>\n<p>2.Database Details について</p>\n<ul>\n<li>database name に データベース名 (<code>LAA0000000-xxxxxx</code>など) を入力</li>\n<li>username に <code>user</code> と入力</li>\n<li>pass に <code>password</code> と入力</li>\n<li>host に <code>mysql</code> と入力</li>\n<li>port に <code>3306</code> と入力</li>\n</ul>\n<p>Test connection を押して、「Success. You are connected.」と表示されることを確認する。</p>\n<p>3.Which Tables? について</p>\n<p>ラジオボタンが all tables を選択していることを確認する。</p>\n<p>4.実行</p>\n<p>入力に誤りがないことを確認して、不安なら「Do a safe test run」をしてみたあとに、「Search and Replace」を実行する。</p>\n<hr>\n<p>ここまでの手順を踏めば、<a href=\"http://localhost:8080\">http://localhost:8080</a> 上で正しくページが表示され、リンクを踏んでもローカルのページに飛べるはず。</p>\n<h2>うまくいかないとき</h2>\n<ul>\n<li>「データベース接続確立エラー」と表示される。</li>\n</ul>\n<p>まず、wp/wp-config.php の中が正しく書き換えられているか確認するとよさそう。\nWordPress に接続した時に「データベース接続確立エラー」と表示される場合は、docker-compose.yml 内のホスト名(今回はmysqlコンテナの3306番に公開されたポートを観に行くので <code>mysql:3306</code>)・データベース名・ユーザ名・パスワード、初期化用sqlファイル内の CREATE DATABASE の行にあるデータベース名、wp-config.php の中にあるホスト名・データベース名・ユーザ名・パスワードが一致しているかを確認してみる</p>\n<ul>\n<li>WordPressのサイトが開けない。「サイトに重大なエラーがありました。」と表示される。</li>\n</ul>\n<p>wp-config.php の中で <code>define('WP_DEBUG', false);</code> の行を <code>define('WP_DEBUG', true);</code> に書き換えるとデバッグモードになってエラーが表示されるので原因究明につながるかもしれない。\nちなみに ftp でファイルをダウンロードするとき、wget コマンドに <code>-l 0</code> オプションを指定しないと途中の階層までしかダウンロードされず、ファイルが欠けてWordPressが起動しなくなる。</p>\n<ul>\n<li>Webページを開くとApacheの404エラーページが出る。</li>\n</ul>\n<p>.htaccess ファイルを設置して、リクエストしたURIに関わらずindex.phpで処理するように設定するとよいかも。</p>\n","content_text":"表題の通り、ロリポップ！レンタルサーバ上に公開されている自身のWebサイトをバックアップし、さらに手元のPC上にdocker-composeで動作するように配置する。\n\n前提の環境\n\nロリポップ！レンタルサーバ上で WordPress を用いた Webサイトを構築している。\n\nmacOS 10.15 Catalina\n\nDocker Desktop for Mac がインストールされている\n\nwget がインストールされている。 (Homebrew を用いて brew install wget でインストール)\n\n手順1: ロリポップ上の情報をダウンロード\n\n1-1: ファイルを抜き出す\n\nはじめにロリポップ！ユーザ専用ページ > ユーザー設定 > アカウント情報 を開いてアカウント情報を確認する。\n今回は以下の内容であったとする。\n\n\n\n次に、ターミナルから以下のコマンドを実行する。\nftp を使って、階層の深さ制限なしに再帰的にファイルをダウンロードする。\n\n\n\nちなみに私の場合は8分で200MB弱をダウンロードした。\n\n1-2: データベースを抜き出す\n\nロリポップ！ユーザ専用ページ > サーバの管理・設定 > データベース を開く。\n\nデータベース名をメモする。今回は LAA0000000-xxxxxx であるとする。\n\nphpMyAdmin を開く。\n\nログインして、画面左のデータベース名を選択 (今回で言えば LAA0000000-xxxxxx)。\n\n\"エクスポート\" タブを開く。\n\nエクスポート方法: \"詳細 - 可能なオプションを全て表示\" のラジオボタンを選択。\n\n生成オプションより追加コマンド: \"CREATE DATABASE / USE コマンドを追加する\" にもチェックを入れる。\n\n他はデフォルトのままで、ページ左下の \"実行\" をクリック。\n\nファイルがダウンロードされるので \\~/lolipop-backup/downlaod/LAA0000000-xxxxxx.sql に移動させる。\n\n手順2: ローカルにWordPress環境を構築\n\n2-1: docker-compose.ymlを整備する\n\n\\~/lolipop-backup/docker-compose.yml を作成し、以下の内容を記述する。\n\\- MYSQL_DATABASE=LAA0000000-xxxxxxの行についてのみ、イコール以降に各自のデータベース名を書き込む必要がある。\n\n\n\n2-2: 抜き出したファイルを設置する\n\n\n\n2-3: WordPressの設定を変更\n\nWordPress の設定が記述されたファイル \\~/lolipop-backup/wp/wp-config.php を編集し、WordPress が正しくデータベースに接続できるようにする。\n\ndefine('DB_USER', '...'); →define('DB_USER', 'user');\n\ndefine('DB_PASSWORD', '...'); →define('DB_PASSWORD', 'password');\n\ndefine('DB_HOST', '...'); →define('DB_HOST', 'mysql:3306');\n\n2-4: Search-Replace-DB を設置\n\nのちほど、データベース内のURLを書き換える必要があるため、書き換えに用いるツールを配置する。\n\n\n\n2-5: Apache の設定を変更\n\nトップページ以外のページのURIを開いた時も、ApacheではなくWordPressに処理して欲しいので、リクエスト先をindex.phpに向ける必要がある。\n\\~/lolipop-backup/wp/.htaccess に以下を記述する。\n\n\n\n手順3: 起動する\n\n3-1. Dockerコンテナ群の立ち上げ\n\nDockerコンテナを立ち上げて、バックアップしたページが表示されることを確認する。\n\n\n\n3-2. データベース内のURLの置換\n\nWordPressのデータベース内では、URLが絶対パスで保持されているらしく、ここまでの手順では、ページ内リンクを踏むと、バックアップ元のWebサーバのページに飛んでしまう。この手順では、データベースを書き換えて、リンクを踏んでもローカルのページを回遊できるようにする。\n\n今回は www\\.example.com に設置されたWebサイトをバックアップしているものとする。\n\n1.Search Replace について\n\nhttp\\://localhost:8080/Search-Replace-DB を開く。\n\nreplace (search for...) に http\\://www\\.example.com、with (replace with...) に http\\://localhost:8080 を入力\n\nadd more search terms をクリック\n\nreplace (search for...) に https\\://www\\.example.com、with (replace with...) に http\\://localhost:8080 を入力\n\n2.Database Details について\n\ndatabase name に データベース名 (LAA0000000-xxxxxxなど) を入力\n\nusername に user と入力\n\npass に password と入力\n\nhost に mysql と入力\n\nport に 3306 と入力\n\nTest connection を押して、「Success. You are connected.」と表示されることを確認する。\n\n3.Which Tables? について\n\nラジオボタンが all tables を選択していることを確認する。\n\n4.実行\n\n入力に誤りがないことを確認して、不安なら「Do a safe test run」をしてみたあとに、「Search and Replace」を実行する。\n\n\n\nここまでの手順を踏めば、http\\://localhost:8080 上で正しくページが表示され、リンクを踏んでもローカルのページに飛べるはず。\n\nうまくいかないとき\n\n「データベース接続確立エラー」と表示される。\n\nまず、wp/wp-config.php の中が正しく書き換えられているか確認するとよさそう。\nWordPress に接続した時に「データベース接続確立エラー」と表示される場合は、docker-compose.yml 内のホスト名(今回はmysqlコンテナの3306番に公開されたポートを観に行くので mysql:3306)・データベース名・ユーザ名・パスワード、初期化用sqlファイル内の CREATE DATABASE の行にあるデータベース名、wp-config.php の中にあるホスト名・データベース名・ユーザ名・パスワードが一致しているかを確認してみる\n\nWordPressのサイトが開けない。「サイトに重大なエラーがありました。」と表示される。\n\nwp-config.php の中で define('WP_DEBUG', false); の行を define('WP_DEBUG', true); に書き換えるとデバッグモードになってエラーが表示されるので原因究明につながるかもしれない。\nちなみに ftp でファイルをダウンロードするとき、wget コマンドに -l 0 オプションを指定しないと途中の階層までしかダウンロードされず、ファイルが欠けてWordPressが起動しなくなる。\n\nWebページを開くとApacheの404エラーページが出る。\n\n.htaccess ファイルを設置して、リクエストしたURIに関わらずindex.phpで処理するように設定するとよいかも。\n"},{"id":"http://localhost:3000/posts/strengths-finder","url":"http://localhost:3000/posts/strengths-finder","title":"僕の、私の、ストレングス・ファインダー (感想)","summary":"会社の研修でストレングス・ファインダーを受けたので、結果を過去の経験と照らし合わせて考えてみます。 読書メモみたいなものです。 ストレングス・ファインダーとは 1998年に心理学者のドナルド・O・クリフトンが開発したオンライン心理テスト。 「実行力」「影響力」「人間関係構築力」「戦略的思考力」の4領域に分類される34の資質のうちどれを自分が持っているのかを判断してくれる。 それぞれの資質を知ることで自分の能力をどのように開発していけばよいかの参考になるらしい。 書籍「さあ、才能(じぶん)に目覚めよう 新版 ストレングス・ファインダー2.0」に付属するアクセスコードから受けることができる。 なお","date_published":"2021-04-19T23:45:00+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E5%83%95%E3%81%AE%E3%80%81%E7%A7%81%E3%81%AE%E3%80%81%E3%82%B9%E3%83%88%E3%83%AC%E3%83%B3%E3%82%B0%E3%82%B9%E3%83%BB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%B3%E3%83%80%E3%83%BC%20(%E6%84%9F%E6%83%B3),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4b8fbeb1ab6d511b1574db240273abb609bc8649","comment":"Add a post 'tokeru-design'\n","date_modified":"2021-04-29T17:29:02+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/49d2ba180e3412d072af1e55eb291f4ba7ae1b10","comment":"Add a post 'strengths-finder'\n","date_modified":"2021-04-19T23:48:01+09:00"}],"content_html":"<p>会社の研修でストレングス・ファインダーを受けたので、結果を過去の経験と照らし合わせて考えてみます。\n読書メモみたいなものです。</p>\n<h2>ストレングス・ファインダーとは</h2>\n<p>1998年に心理学者のドナルド・O・クリフトンが開発したオンライン心理テスト。\n「実行力」「影響力」「人間関係構築力」「戦略的思考力」の4領域に分類される34の資質のうちどれを自分が持っているのかを判断してくれる。\nそれぞれの資質を知ることで自分の能力をどのように開発していけばよいかの参考になるらしい。\n書籍「<a href=\"https://www.amazon.co.jp/%E3%81%95%E3%81%82%E3%80%81%E6%89%8D%E8%83%BD-%E3%81%98%E3%81%B6%E3%82%93-%E3%81%AB%E7%9B%AE%E8%A6%9A%E3%82%81%E3%82%88%E3%81%86-%E6%96%B0%E7%89%88-%E3%82%B9%E3%83%88%E3%83%AC%E3%83%B3%E3%82%B0%E3%82%B9%E3%83%BB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%B3%E3%83%80%E3%83%BC2-0/dp/4532321433/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&#x26;dchild=1&#x26;keywords=%E3%82%B9%E3%83%88%E3%83%AC%E3%83%B3%E3%82%B0%E3%82%B9%E3%83%BB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%B3%E3%83%80%E3%83%BC&#x26;qid=1618838810&#x26;sr=8-1\">さあ、才能(じぶん)に目覚めよう 新版 ストレングス・ファインダー2.0</a>」に付属するアクセスコードから受けることができる。\nなお以降に挙げる引用の出典はすべてこの書籍である。</p>\n<h2>結果</h2>\n<p>私の持つ資質の上位5つは高いものから順に、<strong>分析思考</strong>、<strong>学習心</strong>、<strong>収集心</strong>、<strong>ポジティブ</strong>、<strong>個別化</strong> らしい。前半3つが「戦略的思考力」に、後半2つが「人間関係構築力」に分類されるもののようだ。\nこれらの資質をひとつずつみていく。</p>\n<h3>分析思考</h3>\n<p>分析思考とは、データを好み物事の理由と原因を追求することを好むことを指す。</p>\n<blockquote>\n<p>〈分析思考〉の資質を持つあなたは、他の人に「それを証明しなさい。貴方の主張がなぜ正しいのか示しなさい」と強く要求します。このような詰問を受けると、自分のすばらしい理論がもろくも崩れ落ちるのを感じる人もいます。(p186)</p>\n</blockquote>\n<p>書籍に書かれた上記の文を読んで、他人と議論しているときにまさに自分がよく考える話だと感じた。\nつい先日の研修でのグループワークでも、自分が建設的な意見を出せているわけではないのに、他人の意見の実現可能性が気になってしまっていろいろ質問したくなってしまった。\n悪い方向に走ると意見を潰すような振る舞いになってしまうが、今ある情報からどう判断できるかということをしっかり伝えていくのは必要なことだと思うので、人の意見を良い方向にブラッシュアップできるような発言ができたらよいね。</p>\n<p>あわせて「内容に対しての見解を言うこと」と「人格攻撃をすること」は別であるという点には注意しておきたい。\n本書のアドバイスの中で「あまりキツイことは言い過ぎないように」とあって、わかるし気をつけたいよな〜、改めて心に刻もう、と思った。</p>\n<h3>学習欲</h3>\n<p>学習欲のある人とは、知識を得る状態になることや知識を得た状態だと認識することに満足感を覚える人のことらしい。</p>\n<p>私はコンピュータを触る・学ぶことの面白さに「ブラックボックスを紐解くことが楽しい」ことを挙げることがある。\nコンパイラや認証などを再実装してみたり、大学で既存のソフトウェアに関する講義に興味をもったりしたのは、掘り下げてどう動いているのがわかると楽しいからという理由が強い。</p>\n<p>もっと遡れば小学生の頃、掃除機やラジオなどの古い電化製品を分解していたのを思い出す。\n自覚はしていないが、新しい知識を獲得して学習するプロセスに実は満足感をもっているのかもしれない。</p>\n<p>学習欲の高い人に向けて本書では次のようなアドバイスが挙げられている。</p>\n<blockquote>\n<p>変化を起こす人になりましょう。他の人達は新しい規則や技術を導入したり、環境を整備したりすることに尻込みするかもしれません。(p53)</p>\n</blockquote>\n<blockquote>\n<p>技術や規則が常に変化する分野にキャリアを変更しましょう。これに対応しようと挑戦し続けることであなたはいきいきとします。(p53)</p>\n</blockquote>\n<p>ソフトウェアエンジニアを職業に選んだのは正解だったようだ。\n常に環境が変化する状況で新しいものをキャッチアップし続けることが特に必要な業種だと思うので、変化を受け入れてそれについていける、さらにはそういった流れを作れるような人材になれると良いですね。</p>\n<h3>収集心</h3>\n<p>(ここでいう) 収集心とは、物理的な物の収集欲に限らず、情報を収集することを好む人も含んでいるらしい。\nたしかにWikipediaは永遠に見れるタイプだし、旅行に行く前には調べるタイプだし、社会のものがどう動いているか仕組みを知りたいみたいな気持ちは強いかもしれない。\n本も電子派だけど紙を捨てるときはスキャンするし、Google フォームの内容や一時的な目的のために配られた資料も保管しておきたくなったりする。</p>\n<blockquote>\n<p>情報を保管し、簡単に探し出すことができる仕組みを考案しましょう。(p121)</p>\n</blockquote>\n<p>本書には上のようなアドバイスが書かれていて、これは自分が課題に感じていることの１つだ。\nメモをとったり思考を整理したり、それらの情報にアクセスするためのツールが定まっていない。\n数年前は Google Keep を使っていたが、いつ記録した情報かが残りづらく使うのを止めた。</p>\n<p>今だとたぶんScrapboxとかNotionとかになるのだろうけど、どちらも全然使いこなせていない。\nこういったアプリケーションは移り変わりが早いのでロックインされたくなくてMarkdown最強説を唱えるときもあったものの、メモを集めたgitリポジトリも整理されてアクセスしやすい状況とはいえないな。\nどうにかせねばなあ。</p>\n<h3>ポジティブ</h3>\n<p>ポジティブが上位に入っているのは嬉しい。</p>\n<p>昔 (これまた小学生くらいの頃) は自分をネガティヴだと自覚していて、自分のことを説明するときはネガティヴだと言っていた。\nしかしネガティヴな自分が嫌で、無駄に自分や他人を落ち込ませるような気がして、いつからか言霊でもいいからなるべく言葉では無理矢理でもいいからポジティブになるような発言を心がけていた。</p>\n<p>いつしかそうやって言霊だと思っていた考えが自分の中のポジティブな思考として定着して、物事を悲観的に考えずに済むようになった。\n今回のテストで上位に上がってきたことをもって「自分がポジティブな思考を持った」と言えるようになったと思う。\n自分の性格は自分で変えられることを示たので嬉しい。</p>\n<blockquote>\n<p>日頃から楽しい話や冗談などを準備しておきましょう。(p201)</p>\n</blockquote>\n<p>誰も傷つけないで笑いをとりたい。面白い話ができる人になりたいね。</p>\n<h3>個別化</h3>\n<p>個別化の資質を持つ人は、一人ひとりのユニークな個性に興味をそそられそれを理解することに長けているらしい。\nこれは正直よくわからないけど、自分のわがままを持っているから他人のわがままも受け入れあえたら幸せだよなと思っている。</p>\n<blockquote>\n<p>チームの各メンバーが最も得意とすることを見極めましょう。(p89)</p>\n</blockquote>\n<p>上のようなアドバイスが示されているが、そうやって得意なことを生かしたチームがつくれたら最強だよな。\nあまり共感と理解ができてないのでこの項はさっくり終わる。</p>\n<h2>まとめ</h2>\n<p>自分の資質は4領域のうち「人間関係構築力」「戦略的思考力」に偏っていて、「実行力」「影響力」は強みではないらしい。\n実際のところ実行力も影響力もないのはなんとなく同意してしまうな。\nしかしながら働いていく上ではこれらもある程度必要だと思うので、どうカバーできるか考えていきたい。</p>\n<p>そもそもこういった心理テストは「答えを見たときに自分の中で当てはまりそうな行動や理由を見つけて納得したような気になる」ことがよくあるように思う。\nさらにストレングス・ファインダーの結果は時間が経てば変わることもあるらしく「絶対的な自分の能力」ではなく「今の自分にとっての強みとなりうる要素」を表すものらしい。</p>\n<p>今回の結果が実際のところどれほど適切な指摘をしているのかはわからないが、今後の仕事での振る舞いや方向性を決めていくための自分を振り返る機会になった。\n今回の内容を過信しすぎず、しかしながら自分の行動を律するときの一つの指標として適切な距離感で捉えておきたい。</p>\n","content_text":"会社の研修でストレングス・ファインダーを受けたので、結果を過去の経験と照らし合わせて考えてみます。\n読書メモみたいなものです。\n\nストレングス・ファインダーとは\n\n1998年に心理学者のドナルド・O・クリフトンが開発したオンライン心理テスト。\n「実行力」「影響力」「人間関係構築力」「戦略的思考力」の4領域に分類される34の資質のうちどれを自分が持っているのかを判断してくれる。\nそれぞれの資質を知ることで自分の能力をどのように開発していけばよいかの参考になるらしい。\n書籍「さあ、才能(じぶん)に目覚めよう 新版 ストレングス・ファインダー2.0」に付属するアクセスコードから受けることができる。\nなお以降に挙げる引用の出典はすべてこの書籍である。\n\n結果\n\n私の持つ資質の上位5つは高いものから順に、分析思考、学習心、収集心、ポジティブ、個別化 らしい。前半3つが「戦略的思考力」に、後半2つが「人間関係構築力」に分類されるもののようだ。\nこれらの資質をひとつずつみていく。\n\n分析思考\n\n分析思考とは、データを好み物事の理由と原因を追求することを好むことを指す。\n\n〈分析思考〉の資質を持つあなたは、他の人に「それを証明しなさい。貴方の主張がなぜ正しいのか示しなさい」と強く要求します。このような詰問を受けると、自分のすばらしい理論がもろくも崩れ落ちるのを感じる人もいます。(p186)\n\n書籍に書かれた上記の文を読んで、他人と議論しているときにまさに自分がよく考える話だと感じた。\nつい先日の研修でのグループワークでも、自分が建設的な意見を出せているわけではないのに、他人の意見の実現可能性が気になってしまっていろいろ質問したくなってしまった。\n悪い方向に走ると意見を潰すような振る舞いになってしまうが、今ある情報からどう判断できるかということをしっかり伝えていくのは必要なことだと思うので、人の意見を良い方向にブラッシュアップできるような発言ができたらよいね。\n\nあわせて「内容に対しての見解を言うこと」と「人格攻撃をすること」は別であるという点には注意しておきたい。\n本書のアドバイスの中で「あまりキツイことは言い過ぎないように」とあって、わかるし気をつけたいよな〜、改めて心に刻もう、と思った。\n\n学習欲\n\n学習欲のある人とは、知識を得る状態になることや知識を得た状態だと認識することに満足感を覚える人のことらしい。\n\n私はコンピュータを触る・学ぶことの面白さに「ブラックボックスを紐解くことが楽しい」ことを挙げることがある。\nコンパイラや認証などを再実装してみたり、大学で既存のソフトウェアに関する講義に興味をもったりしたのは、掘り下げてどう動いているのがわかると楽しいからという理由が強い。\n\nもっと遡れば小学生の頃、掃除機やラジオなどの古い電化製品を分解していたのを思い出す。\n自覚はしていないが、新しい知識を獲得して学習するプロセスに実は満足感をもっているのかもしれない。\n\n学習欲の高い人に向けて本書では次のようなアドバイスが挙げられている。\n\n変化を起こす人になりましょう。他の人達は新しい規則や技術を導入したり、環境を整備したりすることに尻込みするかもしれません。(p53)\n\n技術や規則が常に変化する分野にキャリアを変更しましょう。これに対応しようと挑戦し続けることであなたはいきいきとします。(p53)\n\nソフトウェアエンジニアを職業に選んだのは正解だったようだ。\n常に環境が変化する状況で新しいものをキャッチアップし続けることが特に必要な業種だと思うので、変化を受け入れてそれについていける、さらにはそういった流れを作れるような人材になれると良いですね。\n\n収集心\n\n(ここでいう) 収集心とは、物理的な物の収集欲に限らず、情報を収集することを好む人も含んでいるらしい。\nたしかにWikipediaは永遠に見れるタイプだし、旅行に行く前には調べるタイプだし、社会のものがどう動いているか仕組みを知りたいみたいな気持ちは強いかもしれない。\n本も電子派だけど紙を捨てるときはスキャンするし、Google フォームの内容や一時的な目的のために配られた資料も保管しておきたくなったりする。\n\n情報を保管し、簡単に探し出すことができる仕組みを考案しましょう。(p121)\n\n本書には上のようなアドバイスが書かれていて、これは自分が課題に感じていることの１つだ。\nメモをとったり思考を整理したり、それらの情報にアクセスするためのツールが定まっていない。\n数年前は Google Keep を使っていたが、いつ記録した情報かが残りづらく使うのを止めた。\n\n今だとたぶんScrapboxとかNotionとかになるのだろうけど、どちらも全然使いこなせていない。\nこういったアプリケーションは移り変わりが早いのでロックインされたくなくてMarkdown最強説を唱えるときもあったものの、メモを集めたgitリポジトリも整理されてアクセスしやすい状況とはいえないな。\nどうにかせねばなあ。\n\nポジティブ\n\nポジティブが上位に入っているのは嬉しい。\n\n昔 (これまた小学生くらいの頃) は自分をネガティヴだと自覚していて、自分のことを説明するときはネガティヴだと言っていた。\nしかしネガティヴな自分が嫌で、無駄に自分や他人を落ち込ませるような気がして、いつからか言霊でもいいからなるべく言葉では無理矢理でもいいからポジティブになるような発言を心がけていた。\n\nいつしかそうやって言霊だと思っていた考えが自分の中のポジティブな思考として定着して、物事を悲観的に考えずに済むようになった。\n今回のテストで上位に上がってきたことをもって「自分がポジティブな思考を持った」と言えるようになったと思う。\n自分の性格は自分で変えられることを示たので嬉しい。\n\n日頃から楽しい話や冗談などを準備しておきましょう。(p201)\n\n誰も傷つけないで笑いをとりたい。面白い話ができる人になりたいね。\n\n個別化\n\n個別化の資質を持つ人は、一人ひとりのユニークな個性に興味をそそられそれを理解することに長けているらしい。\nこれは正直よくわからないけど、自分のわがままを持っているから他人のわがままも受け入れあえたら幸せだよなと思っている。\n\nチームの各メンバーが最も得意とすることを見極めましょう。(p89)\n\n上のようなアドバイスが示されているが、そうやって得意なことを生かしたチームがつくれたら最強だよな。\nあまり共感と理解ができてないのでこの項はさっくり終わる。\n\nまとめ\n\n自分の資質は4領域のうち「人間関係構築力」「戦略的思考力」に偏っていて、「実行力」「影響力」は強みではないらしい。\n実際のところ実行力も影響力もないのはなんとなく同意してしまうな。\nしかしながら働いていく上ではこれらもある程度必要だと思うので、どうカバーできるか考えていきたい。\n\nそもそもこういった心理テストは「答えを見たときに自分の中で当てはまりそうな行動や理由を見つけて納得したような気になる」ことがよくあるように思う。\nさらにストレングス・ファインダーの結果は時間が経てば変わることもあるらしく「絶対的な自分の能力」ではなく「今の自分にとっての強みとなりうる要素」を表すものらしい。\n\n今回の結果が実際のところどれほど適切な指摘をしているのかはわからないが、今後の仕事での振る舞いや方向性を決めていくための自分を振り返る機会になった。\n今回の内容を過信しすぎず、しかしながら自分の行動を律するときの一つの指標として適切な距離感で捉えておきたい。\n"},{"id":"http://localhost:3000/posts/20210408","url":"http://localhost:3000/posts/20210408","title":"社会人一週目の所感","summary":"4/1に社会人になり一週間が経った。 職種合同での研修期間中で実際の仕事やエンジニアリングとはまだ少し距離がある。 研修もまだまだこれからだけど、区切りが良い日なので今日の気持ちを記録しようかと。 生活について まず当たり前だが、社会人は結構疲れる。 3月末までは一日中暇で、好きなだけコードを書き好きなだけネット見て好きなだけ寝ていたので差が大きいだけで、毎日朝から夕方まで集中していたら人間誰でも疲れるだろう。 睡眠は本当に大事。 一昨日つい睡眠時間を削ったら昨日は一日中眠くて、仕事終わった直後にベッドで爆睡した。 これができるから在宅勤務は良い。通勤が無くて良い。 慣れてしまったら毎日出社な","date_published":"2021-04-09T00:57:25+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E7%A4%BE%E4%BC%9A%E4%BA%BA%E4%B8%80%E9%80%B1%E7%9B%AE%E3%81%AE%E6%89%80%E6%84%9F,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10dfb4350634559eac218dc1c620ec3a198a2942","comment":"Fix the wording\n","date_modified":"2021-04-09T21:37:08+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/00a3449e1581ba247a3ef20eca1495b016629492","comment":"Add a post of '20210408.md'\n","date_modified":"2021-04-09T01:21:46+09:00"}],"content_html":"<p>4/1に社会人になり一週間が経った。\n職種合同での研修期間中で実際の仕事やエンジニアリングとはまだ少し距離がある。\n研修もまだまだこれからだけど、区切りが良い日なので今日の気持ちを記録しようかと。</p>\n<h2>生活について</h2>\n<p>まず当たり前だが、社会人は結構疲れる。\n3月末までは一日中暇で、好きなだけコードを書き好きなだけネット見て好きなだけ寝ていたので差が大きいだけで、毎日朝から夕方まで集中していたら人間誰でも疲れるだろう。\n睡眠は本当に大事。\n一昨日つい睡眠時間を削ったら昨日は一日中眠くて、仕事終わった直後にベッドで爆睡した。\nこれができるから在宅勤務は良い。通勤が無くて良い。\n慣れてしまったら毎日出社なんてできない人間になる気がする。</p>\n<p>あとは時間を大切にしたくなる。\n研修後にレポートを書くのだが、疲れたからゆっくりやるかと思うとそれだけで凄く時間がかかる。\n1日がすぐに終わってまた朝になる。\n逆にテキパキすれば時間はたくさんあって(通勤時間ないし残業もないし)、朝に本を読んだりできるし、こうやってブログを書くこともできる。休むときはしっかり休む、集中するときはガッとやる、意識的に時間で区切っていきたい。</p>\n<p>区切るといえば、リモートワークなので自室で寝て自室で働くのだが、自分の緊張感を意識的に切り替えるために2つのことを決めた。</p>\n<ul>\n<li>ドアを開ける ...</li>\n</ul>\n<p>始業中で会話をしているときにドアを閉めるのは当然として、それ以外の時間は開けるようにしている。\n空気も入れ替わるし、心のスイッチにもなるし、同居の家族も「今は声をかけていいのか」が明確にわかるので良い。</p>\n<ul>\n<li>早く風呂に入る ...</li>\n</ul>\n<p>終業後に気分を緩めるために風呂に入るのがいい。\nゆっくり出来るし体に水を浴びると気分が変わる。\nあと風呂に入ることを面倒に思う人種からすると、入るのが後回しなり夜ふかしすることを避けられるのも良い。</p>\n<p>ほかにも、時間のあるときに本を少しずつ読み進めてみている。\n(いままでは気分がノッたときに一気に読破することがほとんどだったが、平日はまとまって時間取るのも難しそう。)\nしかしながら少しずつ読むと、翌日になったら以前の内容を忘れていたりして内容を掴みづらいと感じる。\n打開策として、手の感覚などからどこまで読んだかという情報が記憶に残りやすいのではないかと物理本を注文してみた。\n本を裁断して自炊するほど電子書籍を好んでいたので物理本はだいぶ久々な気がする。\n効果はあるだろうか、どうかな？</p>\n<h2>研修について</h2>\n<p>話は変わって研修について。\n講義形式のものとチームで課題にとりかかるものの2種類があり、講義形式のものはいろいろな学びがあった。\nビジネスマナーの習得機会でもあったし、自分は将来の夢や目標が明確でないことがわかったし、会社について理解を深めたつもり。</p>\n<p>一方、チームで課題に取りかかるものは結構大変だった。</p>\n<p>ひとつは答えのない問題に対しての解決策を限られた時間で議論すること、導くことの難しさ。\n(就活でグループワークの練習をしたときのことを思い出した。結局選考ではやってないが。)\n途中で焦って方向性のハンドリングをミスったような気がしたけど、優秀なチームメンバーのおかげで終わってみると案外丸くまとまっていたりする。\nてんやわんやするも意図しての研修のような気もするので、とりあえず乗り切ったことを喜びたい。</p>\n<p>もうひとつは言語の壁。\n日本語を母語としない方がチームにいて、英語でコミュニケーションする必要があった。(多様性は歓迎されるべきことで良いこと。)\n人生でたまに必要になるんだよな英会話。\n一応配慮があって留学経験のある人が同じチームにいたのだけど (ありがたい) (めちゃめちゃ発音きれいだった)、自分も割と頑張って英語を喋ろうとした、したけれど...</p>\n<p>最初は途中途中に英語で「今こんなことを考えているんだけど貴方の意見は？」と議論を整理して振ろうとしてみてみたり、テキストベースで進めてみたりしようとしたものの、最終的には結局全然うまく行かなかった。\nテキストベースの議論が難しかった原因は、研修の都合でコミュニケーションツールが Zoom のみに限定されていたということもあるけれど、一番は「議論が白熱すると余裕がない」ことだった。\n日本語で考えるのでさえ精一杯で、どうしようかと悩み、時間がなく焦っている状況だった。\n散らかった議論をそのまま英語で話すのも厳しいし、整理して説明する余裕もない。\n結局チームの中で情報格差の壁ができたままになってしまって、現状を伝えて一緒に考えることが難しくなっていった。\n日本語ベースの研修だから仕方ない部分もあるだろうけど、結局チームも分断されてしまった (疎外感を与えてしまっただろう) し、その方の学びの機会も少なくなってしまった気がして、申し訳ない気持ちと残念な気持ちのまま研修が終わってしまった。</p>\n<p>どう進めればよかったのだろうか、今考えてもわからない。\nある程度議論のスピードを抑えてでも丁寧に進めるべきだったのかもしれない。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">英語力欲しすぎ太郎</p>&mdash; やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1377835243336425473?ref_src=twsrc%5Etfw\">April 2, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>文章の方向性がわからなくなってきたので、ちょっと話を変えましょう。\nリモートワークが中心でありコロナ禍ということもあり、内定をいただいてから一度も出社してないし、同期の人とは殆ど物理的に顔を合わせたことがない。\nその上にまだ入社1週間なのだが、研修のチームが違えど会社の同期の人同士では既にたくさんコミュニケーションをとっているし、なんとなく近くにいる気がする。\nチームでの課題で「大変だな」という気分になっているときも Slackを通して同期の人々に支えられる気分になるし (ありがとうございます)、いい会社にはいい人が集まるんだろうな。</p>\n<p>明日からまた研修が続くのでそろそろ寝ましょう。\nおやすみなさい。</p>\n","content_text":"4/1に社会人になり一週間が経った。\n職種合同での研修期間中で実際の仕事やエンジニアリングとはまだ少し距離がある。\n研修もまだまだこれからだけど、区切りが良い日なので今日の気持ちを記録しようかと。\n\n生活について\n\nまず当たり前だが、社会人は結構疲れる。\n3月末までは一日中暇で、好きなだけコードを書き好きなだけネット見て好きなだけ寝ていたので差が大きいだけで、毎日朝から夕方まで集中していたら人間誰でも疲れるだろう。\n睡眠は本当に大事。\n一昨日つい睡眠時間を削ったら昨日は一日中眠くて、仕事終わった直後にベッドで爆睡した。\nこれができるから在宅勤務は良い。通勤が無くて良い。\n慣れてしまったら毎日出社なんてできない人間になる気がする。\n\nあとは時間を大切にしたくなる。\n研修後にレポートを書くのだが、疲れたからゆっくりやるかと思うとそれだけで凄く時間がかかる。\n1日がすぐに終わってまた朝になる。\n逆にテキパキすれば時間はたくさんあって(通勤時間ないし残業もないし)、朝に本を読んだりできるし、こうやってブログを書くこともできる。休むときはしっかり休む、集中するときはガッとやる、意識的に時間で区切っていきたい。\n\n区切るといえば、リモートワークなので自室で寝て自室で働くのだが、自分の緊張感を意識的に切り替えるために2つのことを決めた。\n\nドアを開ける ...\n\n始業中で会話をしているときにドアを閉めるのは当然として、それ以外の時間は開けるようにしている。\n空気も入れ替わるし、心のスイッチにもなるし、同居の家族も「今は声をかけていいのか」が明確にわかるので良い。\n\n早く風呂に入る ...\n\n終業後に気分を緩めるために風呂に入るのがいい。\nゆっくり出来るし体に水を浴びると気分が変わる。\nあと風呂に入ることを面倒に思う人種からすると、入るのが後回しなり夜ふかしすることを避けられるのも良い。\n\nほかにも、時間のあるときに本を少しずつ読み進めてみている。\n(いままでは気分がノッたときに一気に読破することがほとんどだったが、平日はまとまって時間取るのも難しそう。)\nしかしながら少しずつ読むと、翌日になったら以前の内容を忘れていたりして内容を掴みづらいと感じる。\n打開策として、手の感覚などからどこまで読んだかという情報が記憶に残りやすいのではないかと物理本を注文してみた。\n本を裁断して自炊するほど電子書籍を好んでいたので物理本はだいぶ久々な気がする。\n効果はあるだろうか、どうかな？\n\n研修について\n\n話は変わって研修について。\n講義形式のものとチームで課題にとりかかるものの2種類があり、講義形式のものはいろいろな学びがあった。\nビジネスマナーの習得機会でもあったし、自分は将来の夢や目標が明確でないことがわかったし、会社について理解を深めたつもり。\n\n一方、チームで課題に取りかかるものは結構大変だった。\n\nひとつは答えのない問題に対しての解決策を限られた時間で議論すること、導くことの難しさ。\n(就活でグループワークの練習をしたときのことを思い出した。結局選考ではやってないが。)\n途中で焦って方向性のハンドリングをミスったような気がしたけど、優秀なチームメンバーのおかげで終わってみると案外丸くまとまっていたりする。\nてんやわんやするも意図しての研修のような気もするので、とりあえず乗り切ったことを喜びたい。\n\nもうひとつは言語の壁。\n日本語を母語としない方がチームにいて、英語でコミュニケーションする必要があった。(多様性は歓迎されるべきことで良いこと。)\n人生でたまに必要になるんだよな英会話。\n一応配慮があって留学経験のある人が同じチームにいたのだけど (ありがたい) (めちゃめちゃ発音きれいだった)、自分も割と頑張って英語を喋ろうとした、したけれど...\n\n最初は途中途中に英語で「今こんなことを考えているんだけど貴方の意見は？」と議論を整理して振ろうとしてみてみたり、テキストベースで進めてみたりしようとしたものの、最終的には結局全然うまく行かなかった。\nテキストベースの議論が難しかった原因は、研修の都合でコミュニケーションツールが Zoom のみに限定されていたということもあるけれど、一番は「議論が白熱すると余裕がない」ことだった。\n日本語で考えるのでさえ精一杯で、どうしようかと悩み、時間がなく焦っている状況だった。\n散らかった議論をそのまま英語で話すのも厳しいし、整理して説明する余裕もない。\n結局チームの中で情報格差の壁ができたままになってしまって、現状を伝えて一緒に考えることが難しくなっていった。\n日本語ベースの研修だから仕方ない部分もあるだろうけど、結局チームも分断されてしまった (疎外感を与えてしまっただろう) し、その方の学びの機会も少なくなってしまった気がして、申し訳ない気持ちと残念な気持ちのまま研修が終わってしまった。\n\nどう進めればよかったのだろうか、今考えてもわからない。\nある程度議論のスピードを抑えてでも丁寧に進めるべきだったのかもしれない。\n\n\n\n文章の方向性がわからなくなってきたので、ちょっと話を変えましょう。\nリモートワークが中心でありコロナ禍ということもあり、内定をいただいてから一度も出社してないし、同期の人とは殆ど物理的に顔を合わせたことがない。\nその上にまだ入社1週間なのだが、研修のチームが違えど会社の同期の人同士では既にたくさんコミュニケーションをとっているし、なんとなく近くにいる気がする。\nチームでの課題で「大変だな」という気分になっているときも Slackを通して同期の人々に支えられる気分になるし (ありがとうございます)、いい会社にはいい人が集まるんだろうな。\n\n明日からまた研修が続くのでそろそろ寝ましょう。\nおやすみなさい。\n"},{"id":"http://localhost:3000/posts/mail-backup-mbox","url":"http://localhost:3000/posts/mail-backup-mbox","title":"Office365メールやGmailをローカルにバックアップする (macOS)","summary":"3月で大学を卒業するにあたり、大学のメール (Office365) と研究室のメール (Google Workspace) が使えなくなる。 閲覧もできなくなるのでバックアップを取っておきたいので試してみる。 メールの取得 Gmail 上のすべてのメールを mbox 形式で取得する Google は サービス上の個人データをエクスポートする機能を提供している。 参考: Gmail からデータを書き出す - Gmail ヘルプ 2021/03現在では、次の手順で取得できる。 Gmail を開き、右上の自分のアイコンをクリックして、「Google アカウントを管理」を選択 「データとカスタマイズ」","date_published":"2021-03-28T18:03:06+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Office365%E3%83%A1%E3%83%BC%E3%83%AB%E3%82%84Gmail%E3%82%92%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%AB%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%81%99%E3%82%8B%20(macOS),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","メール"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a6ab6b9b1aed23edf9066610d53b55e68a05f389","comment":"Add a post\n","date_modified":"2021-03-28T19:52:28+09:00"}],"content_html":"<p>3月で大学を卒業するにあたり、大学のメール (Office365) と研究室のメール (Google Workspace) が使えなくなる。\n閲覧もできなくなるのでバックアップを取っておきたいので試してみる。</p>\n<h2>メールの取得</h2>\n<h3>Gmail 上のすべてのメールを mbox 形式で取得する</h3>\n<p>Google は サービス上の個人データをエクスポートする機能を提供している。</p>\n<p>参考: <a href=\"https://support.google.com/mail/answer/10016932?hl=ja\">Gmail からデータを書き出す - Gmail ヘルプ</a></p>\n<p>2021/03現在では、次の手順で取得できる。</p>\n<ol>\n<li>Gmail を開き、右上の自分のアイコンをクリックして、「Google アカウントを管理」を選択</li>\n<li>「データとカスタマイズ」タブに移動し、中段の「データのダウンロード、削除」から「データをダウンロード」を選択</li>\n<li>「新しいエクスポートの作成」の右下にある「選択をすべて解除」をクリック</li>\n<li>スクロールして下の方に移動し、「メール」のチェックボックスを選択状態にする</li>\n<li>さらに下に移動し「次のステップ」を選択</li>\n<li>「エクスポートを作成」を選択</li>\n<li>しばらく時間が立つと自分のメールアドレスにダウンロードリンクが届くので、これを開いてzipファイルをダウンロード</li>\n</ol>\n<h3>Apple純正の Mail.app でメールボックスごとに mbox 形式で取得する</h3>\n<p>Office365 は Gmail のようにエクスポート機能を提供していない。\n一方で macOSでは、純正で付属する Mail.app を用いてメールボックスのメールをエクスポートすることができる。</p>\n<p>参考: <a href=\"https://support.apple.com/ja-jp/guide/mail/mlhlp1030/mac\">Macの「メール」でメールボックスを読み込む/書き出す - Apple サポート</a></p>\n<p>例えば「受信トレイ」や「送信済み」なども含めたすべてのメールを「アーカイブ」に移動し、「アーカイブ」のメールボックスを右クリックして「メールボックスを書き出す」を選ぶとすべてのメールを単一の mbox 形式でエクスポートできる。</p>\n<p>(Office365 だけでなく Gmail を含む他のサービスのメールも、Mail.app でログインして同期すれば、この機能からメールをエクスポートできる)</p>\n<h2>メールの閲覧</h2>\n<p><a href=\"http://www.mutt.org\">mutt</a> という CLI で mbox 形式のメールを閲覧できる。</p>\n<h3>インストール</h3>\n<pre><code class=\"hljs language-sh\">$ brew install mutt</code></pre>\n<h3>メールを見る</h3>\n<pre><code class=\"hljs language-sh\">$ mutt -f path/to/mail-file.mbox</code></pre>\n<p>操作は次のとおり</p>\n<table>\n<thead>\n<tr>\n<th>キー</th>\n<th align=\"left\">動作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>j</td>\n<td align=\"left\">下へ</td>\n</tr>\n<tr>\n<td>k</td>\n<td align=\"left\">上へ</td>\n</tr>\n<tr>\n<td>z</td>\n<td align=\"left\">次ページへ</td>\n</tr>\n<tr>\n<td>Z</td>\n<td align=\"left\">前ページへ</td>\n</tr>\n<tr>\n<td>/</td>\n<td align=\"left\">正規表現で検索</td>\n</tr>\n<tr>\n<td>Enter</td>\n<td align=\"left\">メールを読む</td>\n</tr>\n<tr>\n<td>q</td>\n<td align=\"left\">戻る / 終了</td>\n</tr>\n</tbody>\n</table>\n<h2>経緯といざこざ</h2>\n<p>メールをローカルに保存するときは、Unix, Linuxで用いられる形式として mbox 形式 (１つのファイルに複数のメールを記録) と Mail Dir形式 (1つのファイルに1つのメールを記録)、Windows で用いられている形式として eml形式 (1つのファイルに1つのメールを記録) などが代表的なよう。\n今回は使わなくなるメールアドレスの過去のメールを保存しておきたいだけなので、後から見返しやすければどの形式でも良い。mbox 形式でのエクスポートがやりやすかったので mbox を選んだ。</p>\n<p>macOS ないし Ubuntu からメールをDownloadする CLI として getmail や fetchmail 等があるが、CLIからだと Office365 や Gmali の2段階認証を超えるのが面倒そうだった。\nThunderbird のエクステンションでのエクスポートも、エクスポート後のファイルを mutt で閲覧できなかったのでやめた。\n右往左往していて最終的に OS にバンドルされた Mail.app で mbox 形式でのエクスポートができることがわかり解決。\nmacOS の純正アプリケーションは PDF の切り取りや並べ替えができたり、簡易的にRAW現像できたりと意外にも高機能なのでよく助けられている気がする。Appleありがとう。</p>\n","content_text":"3月で大学を卒業するにあたり、大学のメール (Office365) と研究室のメール (Google Workspace) が使えなくなる。\n閲覧もできなくなるのでバックアップを取っておきたいので試してみる。\n\nメールの取得\n\nGmail 上のすべてのメールを mbox 形式で取得する\n\nGoogle は サービス上の個人データをエクスポートする機能を提供している。\n\n参考: Gmail からデータを書き出す - Gmail ヘルプ\n\n2021/03現在では、次の手順で取得できる。\n\nGmail を開き、右上の自分のアイコンをクリックして、「Google アカウントを管理」を選択\n\n「データとカスタマイズ」タブに移動し、中段の「データのダウンロード、削除」から「データをダウンロード」を選択\n\n「新しいエクスポートの作成」の右下にある「選択をすべて解除」をクリック\n\nスクロールして下の方に移動し、「メール」のチェックボックスを選択状態にする\n\nさらに下に移動し「次のステップ」を選択\n\n「エクスポートを作成」を選択\n\nしばらく時間が立つと自分のメールアドレスにダウンロードリンクが届くので、これを開いてzipファイルをダウンロード\n\nApple純正の Mail.app でメールボックスごとに mbox 形式で取得する\n\nOffice365 は Gmail のようにエクスポート機能を提供していない。\n一方で macOSでは、純正で付属する Mail.app を用いてメールボックスのメールをエクスポートすることができる。\n\n参考: Macの「メール」でメールボックスを読み込む/書き出す - Apple サポート\n\n例えば「受信トレイ」や「送信済み」なども含めたすべてのメールを「アーカイブ」に移動し、「アーカイブ」のメールボックスを右クリックして「メールボックスを書き出す」を選ぶとすべてのメールを単一の mbox 形式でエクスポートできる。\n\n(Office365 だけでなく Gmail を含む他のサービスのメールも、Mail.app でログインして同期すれば、この機能からメールをエクスポートできる)\n\nメールの閲覧\n\nmutt という CLI で mbox 形式のメールを閲覧できる。\n\nインストール\n\n\n\nメールを見る\n\n\n\n操作は次のとおり\n\n\n\n経緯といざこざ\n\nメールをローカルに保存するときは、Unix, Linuxで用いられる形式として mbox 形式 (１つのファイルに複数のメールを記録) と Mail Dir形式 (1つのファイルに1つのメールを記録)、Windows で用いられている形式として eml形式 (1つのファイルに1つのメールを記録) などが代表的なよう。\n今回は使わなくなるメールアドレスの過去のメールを保存しておきたいだけなので、後から見返しやすければどの形式でも良い。mbox 形式でのエクスポートがやりやすかったので mbox を選んだ。\n\nmacOS ないし Ubuntu からメールをDownloadする CLI として getmail や fetchmail 等があるが、CLIからだと Office365 や Gmali の2段階認証を超えるのが面倒そうだった。\nThunderbird のエクステンションでのエクスポートも、エクスポート後のファイルを mutt で閲覧できなかったのでやめた。\n右往左往していて最終的に OS にバンドルされた Mail.app で mbox 形式でのエクスポートができることがわかり解決。\nmacOS の純正アプリケーションは PDF の切り取りや並べ替えができたり、簡易的にRAW現像できたりと意外にも高機能なのでよく助けられている気がする。Appleありがとう。\n"},{"id":"http://localhost:3000/posts/tcp-packet-layout","url":"http://localhost:3000/posts/tcp-packet-layout","title":"TCP/IP における全レイヤを俯瞰したパケットの構成","summary":"ふとしたときに TCP/IP でのパケットの各フィールドにどんなものがあったか確認したくなることがあるので、レイヤごとに分けずまとめて書かれた物があると便利。 以下, Ethernet, IPv4, TCP, HTTP を用いたパケットの各フィールドの配置を表した図。 各フィールドの意味は記載しません。 TCPパケットの全レイヤを通したフィールドの構成図 ","date_published":"2021-02-19T11:24:44+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:TCP%2FIP%20%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%85%A8%E3%83%AC%E3%82%A4%E3%83%A4%E3%82%92%E4%BF%AF%E7%9E%B0%E3%81%97%E3%81%9F%E3%83%91%E3%82%B1%E3%83%83%E3%83%88%E3%81%AE%E6%A7%8B%E6%88%90,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["HTTP","TCP/IP"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1244f9e907d244f482f32b56c343dcffcc231605","comment":"Add a post of tcp-packet-layout\n","date_modified":"2021-02-19T11:35:40+09:00"}],"content_html":"<p>ふとしたときに TCP/IP でのパケットの各フィールドにどんなものがあったか確認したくなることがあるので、レイヤごとに分けずまとめて書かれた物があると便利。</p>\n<p>以下, Ethernet, IPv4, TCP, HTTP を用いたパケットの各フィールドの配置を表した図。\n各フィールドの意味は記載しません。</p>\n<p><img src=\"https://blob.yammer.jp/tcp-packet-layout.svg\" alt=\"TCPパケットの全レイヤを通したフィールドの構成図\"></p>\n","content_text":"ふとしたときに TCP/IP でのパケットの各フィールドにどんなものがあったか確認したくなることがあるので、レイヤごとに分けずまとめて書かれた物があると便利。\n\n以下, Ethernet, IPv4, TCP, HTTP を用いたパケットの各フィールドの配置を表した図。\n各フィールドの意味は記載しません。\n\nTCPパケットの全レイヤを通したフィールドの構成図\n"},{"id":"http://localhost:3000/posts/20210218","url":"http://localhost:3000/posts/20210218","title":"卒業論文の発表を終えた。近況。","summary":"先週に卒業論文を提出し、今日その内容を学科内で発表した。 無事合格できた旨のメールを先ほど受け取って、これで大学4年間の全ての単位を取得できる見込みになった。 最近は論文執筆に勤しんでいた。 新年の意気込みで早寝早起きと言っておきながら最近はだいぶ夜ふかしをしていたし、本を読む目標もあまり進んでいない。 少し読んだ本もあるが、そんな時間があるなら論文を書きましょうという感じだった。 というわけで駄文でした。 研究が終わったらやりたいことがいくつか溜まっていたので順番に消化していきたい。 気分症なのでいくつか既に昇華してしまったものもあるが、まあよいだろう。 生活リズムも戻します。 ブログもまた","date_published":"2021-02-18T22:44:22+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E5%8D%92%E6%A5%AD%E8%AB%96%E6%96%87%E3%81%AE%E7%99%BA%E8%A1%A8%E3%82%92%E7%B5%82%E3%81%88%E3%81%9F%E3%80%82%E8%BF%91%E6%B3%81%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae46e542337c24910143add3bcb03ea0f8836dcc","comment":"Add a post of dialy\n","date_modified":"2021-02-19T00:29:08+09:00"}],"content_html":"<p>先週に卒業論文を提出し、今日その内容を学科内で発表した。\n無事合格できた旨のメールを先ほど受け取って、これで大学4年間の全ての単位を取得できる見込みになった。</p>\n<p style=\"padding-bottom: 50px\">\n大学生活は案外早く過ぎ去ったなと思いつつ、こういうのは終わってみればたいてい早く感じるものだろう。\n今の自分は大した技術力があるわけでもないし、大学4年間で大したことを身につけられた気がしないと少し前まで思っていたけれど、振り返ると4年前の自分は今よりも果てしなく無知だったことに気づくので、大学に入ってこの専攻を選んでよかった。\n</p>\n<p>最近は論文執筆に勤しんでいた。\n新年の意気込みで早寝早起きと言っておきながら最近はだいぶ夜ふかしをしていたし、本を読む目標もあまり進んでいない。\n少し読んだ本もあるが、そんな時間があるなら論文を書きましょうという感じだった。</p>\n<p style=\"padding-bottom: 50px\">\n卒業研究にあたってそこそこ論文などを読んだ。\n論文を読む機会なんて正直いままで殆ど無かったし、長い仕様書をじっくり読むみたいなのもそんなにしてこなかったので、卒業研究はそういった意味で新しいことを体験する機会だった。\n世の研究者と比べたら大したことを出来た訳ではないだろうけれど、右も左もわからないながらも、一応高等教育の最後として自分の考えをしたためた文章を書ききったことに達成感を感じている。\n</p>\n<p style=\"padding-bottom: 50px\">\nところで私は昔、理系大学生の醍醐味といえば研究室生活だろうみたいな想像をしていた。\nそういうのを心のどこか楽しみにしていたが、私の研究室はコアタイムがあるわけでもないし、新型コロナウィルスの影響で研究室には最初の1,2回しか行く機会がなかった。\n実家で一日中コンピュータを触っているのは実に快適でよいのだけれど。\nそういえば弊研究室に所属したら SINET から出れる IPv4 の固定アドレスを自由に使える権利があったのだけど、研究室内にコンピュータをセットアップすることもないまま卒業することになるので実質この権利を放棄してしまった。\n無理してでも文字通り研究室に入ってラズパイの1台でも置いてくればよかったな。\n一抹の後悔。\n</p>\n<p>というわけで駄文でした。</p>\n<p>研究が終わったらやりたいことがいくつか溜まっていたので順番に消化していきたい。\n気分症なのでいくつか既に昇華してしまったものもあるが、まあよいだろう。\n生活リズムも戻します。\nブログもまた書いていきます、今までは文章を書く時間が全て論文に奪われていたので... (これは言い訳)</p>\n<p>最後に先週公開され、卒論準備を後押ししてくれた BUMP OF CHICKEN の新曲、Flare の MV を置いてこの文章を終えます。\nおやすみなさい。</p>\n<div style=\"text-align: center\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pDFkg9L5wJY\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n","content_text":"先週に卒業論文を提出し、今日その内容を学科内で発表した。\n無事合格できた旨のメールを先ほど受け取って、これで大学4年間の全ての単位を取得できる見込みになった。\n\n\n\n最近は論文執筆に勤しんでいた。\n新年の意気込みで早寝早起きと言っておきながら最近はだいぶ夜ふかしをしていたし、本を読む目標もあまり進んでいない。\n少し読んだ本もあるが、そんな時間があるなら論文を書きましょうという感じだった。\n\n\n\nというわけで駄文でした。\n\n研究が終わったらやりたいことがいくつか溜まっていたので順番に消化していきたい。\n気分症なのでいくつか既に昇華してしまったものもあるが、まあよいだろう。\n生活リズムも戻します。\nブログもまた書いていきます、今までは文章を書く時間が全て論文に奪われていたので... (これは言い訳)\n\n最後に先週公開され、卒論準備を後押ししてくれた BUMP OF CHICKEN の新曲、Flare の MV を置いてこの文章を終えます。\nおやすみなさい。\n\n"},{"id":"http://localhost:3000/posts/clip-path","url":"http://localhost:3000/posts/clip-path","title":"ベジェ曲線で画像を丸っぽくくり抜く (CSS clip-path)","summary":" HTML で上記のように記述すると下記のように丸っぽく画像をくり抜ける 参考 clip-path - CSS: Cascading Style Sheets | MDN Paths - SVG: Scalable Vector Graphics | MDN ","date_published":"2021-01-27T11:43:00+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%99%E3%82%B8%E3%82%A7%E6%9B%B2%E7%B7%9A%E3%81%A7%E7%94%BB%E5%83%8F%E3%82%92%E4%B8%B8%E3%81%A3%E3%81%BD%E3%81%8F%E3%81%8F%E3%82%8A%E6%8A%9C%E3%81%8F%20(CSS%20clip-path),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b96dfb40fab9e61a5c1bfeadd03e67a872a944f9","comment":"Add post\n","date_modified":"2021-01-27T11:49:42+09:00"}],"content_html":"<pre><code class=\"hljs language-html\">  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">img</span>\n    <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://blob.yammer.jp/gather_fishes.jpg\"</span>\n    <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"clip-path:url(#bezier-curve-circle); width:300px;\"</span>\n  /></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">svg</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"bezier-curve-circle\"</span> <span class=\"hljs-attr\">clipPathUnits</span>=<span class=\"hljs-string\">\"objectBoundingBox\"</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"\n      M 0 0.5\n      C 0 0.166, 0.166 0, 0.5 0\n      S 1 0.166, 1 0.5\n      S 0.833 1, 0.5 1\n      S 0, 0.833, 0, 0.5\n      Z\n    \"</span>/></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">clipPath</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">svg</span>></span></code></pre>\n<p>HTML で上記のように記述すると下記のように丸っぽく画像をくり抜ける</p>\n<hr>\n<p><img\n src=\"https://blob.yammer.jp/gather_fishes.jpg\"\n style=\"clip-path:url(#bezier-curve-circle); width:300px;\"\n/>\n<svg>\n<clipPath id=\"bezier-curve-circle\" clipPathUnits=\"objectBoundingBox\">\n<path d=\"\n   M 0 0.5\n   C 0 0.166, 0.166 0, 0.5 0\n   S 1 0.166, 1 0.5\n   S 0.833 1, 0.5 1\n   S 0, 0.833, 0, 0.5\n   Z\n \"/>\n</clipPath>\n</svg></p>\n<hr>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path\">clip-path - CSS: Cascading Style Sheets | MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/SVG/Tutorial/Paths\">Paths - SVG: Scalable Vector Graphics | MDN</a></li>\n</ul>\n","content_text":"\n\nHTML で上記のように記述すると下記のように丸っぽく画像をくり抜ける\n\n\n\n\n\n\n\n\n\n\n\n\n参考\n\nclip-path - CSS: Cascading Style Sheets | MDN\n\nPaths - SVG: Scalable Vector Graphics | MDN\n"},{"id":"http://localhost:3000/posts/planck-keyboard","url":"http://localhost:3000/posts/planck-keyboard","title":"Planck Keyboard を手に入れた","summary":"先月に申し込んだ Planck Keyboard が届いたので組み立てた。 planck keyboard Planck Keyboard とは Drop + OLKB Planck Mechanical Keyboard Kit V6 | Drop いわゆる 40%[^1] と言われる分類で格子配列[^2] のキーボードキット。 キー数が少なく(4x12個) コンパクトなキーボードである。 スイッチを取り付ける基盤である PCB と PCB に装着するケースのセットで販売されていて、アメリカの共同購入サイト Drop (Massdrop, Inc.) で購入できる。 いつでも買うことが出来る","date_published":"2021-01-09T15:07:39+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Planck%20Keyboard%20%E3%82%92%E6%89%8B%E3%81%AB%E5%85%A5%E3%82%8C%E3%81%9F,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["自作キーボード"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b2276e908080e7b533c5c7068bce7a66ce1fe9be","comment":"Add a post 'planck keyboard'\n","date_modified":"2021-01-09T17:48:47+09:00"}],"content_html":"<p>先月に申し込んだ Planck Keyboard が届いたので組み立てた。</p>\n<p><img src=\"https://blob.yammer.jp/planck-keyboard.jpg\" alt=\"planck keyboard\"></p>\n<h2>Planck Keyboard とは</h2>\n<p><a href=\"https://drop.com/buy/planck-mechanical-keyboard\">Drop + OLKB Planck Mechanical Keyboard Kit V6 | Drop</a></p>\n<p>いわゆる 40%<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> と言われる分類で格子配列<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> のキーボードキット。\nキー数が少なく(4x12個) コンパクトなキーボードである。</p>\n<p>スイッチを取り付ける基盤である PCB と PCB に装着するケースのセットで販売されていて、アメリカの共同購入サイト <a href=\"https://drop.com/home\">Drop (Massdrop, Inc.)</a> で購入できる。\nいつでも買うことが出来るわけではなく購入希望者が集まってからまとめて生産されるようで、しばらく前から様子を見ており12月に購入できると知って注文した。</p>\n<p>もともとは薄型の <a href=\"https://drop.com/buy/massdrop-x-olkb-planck-light-mechanical-keyboard\">Planck Light Keyboard</a> が欲しかったのだが、40%で格子配列のキーボードが買えるなら通常の Planck Keyboard でもいいかと妥協した。\n(結果満足している)</p>\n<p>現在販売されている v6 では、 ケースを 周りの高さが低い Mid-Pro と 高い High-Pro から選べる。\n加えてケースの色も選べる。\n自分は Mid-Pro の スペースグレーを選んだ。</p>\n<h2>買ったもの</h2>\n<p>キットにはキースイッチとキーキャップが付属しないので別途購入した。</p>\n<p><img src=\"https://blob.yammer.jp/planck-keyboard-and-parts.jpg\" alt=\"購入したもの\"></p>\n<p>今回購入したものは以下。</p>\n<table>\n<thead>\n<tr>\n<th>商品名</th>\n<th>個数</th>\n<th align=\"right\">単価(円)</th>\n<th align=\"right\">小計(円)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://www.amazon.co.jp/gp/product/B081QL9QF3/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&#x26;psc=1\">USB Type-Cホストケーブル C - C 両端L型 10cm U20CC-LL01T AINEX Amazon</a></td>\n<td>1</td>\n<td align=\"right\">792</td>\n<td align=\"right\">792</td>\n</tr>\n<tr>\n<td><a href=\"https://drop.com/buy/planck-mechanical-keyboard\">Planck Keyboard V6 (Mid-Pro, SpaceGlay)</a> (送料込)</td>\n<td>1</td>\n<td align=\"right\">$108</td>\n<td align=\"right\">11754</td>\n</tr>\n<tr>\n<td><a href=\"https://talpkeyboard.stores.jp/items/5e05d3a85b120c2ad04ccf99\">XDA PBT ブランク キーキャップ (クリーム/2個)</a></td>\n<td>16</td>\n<td align=\"right\">110</td>\n<td align=\"right\">1760</td>\n</tr>\n<tr>\n<td><a href=\"https://talpkeyboard.stores.jp/items/5d6e2e4f8606480675a98c5f\">XDA PBT ブランク キーキャップ (アップルグリーン/2個)</a></td>\n<td>4</td>\n<td align=\"right\">110</td>\n<td align=\"right\">440</td>\n</tr>\n<tr>\n<td><a href=\"https://talpkeyboard.stores.jp/items/5b6e593d5f78663893000482\">XDA PBT ブランク キーキャップ (グレー/2個)</a></td>\n<td>7</td>\n<td align=\"right\">110</td>\n<td align=\"right\">770</td>\n</tr>\n<tr>\n<td><a href=\"https://talpkeyboard.stores.jp/items/59be1a4ab1b61963180007c6\">Gateron キースイッチ Brown (トップクリア/5ピン/55g/タクタイル/10個)</a></td>\n<td>5</td>\n<td align=\"right\">450</td>\n<td align=\"right\">2250</td>\n</tr>\n<tr>\n<td>TALP KEYBOARD キースイッチ 5個以上購入で5%オフ</td>\n<td></td>\n<td align=\"right\"></td>\n<td align=\"right\">-110</td>\n</tr>\n<tr>\n<td>TALP KEYBOARD 送料</td>\n<td></td>\n<td align=\"right\"></td>\n<td align=\"right\">300</td>\n</tr>\n<tr>\n<td><strong>合計</strong></td>\n<td></td>\n<td align=\"right\"></td>\n<td align=\"right\">17956</td>\n</tr>\n</tbody>\n</table>\n<h2>組み立て</h2>\n<p>Planck Keyboard V6 は, ホットスワップ用のソケットが PCB にはんだ付けされた状態で届くので、組立時に自分ではんだ付けする必要はない。\nドライバーでネジを回し、スイッチをはめ込むだけで作れる。</p>\n<p>作り方は公式動画で説明されている。</p>\n<div style=\"text-align: center;\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KAZglmhVuYg\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n<p>PCB にはデフォルトでキーマップが書き込まれているが、<a href=\"https://github.com/qmk/qmk_firmware\">qmk/qmk_firmware</a>を利用して独自のキーマップを書き込むことも出来る。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># Ubuntu 20.04</span>\n\n<span class=\"hljs-comment\"># インストール</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/qmk/qmk_firmware.git\n<span class=\"hljs-built_in\">cd</span> qmk_firmware\nmake git-submodule\n./util/qmk_install.sh\n\n<span class=\"hljs-comment\"># デフォルトのキーマップを書き込み</span>\n<span class=\"hljs-comment\"># Planck Keyboard をコンピュータにUSB接続</span>\nsudo make planck/rev6:default:dfu-util\n<span class=\"hljs-comment\"># キーボード背面のリセットスイッチを押す</span>\n<span class=\"hljs-comment\"># 書き込みが終わるまで待つ</span>\n\n<span class=\"hljs-comment\"># 好みのキーマップを書き込み</span>\ncp -r keyboards/planck/keymaps/default keyboards/planck/keymaps/mykeymap\nvim keyboard/planck/keymaps/mykeymap/keymap.c    <span class=\"hljs-comment\"># キーマップを好みに変更</span>\n<span class=\"hljs-comment\"># Planck KeyboardをコンピュータにUSB接続</span>\nsudo make planck/rev6:mykeymap:dfu-util\n<span class=\"hljs-comment\"># キーボード背面のリセットスイッチを押す</span>\n<span class=\"hljs-comment\"># 書き込みが終わるまで待つ</span></code></pre>\n<p>買ったキースイッチは無刻印でホームポジションの印がないので、かわりに家にあった透明なシールを穴あけパンチでくり抜いて貼り付けている。</p>\n<h2>感想</h2>\n<p>Planck Keyboard は組み立ても簡単で、作りもしっかりしている。\n剛性感があるのでキーをタイプしても安定しているので安心感がある。</p>\n<p>アルミケースの質感もいい感じ。\n事前の写真ではテカテカして安っぽい感じに見えていたのだが、実物はアルミの目が細かくて思っていたより落ち着いた風合いだった。</p>\n<p>一緒に <a href=\"https://talpkeyboard.stores.jp\">TALP KEYBOARD</a> で買ったキーキャップの質感と色味も絶妙で、やさしい見た目になった。</p>\n<p>キースイッチに選んだ Gateron 茶軸の押し心地もとても良い。\nスイッチを押すとストンと素直に下まで落ちてくれるし、別のキーボードに使っている Kailh ロープロファイル<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>のスイッチに比べてに比べて深く沈み込むのも良い。\nいままでは薄型の Kailh Choc のほうが自分に合っているかなと思っていたけど、今回 Cherry MX 互換<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>のキースイッチを使ってみて、すでに持っているキーボードもキースイッチを変えたくなってきた。</p>\n<p>尊師スタイル<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>で使うために、短い USB ケーブルも合わせて買った。\nPlanck Keyboard にはキーボード裏に貼る滑り止めの足が付属するが、これを貼らずに裏面が平らなまま Mac の 内蔵キーボード上に載せると、載せた上の Planck Keyboard をタイプしても内蔵キーボードは反応しないで使える。</p>\n<p>前年に <a href=\"https://memo.yammer.jp/posts/lily58-pro-build-log/\">Lily58 というキーボードを作って</a>からというもの、row-staggered<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup> なキーボードに違和感を感じるようになって、持ち運びのしやすい格子配列のキーボードを欲していた。\nPlanck Keyboard を手に入れたおかげで気軽にこたつにキーボードを持ち込むことが出来て、こたつ PC 時間が捗りそう。</p>\n<p><img src=\"https://blob.yammer.jp/planck-on-macbook.jpg\" alt=\"Macの上に置いたPlanck Keyboard\"></p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://olkb.com/collections/planck\">The Planck Keyboard – OLKB</a></li>\n<li><a href=\"https://github.com/qmk/qmk_firmware/blob/master/keyboards/planck/readme.md\">qmk_firmware/readme.md at master · qmk/qmk_firmware</a></li>\n<li><a href=\"https://leopardgecko.hatenablog.com/entry/2017/09/13/234549\">PlanckキーボードをMacでカスタマイズしてみよう。　＜導入編＞ - leopardgeckoのブログ</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">一般的なキーボードのキー数に対する割合が40% (40-50個ほど) のキーボードのこと。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">列ごと、行ごとにキー配置が揃っているキーボードの配列。othroliner ともいう。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">自作キーボードに使われる薄型のキースイッチの規格。スイッチを押したときに沈み込む深さであるキーストロークは3mm。<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">自作キーボードに使われる最も一般的なキースイッチの規格。キーストロークは4mmが一般的。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\">ノートパソコンの内蔵キーボードの上に外付けキーボードを置く方式。<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\">行ごとにキー配置が横にずれている、一般的なキーボードの配列。<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"先月に申し込んだ Planck Keyboard が届いたので組み立てた。\n\nplanck keyboard\n\nPlanck Keyboard とは\n\nDrop + OLKB Planck Mechanical Keyboard Kit V6 | Drop\n\nいわゆる 40%[^1] と言われる分類で格子配列[^2] のキーボードキット。\nキー数が少なく(4x12個) コンパクトなキーボードである。\n\nスイッチを取り付ける基盤である PCB と PCB に装着するケースのセットで販売されていて、アメリカの共同購入サイト Drop (Massdrop, Inc.) で購入できる。\nいつでも買うことが出来るわけではなく購入希望者が集まってからまとめて生産されるようで、しばらく前から様子を見ており12月に購入できると知って注文した。\n\nもともとは薄型の Planck Light Keyboard が欲しかったのだが、40%で格子配列のキーボードが買えるなら通常の Planck Keyboard でもいいかと妥協した。\n(結果満足している)\n\n現在販売されている v6 では、 ケースを 周りの高さが低い Mid-Pro と 高い High-Pro から選べる。\n加えてケースの色も選べる。\n自分は Mid-Pro の スペースグレーを選んだ。\n\n買ったもの\n\nキットにはキースイッチとキーキャップが付属しないので別途購入した。\n\n購入したもの\n\n今回購入したものは以下。\n\n\n\n組み立て\n\nPlanck Keyboard V6 は, ホットスワップ用のソケットが PCB にはんだ付けされた状態で届くので、組立時に自分ではんだ付けする必要はない。\nドライバーでネジを回し、スイッチをはめ込むだけで作れる。\n\n作り方は公式動画で説明されている。\n\n\n\nPCB にはデフォルトでキーマップが書き込まれているが、qmk/qmk_firmwareを利用して独自のキーマップを書き込むことも出来る。\n\n\n\n買ったキースイッチは無刻印でホームポジションの印がないので、かわりに家にあった透明なシールを穴あけパンチでくり抜いて貼り付けている。\n\n感想\n\nPlanck Keyboard は組み立ても簡単で、作りもしっかりしている。\n剛性感があるのでキーをタイプしても安定しているので安心感がある。\n\nアルミケースの質感もいい感じ。\n事前の写真ではテカテカして安っぽい感じに見えていたのだが、実物はアルミの目が細かくて思っていたより落ち着いた風合いだった。\n\n一緒に TALP KEYBOARD で買ったキーキャップの質感と色味も絶妙で、やさしい見た目になった。\n\nキースイッチに選んだ Gateron 茶軸の押し心地もとても良い。\nスイッチを押すとストンと素直に下まで落ちてくれるし、別のキーボードに使っている Kailh ロープロファイル[^3]のスイッチに比べてに比べて深く沈み込むのも良い。\nいままでは薄型の Kailh Choc のほうが自分に合っているかなと思っていたけど、今回 Cherry MX 互換[^4]のキースイッチを使ってみて、すでに持っているキーボードもキースイッチを変えたくなってきた。\n\n尊師スタイル[^5]で使うために、短い USB ケーブルも合わせて買った。\nPlanck Keyboard にはキーボード裏に貼る滑り止めの足が付属するが、これを貼らずに裏面が平らなまま Mac の 内蔵キーボード上に載せると、載せた上の Planck Keyboard をタイプしても内蔵キーボードは反応しないで使える。\n\n前年に Lily58 というキーボードを作ってからというもの、row-staggered[^6] なキーボードに違和感を感じるようになって、持ち運びのしやすい格子配列のキーボードを欲していた。\nPlanck Keyboard を手に入れたおかげで気軽にこたつにキーボードを持ち込むことが出来て、こたつ PC 時間が捗りそう。\n\nMacの上に置いたPlanck Keyboard\n\n参考\n\nThe Planck Keyboard – OLKB\n\nqmk_firmware/readme.md at master · qmk/qmk_firmware\n\nPlanckキーボードをMacでカスタマイズしてみよう。　＜導入編＞ - leopardgeckoのブログ\n\n[^1]: 一般的なキーボードのキー数に対する割合が40% (40-50個ほど) のキーボードのこと。\n\n[^2]: 列ごと、行ごとにキー配置が揃っているキーボードの配列。othroliner ともいう。\n\n[^3]: 自作キーボードに使われる薄型のキースイッチの規格。スイッチを押したときに沈み込む深さであるキーストロークは3mm。\n\n[^4]: 自作キーボードに使われる最も一般的なキースイッチの規格。キーストロークは4mmが一般的。\n\n[^5]: ノートパソコンの内蔵キーボードの上に外付けキーボードを置く方式。\n\n[^6]: 行ごとにキー配置が横にずれている、一般的なキーボードの配列。\n"},{"id":"http://localhost:3000/posts/2021-target","url":"http://localhost:3000/posts/2021-target","title":"2021年の目標「早寝早起き、本を読む」","summary":"今年の目標は「早寝早起き、本を読む」とする。 生活リズムの改善 目標の前半部分「早寝早起き」について。 2020年は大学の講義中心の生活から研究中心の生活に移り、殆ど自宅で過ごしたこともあって夜型の生活が続いた。 寝るのが惜しくて夜ふかしをして、起きるのが遅くなることで更に眠くなる時間が遅くなり、、という悪循環から朝4時頃に寝て昼頃に起きるのが常態化していた。(もっと遅いことも多々) これに対し、今年から社会人になるのでこのままでは良くないと思い12月中頃から生活リズムを改善する試みが始まった。 22歳になって「早寝早起き」という小学生みたいな目標を立てているが、今まで生活リズムを制御すること","date_published":"2021-01-02T16:08:22+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:2021%E5%B9%B4%E3%81%AE%E7%9B%AE%E6%A8%99%E3%80%8C%E6%97%A9%E5%AF%9D%E6%97%A9%E8%B5%B7%E3%81%8D%E3%80%81%E6%9C%AC%E3%82%92%E8%AA%AD%E3%82%80%E3%80%8D,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/51bcc87674bd42aa8081e9c724495506f98014d2","comment":"Publish a post '2021-target'\n","date_modified":"2021-01-05T19:47:58+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/53ac1b7ab93a76d8785db918f296b7820ba59cf6","comment":"Add a post '2021-target'\n","date_modified":"2021-01-02T22:50:46+09:00"}],"content_html":"<p>今年の目標は「早寝早起き、本を読む」とする。</p>\n<h2>生活リズムの改善</h2>\n<p>目標の前半部分「早寝早起き」について。</p>\n<p>2020年は大学の講義中心の生活から研究中心の生活に移り、殆ど自宅で過ごしたこともあって夜型の生活が続いた。\n寝るのが惜しくて夜ふかしをして、起きるのが遅くなることで更に眠くなる時間が遅くなり、、という悪循環から朝4時頃に寝て昼頃に起きるのが常態化していた。(もっと遅いことも多々)</p>\n<p>これに対し、今年から社会人になるのでこのままでは良くないと思い12月中頃から生活リズムを改善する試みが始まった。\n22歳になって「早寝早起き」という小学生みたいな目標を立てているが、今まで生活リズムを制御することは自分にとって結構な難題であった。</p>\n<p>振り返れば昔から朝に弱く学校に遅刻したりしていたし、中高の部活を選ぶときの最優先条件は朝練がないことだった。\n記憶に残っている出来事として、中学3年の登校初日に寝坊し、急いで学校に行くと頭に寝癖がついたままだったため、これが元ネタでそのまま学級目標が「Neguse」になったことがある。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>高校になっても朝が不安で、修学旅行前夜には家中の目覚まし時計をかき集めてベッドの周りに包囲陣を形成していたし、大学のサークル仲間と旅行に行くと「大音量の目覚ましを沢山設定するくせに一人だけ起きないから煩くて迷惑」との声を頂いた。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>そんな人間でも、最近は一応毎日同じくらいの時間に就寝と起床が出来ている。\n日付が変わる前に寝て7時半に起きることにしていて、3週間くらいは概ね継続できたことになる。\n2020年はこれを続けることを目標の一つとする。</p>\n<h2>早起きのコツ</h2>\n<p>一定の生活リズムを継続できている要素には次の2つがあると考えられる。</p>\n<ul>\n<li>早く寝る</li>\n</ul>\n<p>生活リズムを一定に保つためには、同じ時間に起きることよりも同じ時間に寝ることを心がけることのほうが大切だと気づいた。\n寝ているときに目覚ましに気づくかどうかは自らの意思でないが (意識がないから。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>)、一方で寝る時間は自らの意思で決められる。</p>\n<p>どうも夜のほうが作業が捗るような気が夜ふかしをしがちだったが、その日やることが残っているかどうかを無視して予定の時間になったら寝る<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup> ことで、同じ時間に起きれるようになった。\n夜のほうが作業が捗るのも多分気のせいで、早い時間に起きれば夜でなくても集中できる。</p>\n<ul>\n<li>起床後がんばらない</li>\n</ul>\n<p>今までの数々の(早起きチャレンジ)失敗の原因は、朝の時間を有効に活用しようとしたことにあった。\n早起きして何かをやろうと自分に課していたのが問題だった。\n布団は暖かいしこの時期は特に出たくなくなる。\n起きてすぐやらねばならぬタスクがあるのは気が重いし「嫌だなあ」と考えてるうちに2度寝するのがオチだ。</p>\n<p>そこで朝に何かを課すのをやめた。「目が覚めたら良し」とすることで気が楽になる。\nついでに「起きたら2度寝しないようにベッドからすぐに出る」ことも課さない。\n起きたら目が冴えるまではスマホで Twitter や動画でも見ながらぬくぬくして、程よい頃合いでベッドから出れば良いとする。</p>\n<p>これくらいの温度感でとにかく寝ることと目が覚めたらまずは良しとすることだけを自分に課すことで今後も継続しようと試みている。</p>\n<h2>粗読と精読の使い分け</h2>\n<p>目標の後半部分「本を読む」について。</p>\n<p>昨年末の記事 (<a href=\"/posts/2020-github-repositories/\">自分のGitHubリポジトリで振り返る2020年</a>) にあるように、またこのブログの記事を書くなども含めて2020年は継続してアウトプットに取り組んだのに対し、インプットが弱かったと感じる。</p>\n<p>そこで本年はアウトプットについては継続しつつ<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>、本を読むことでインプットを増やしたい。\n手始めにソフトウェア開発に関わる本の積読を減らすため<a href=\"/posts/readable-code/\">リーダブルコードに手を付けた</a>。</p>\n<p>本を読むにあたっては、精読と粗読の使い分けを心がけようと思う。\n以前の記事 (<a href=\"/posts/webteckbook/\">積読本だった\"Webを支える技術\"を読んだ感想と、本を読むための心がけ</a>) でも書いたが、精読ではなくまずは最後まで読み切り、何かあったら当該の本を読み直せばよい、といった読み方を意識する。</p>\n<p>そうでもないと永遠に積読が減らない。</p>\n<p>1冊の本から得られるものを最大化するより、学習時間あたりの得られるものを最大化すべきで、このためには最初に精読するよりも粗読と振り返りの精読のほうが大切だろうと思っている。</p>\n<h2>まとめ</h2>\n<p>家族に「年始に目標をたてても年末には忘れてるんだよね」と言われたので、忘れないようにそして心がけられるように宣言しておこうと思い記事を書くに至った。</p>\n<p>「早寝早起き、本を読む」やっていきたい。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">頭についた寝癖のように各々の個性を発揮するみたいな意味付けだったと思う。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">ここまで全て実話。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">これは<a target=\"_blank\" href=\"https://twitter.com/hirox246\">ひろゆき</a>氏の受け売りで、よく寝坊を回避するのは不可能である理由の説明に使われる。<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">そうはいってもついつい夜ふかししがちなのでこの点は強い心が必要。あと風呂に入る時間を早めることも大切。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\">アウトプットするコードと文章の質については高めていきたい。<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"今年の目標は「早寝早起き、本を読む」とする。\n\n生活リズムの改善\n\n目標の前半部分「早寝早起き」について。\n\n2020年は大学の講義中心の生活から研究中心の生活に移り、殆ど自宅で過ごしたこともあって夜型の生活が続いた。\n寝るのが惜しくて夜ふかしをして、起きるのが遅くなることで更に眠くなる時間が遅くなり、、という悪循環から朝4時頃に寝て昼頃に起きるのが常態化していた。(もっと遅いことも多々)\n\nこれに対し、今年から社会人になるのでこのままでは良くないと思い12月中頃から生活リズムを改善する試みが始まった。\n22歳になって「早寝早起き」という小学生みたいな目標を立てているが、今まで生活リズムを制御することは自分にとって結構な難題であった。\n\n振り返れば昔から朝に弱く学校に遅刻したりしていたし、中高の部活を選ぶときの最優先条件は朝練がないことだった。\n記憶に残っている出来事として、中学3年の登校初日に寝坊し、急いで学校に行くと頭に寝癖がついたままだったため、これが元ネタでそのまま学級目標が「Neguse」になったことがある。[^1]\n\n高校になっても朝が不安で、修学旅行前夜には家中の目覚まし時計をかき集めてベッドの周りに包囲陣を形成していたし、大学のサークル仲間と旅行に行くと「大音量の目覚ましを沢山設定するくせに一人だけ起きないから煩くて迷惑」との声を頂いた。[^2]\n\nそんな人間でも、最近は一応毎日同じくらいの時間に就寝と起床が出来ている。\n日付が変わる前に寝て7時半に起きることにしていて、3週間くらいは概ね継続できたことになる。\n2020年はこれを続けることを目標の一つとする。\n\n早起きのコツ\n\n一定の生活リズムを継続できている要素には次の2つがあると考えられる。\n\n早く寝る\n\n生活リズムを一定に保つためには、同じ時間に起きることよりも同じ時間に寝ることを心がけることのほうが大切だと気づいた。\n寝ているときに目覚ましに気づくかどうかは自らの意思でないが (意識がないから。[^3])、一方で寝る時間は自らの意思で決められる。\n\nどうも夜のほうが作業が捗るような気が夜ふかしをしがちだったが、その日やることが残っているかどうかを無視して予定の時間になったら寝る[^4] ことで、同じ時間に起きれるようになった。\n夜のほうが作業が捗るのも多分気のせいで、早い時間に起きれば夜でなくても集中できる。\n\n起床後がんばらない\n\n今までの数々の(早起きチャレンジ)失敗の原因は、朝の時間を有効に活用しようとしたことにあった。\n早起きして何かをやろうと自分に課していたのが問題だった。\n布団は暖かいしこの時期は特に出たくなくなる。\n起きてすぐやらねばならぬタスクがあるのは気が重いし「嫌だなあ」と考えてるうちに2度寝するのがオチだ。\n\nそこで朝に何かを課すのをやめた。「目が覚めたら良し」とすることで気が楽になる。\nついでに「起きたら2度寝しないようにベッドからすぐに出る」ことも課さない。\n起きたら目が冴えるまではスマホで Twitter や動画でも見ながらぬくぬくして、程よい頃合いでベッドから出れば良いとする。\n\nこれくらいの温度感でとにかく寝ることと目が覚めたらまずは良しとすることだけを自分に課すことで今後も継続しようと試みている。\n\n粗読と精読の使い分け\n\n目標の後半部分「本を読む」について。\n\n昨年末の記事 (自分のGitHubリポジトリで振り返る2020年) にあるように、またこのブログの記事を書くなども含めて2020年は継続してアウトプットに取り組んだのに対し、インプットが弱かったと感じる。\n\nそこで本年はアウトプットについては継続しつつ[^5]、本を読むことでインプットを増やしたい。\n手始めにソフトウェア開発に関わる本の積読を減らすためリーダブルコードに手を付けた。\n\n本を読むにあたっては、精読と粗読の使い分けを心がけようと思う。\n以前の記事 (積読本だった\"Webを支える技術\"を読んだ感想と、本を読むための心がけ) でも書いたが、精読ではなくまずは最後まで読み切り、何かあったら当該の本を読み直せばよい、といった読み方を意識する。\n\nそうでもないと永遠に積読が減らない。\n\n1冊の本から得られるものを最大化するより、学習時間あたりの得られるものを最大化すべきで、このためには最初に精読するよりも粗読と振り返りの精読のほうが大切だろうと思っている。\n\nまとめ\n\n家族に「年始に目標をたてても年末には忘れてるんだよね」と言われたので、忘れないようにそして心がけられるように宣言しておこうと思い記事を書くに至った。\n\n「早寝早起き、本を読む」やっていきたい。\n\n[^1]: 頭についた寝癖のように各々の個性を発揮するみたいな意味付けだったと思う。\n\n[^2]: ここまで全て実話。\n\n[^3]: これはひろゆき氏の受け売りで、よく寝坊を回避するのは不可能である理由の説明に使われる。\n\n[^4]: そうはいってもついつい夜ふかししがちなのでこの点は強い心が必要。あと風呂に入る時間を早めることも大切。\n\n[^5]: アウトプットするコードと文章の質については高めていきたい。\n"},{"id":"http://localhost:3000/posts/readable-code","url":"http://localhost:3000/posts/readable-code","title":"リーダブルコードを読んだ感想","summary":"2021年最初の読書はリーダブルコード。 今年は本をたくさん読みたいので景気づけも兼ねて元日のうちに読み始め、今日の午前に読み終えたので感想を綴る。 本の概要 リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice) | Dustin Boswell, Trevor Foucher, 須藤 功平, 角 征典 |本 | 通販 | Amazon プログラマーに向けた、読みやすいコードを書くためのバイブルといわれることもある本である。 表紙が楽譜のデザインであり、ソフトウェアにおける「コード」と音楽における「コード」(音楽符号) をかけてい","date_published":"2021-01-02T15:49:50+09:00","date_modified":"2021-05-05T19:47:55+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0%E6%84%9F%E6%83%B3,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1741da28aa87b809153d2c6799f500b28fc236a8","comment":"注釈内の改行を削除してremark-footnoteで正しく変換されるよう修正\n","date_modified":"2021-05-05T19:47:55+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b26bea9028efab6990f69ef0f8877fedaee9cf35","comment":"Add a post 'readable-code'\n","date_modified":"2021-01-02T22:03:39+09:00"}],"content_html":"<p>2021年最初の読書はリーダブルコード。\n今年は本をたくさん読みたいので景気づけも兼ねて元日のうちに読み始め、今日の午前に読み終えたので感想を綴る。</p>\n<h2>本の概要</h2>\n<p><a href=\"https://www.amazon.co.jp/dp/4873115655/ref=cm_sw_r_cp_ep_dp_K21dCbS19WG0N\">リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice) | Dustin Boswell, Trevor Foucher, 須藤 功平, 角 征典 |本 | 通販 | Amazon</a></p>\n<p>プログラマーに向けた、読みやすいコードを書くためのバイブルといわれることもある本である。\n表紙が楽譜のデザインであり、ソフトウェアにおける「コード」と音楽における「コード」(音楽符号) をかけているのがポイント。</p>\n<p>プログラムを書く人間なら読むべき、としばらく前に教えていただいたが積読されていた本である。\n英語版は無料で PDF が手に入る。\n日本語訳版は3000円くらいだが有名な本なので図書館とかに割と置いてありそう。\n(弊学にはあった。)</p>\n<h2>感想</h2>\n<p>本書は良いコードを書くための方法を具体的に説明しており、そのまま実践できそうな内容が詰め込まれている。</p>\n<p>しかしながら沢山のテクニックが示されておりその個々を読みながら納得することは出来ても、今の時点では自らの血肉となった気がしない。\n実際にコードを書くときに書かれた内容全てを実現することはすぐには出来ないだろう。\n定期的に見直して意識を続けるほかない。</p>\n<p>幸いにも各章のさいごに「まとめ」が付いており、これがとても良くできている。\nまとめをインデックスとしてまずは迷ったときに本書に戻れるようにしておきたい。</p>\n<p>特に5章, 6章のコメントに関する言及は興味深かった。\n本書では、よく言われる言葉「コメントには WHAT ではなく (あるいは HOW ではなく) ではなく WHY を書こう」ではなく「コードの理解するのに役立つものなら何でも良いから書こう」と説明されていた。</p>\n<p>私は以前はコメントを沢山書いていた。\n命名については深く考えておらず、ソースコード内に日本語で説明できる部分があるなら助かると思っていたからだ。\nしばらくして Git を学び、命名の大切さを知り、以前コメントに書いていたようなことは命名で表現できるのではないかと思うようになった。\nさらに無駄なコメントは悪である<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>という考えを知った。</p>\n<p>これらは勿論大切なことではあるが、必要以上にコメントを忌み嫌ってほとんど書かなくなったように思う。\n自分の書いたプログラムをあとから変更しようとするときにコードを理解する負担が増えたような気がして気づいた。</p>\n<p>こういった曲がった考えを直して正しいスタンスを説明してくれているのが本書だと感じた。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>\nコメントをどのように書くか悩んだときは、5章4説にある「とにかく書き始める」が有効だろう。\nまず頭で思ったことをそのまま書き出してから細かく改善することで良いコメントを作ることを勧めている。</p>\n<p>こういった一つ一つの事柄をコツコツ実践していきたい。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">コードを読んですぐに分かるようなことをコメントに書くのは良くない。画面を専有する、コードを書き換えるときに一緒に書き換えなければならず負担になる、書換えを忘れてコードの内容とコメントの内容が乖離していたら読み手は混乱する、などの理由から。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">そもそも無駄なコメントは必要ないと指摘してくださった方は同時にあわせて「リーダブルコードを読んだほうが良い」と仰っていた。 それを積読のまま消化しなかった自分が悪い。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"2021年最初の読書はリーダブルコード。\n今年は本をたくさん読みたいので景気づけも兼ねて元日のうちに読み始め、今日の午前に読み終えたので感想を綴る。\n\n本の概要\n\nリーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice) | Dustin Boswell, Trevor Foucher, 須藤 功平, 角 征典 |本 | 通販 | Amazon\n\nプログラマーに向けた、読みやすいコードを書くためのバイブルといわれることもある本である。\n表紙が楽譜のデザインであり、ソフトウェアにおける「コード」と音楽における「コード」(音楽符号) をかけているのがポイント。\n\nプログラムを書く人間なら読むべき、としばらく前に教えていただいたが積読されていた本である。\n英語版は無料で PDF が手に入る。\n日本語訳版は3000円くらいだが有名な本なので図書館とかに割と置いてありそう。\n(弊学にはあった。)\n\n感想\n\n本書は良いコードを書くための方法を具体的に説明しており、そのまま実践できそうな内容が詰め込まれている。\n\nしかしながら沢山のテクニックが示されておりその個々を読みながら納得することは出来ても、今の時点では自らの血肉となった気がしない。\n実際にコードを書くときに書かれた内容全てを実現することはすぐには出来ないだろう。\n定期的に見直して意識を続けるほかない。\n\n幸いにも各章のさいごに「まとめ」が付いており、これがとても良くできている。\nまとめをインデックスとしてまずは迷ったときに本書に戻れるようにしておきたい。\n\n特に5章, 6章のコメントに関する言及は興味深かった。\n本書では、よく言われる言葉「コメントには WHAT ではなく (あるいは HOW ではなく) ではなく WHY を書こう」ではなく「コードの理解するのに役立つものなら何でも良いから書こう」と説明されていた。\n\n私は以前はコメントを沢山書いていた。\n命名については深く考えておらず、ソースコード内に日本語で説明できる部分があるなら助かると思っていたからだ。\nしばらくして Git を学び、命名の大切さを知り、以前コメントに書いていたようなことは命名で表現できるのではないかと思うようになった。\nさらに無駄なコメントは悪である[^1]という考えを知った。\n\nこれらは勿論大切なことではあるが、必要以上にコメントを忌み嫌ってほとんど書かなくなったように思う。\n自分の書いたプログラムをあとから変更しようとするときにコードを理解する負担が増えたような気がして気づいた。\n\nこういった曲がった考えを直して正しいスタンスを説明してくれているのが本書だと感じた。[^2]\nコメントをどのように書くか悩んだときは、5章4説にある「とにかく書き始める」が有効だろう。\nまず頭で思ったことをそのまま書き出してから細かく改善することで良いコメントを作ることを勧めている。\n\nこういった一つ一つの事柄をコツコツ実践していきたい。\n\n[^1]: コードを読んですぐに分かるようなことをコメントに書くのは良くない。画面を専有する、コードを書き換えるときに一緒に書き換えなければならず負担になる、書換えを忘れてコードの内容とコメントの内容が乖離していたら読み手は混乱する、などの理由から。\n\n[^2]: そもそも無駄なコメントは必要ないと指摘してくださった方は同時にあわせて「リーダブルコードを読んだほうが良い」と仰っていた。 それを積読のまま消化しなかった自分が悪い。\n"},{"id":"http://localhost:3000/posts/2020-github-repositories","url":"http://localhost:3000/posts/2020-github-repositories","title":"自分のGitHubリポジトリで振り返る2020年","summary":"今年コミットした GitHub のリポジトリを順にみながら2020年の個人開発を振り返ってみる。 実は去年もやろうとしていた企画[^1]、今年こそ年内に公開するぞ。 リポジトリ一覧の取得 去年の記事では API を curl で取得していた[^2]が、今年は GitHub の公式 CLI である gh を使って取得することとする。 jq と gh をインストールし、 \\~/.config/gh/config.yml の aliases キーに、次のような内容を追記する。 ログインして、先程登録したエイリアスでリポジトリ一覧を取得する。 リポジトリを一つづつ振り返る 以下順番にコミットした Gi","date_published":"2020-12-31T18:18:37+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%87%AA%E5%88%86%E3%81%AEGitHub%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%81%A7%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8B2020%E5%B9%B4,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/04f4516f39f3f381ad27b0fc2c5bb924f4e0ef64","comment":"Add a post '2020-github-repositories'\n","date_modified":"2020-12-31T18:34:47+09:00"}],"content_html":"<p>今年コミットした GitHub のリポジトリを順にみながら2020年の個人開発を振り返ってみる。</p>\n<p>実は去年もやろうとしていた企画<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>、今年こそ年内に公開するぞ。</p>\n<h2>リポジトリ一覧の取得</h2>\n<p>去年の記事では API を curl で取得していた<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>が、今年は GitHub の公式 CLI である <a href=\"https://github.com/cli/cli\">gh</a> を使って取得することとする。</p>\n<p><a href=\"https://github.com/stedolan/jq\">jq</a> と gh をインストールし、 <code>~/.config/gh/config.yml</code> の aliases キーに、次のような内容を追記する。</p>\n<pre><code>aliases:\n    repos: |\n        !gh api --paginate graphql -f owner=\"$1\" -f query='\n          query($owner: String!, $per_page: Int = 100, $endCursor: String) {\n            repositoryOwner(login: $owner) {\n              repositories(first: $per_page, after: $endCursor, ownerAffiliations: OWNER) {\n                nodes { nameWithOwner, updatedAt }\n                pageInfo { hasNextPage endCursor }\n              }\n            }\n          }\n        ' | jq '.data.repositoryOwner.repositories.nodes[] | .updatedAt + \" \" + .nameWithOwner' -r | sort\n</code></pre>\n<p>ログインして、先程登録したエイリアスでリポジトリ一覧を取得する。</p>\n<pre><code class=\"hljs language-sh\">gh auth login\ngh repos | grep <span class=\"hljs-string\">'2020'</span> > repos.txt</code></pre>\n<h2>リポジトリを一つづつ振り返る</h2>\n<p>以下順番にコミットした GitHub リポジトリを振り返っていく。</p>\n<h3>lovelab-api</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/lovelab-api\">yammerjp/lovelab-api</a> : API server of lovelab with express.js</li>\n<li><a href=\"https://github.com/yammerjp/lovelab-batch\">yammerjp/lovelab-batch</a> : Batch server of lovelab with node.js</li>\n</ul>\n<p>2019年10月から2020年1月にかけての iPhone アプリを開発する演習授業に合わせて作った、TypeScript 製の API サーバ。\nデータベースを使ったサーバサイドアプリケーションを一人で作ったのは初めてで、サーバ内でどのような処理をしているか、また REST API とはどのようなものかなどの全体を知ることができた。</p>\n<p>ドキュメントは手書きしたがエンドポイントが意外と多く<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>、書くのが大変で中身も整っておらず良い出来とは言えない。\n今思えば Swagger などを使うべきだっただろう。</p>\n<p>認証系は簡素なもので「ID とパスワードの対で新規登録する」「ログイン時にアクセストークンを発行する」といった動作を自前で実装している。\n自前で実装したのは認証認可のしくみを理解していなかったからだ。\nスマートフォン用の API においてどのように認証認可が行われるか、HTTP の中でそれはどのように表現されるかがよくわかっておらず、ライブラリを使おうとしても「よくわからんな」という気持ちになった。</p>\n<p>そこで、授業でやっていることもあり (リリースまでは求められていない)、良い機会だと思って一連の流れを作ることにした。\n「車輪の再発明は無駄」「セキュリティホールの発生に繋がるので自前での実装は避けるべき」といった意見はごもっともだが、作ってしくみを理解するという点ではとても助かった。\n普通なら Express.js に使える認証ミドルウェアの Passport.js を使ったり Firebase Authentication や Auth0 などに任せてしまうのがいいだろう。</p>\n<p>そういえば Dockerfile を自分で初めて書いたのもこのアプリケーションだった。\nDocker は <a href=\"https://www.amazon.co.jp/dp/B07BHK5KX7/ref=dp-kindle-redirect?_encoding=UTF8&#x26;btkr=1\">プログラマのためのDocker教科書 第2版</a> を読んで学び, EC2 上に docker-compose を使って展開していた。</p>\n<h3>17ti.me</h3>\n<p>2月に作った、大学の研究室配属前に学生間で希望を調整するために非公式で作った Web アプリケーション。\n学内の情報がハードコーディングされているので公開していない。\n最終的に対象者の8割以上の人に利用していただいた。感謝。</p>\n<p>成績と希望を集計するもので、Vue.js と Firebase (Realtime Database, Authentication), Netlify を利用している。\n大学個人に付与されるメールアドレスを用いて Firebase Authentication でログイン機能を設け, Realtime Database 上に集計情報を記録した。</p>\n<p>Firebase Authentication は 前月に作った <a href=\"#lovelab-api\">lovelab-api</a> の認証と比べて簡単だし管理画面も良く出来ていて感動した。\nFirebase Realtime Database も 全体を1つの JSON として扱うシンプルなデータベースをクライアント側から読み書きできるので楽に作れて素晴らしかった。\n車輪の再発明のあとに最新式の自動車に乗った気分。</p>\n<h3>dotfiles</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/dotfiles\">yammerjp/dotfiles</a> : my .vimrc, .zshrc, and so on...</li>\n<li><a href=\"https://github.com/yammerjp/dot.yammer.jp\">yammerjp/dot.yammer.jp</a> : HTTP redirect server to download shell script to initialize dotfiles</li>\n</ul>\n<p>2020年は私が dotfiles に入門した年でもあった。</p>\n<p>dotfiles とは <code>~/.vimrc</code> や <code>~/.bashrc</code> などの各アプリケーション向けの個人設定ファイルの総称で、よくホームディレクトリの中にドットで始まるファイル名で保存されることからこう呼ばれる。\n複数のコンピュータで設定を共有するために dotfiles を GitHub で管理する Tips があり、Qiita で知ってやってみたいと思っていたのだ。</p>\n<p>3月の春休みに、4月の研究室配属時に研究室のコンピュータのセットアップを爆速で終わらせることを目指して作り始めた。<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup></p>\n<p>最もシンプルな dotfiles は 設定ファイルを別ディレクトリで git の管理下に置きホームディレクトリにシンボリックリンクを貼るものであるが、これにとどまらず様々な機能をもたせることもできる。\n私のリポジトリでは、アプリケーションの一括インストールや OS の設定変更、設定ファイルの自動配置などを行うスクリプトも一緒にまとめて管理している。\nOS は macOS と Ubuntu に対応させてそれぞれ判断してスクリプトが実行されるし、ついでに GitHub Actions で CI を回したりもしている。</p>\n<p>dotfiles を始めてよかったのはシェルに親しめたことだ。\nまずシェルスクリプトを書く機会が圧倒的に増えた。\nそれまでは普段書かないので if の記法ですら毎度 ggっていたくらいだったが、dotfiles を凝りだすとシェルスクリプトを書く必要が出てきて覚えた。</p>\n<p>他にも<code>.vimrc</code>を改造してプラグインを入れたり、シェルにエイリアスもたくさん貼るようになって便利になった。\n設定ファイルを壊してもすぐ直せるので色々試せるのが良い。</p>\n<h3>pdef</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/pdef\">yammerjp/pdef</a> : Patch script generator of Mac OS X User Defaults</li>\n<li><a href=\"https://github.com/yammerjp/homebrew-tap\">yammerjp/homebrew-tap</a> : yammerjp's collection of Homebrew (aka, Brew) \"formulae\"</li>\n</ul>\n<p>dotfiles の開発にあわせて、macOS の設定を保持する UserDefaults をシェルから書き換えたくなって作ったツール。\n詳細は当時のブログ記事に書いている。</p>\n<p>書いた記事:\n<a href=\"/posts/pdef/\">Macの設定を自動化するdefaultsコマンドと、それを助けるpdef</a>\n/ <a href=\"/posts/plist/\">(余談) User Defaultsとproperty list(plist)</a></p>\n<h3>memo.yammer.jp</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/memo.yammer.jp\">yammerjp/memo.yammer.jp</a> : my memos. <a href=\"https://memo.yammer.jp/\">https://memo.yammer.jp/</a></li>\n</ul>\n<p>このブログ (<a href=\"https://memo.yammer.jp\">memo.yammer.jp</a>) と個人のページ (<a href=\"https://yammer.jp\">yammer.jp</a>) を用意したのも 2020年。</p>\n<p>このブログは<a href=\"https://basd4g.hatenablog.com\">やんまーのブログ</a>とは別にメモや作業記録を雑に投稿するために作ったのに、使い分けが出来ておらず完全に迷走している。\nでも記事を書くハードルが下がったのはとても良くて「とりあえず雑に投稿しておくか」と自分で思える。</p>\n<p>Hugo で出来ていて、最近デザインの変更と OGP 対応をした。\n拡張したい機能がいくつかあるのでそのために来年は勉強も兼ねて Hugo から Next.js に置き換えたい。</p>\n<h3>yammer.jp</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/yammerjp.github.io\">yammerjp/yammerjp.github.io</a> : A web page including links for my SNS and Web sites</li>\n<li><a href=\"https://github.com/yammerjp/rss-republish.yammer.jp\">yammerjp/rss-republish.yammer.jp</a> : Republish RSS feeds with Vercel</li>\n</ul>\n<p><a href=\"https://yammer.jp\">個人のページ</a>。\n最初は linktree<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup> を真似して SNS のユーザページのリンクなどを含む HTML と CSS だけのページをおいていた。\n最近作り変えて自己紹介と記事の一覧も表示している。</p>\n<h3>はてなブログ</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/gimonfu\">yammerjp/gimonfu</a> : Manage hatena-blog articles</li>\n<li><a href=\"https://github.com/yammerjp/yammerjp.hatenablog.com\">yammerjp/yammerjp.hatenablog.com</a> : Hatenablog articles</li>\n<li><a href=\"https://github.com/yammerjp/blog.yammer.fun\">yammerjp/blog.yammer.fun</a> : Redirect old blog to new blog</li>\n<li><a href=\"https://github.com/yammerjp/hatenablog-post\">yammerjp/hatenablog-post</a> : Post article of markdown file to hatena-blog.</li>\n</ul>\n<p>去年 Nuxt.js で作ったブログをはてなブログに移行した。\n移行にあたって、画像を AWS S3 に移したり、旧ドメインをリダイレクトしたり (yammerjp/blog.yammer.fun)、はてなブログの記事管理 CLI (yammerjp/gimonfu)を作ったりした。</p>\n<p>最初は一括投稿のために hatenablog-post という CLI ツールを作ったが、それ以外の機能も欲しくなって gimonfu という CLI ツールに発展した。\ngimonfu は初めて npm publish したが、インターネット上のどこかで使ってくれている人がいるようで嬉しい。</p>\n<p>書いた記事: <a href=\"https://qiita.com/yammerjp/items/1a38857f6bafb20f065d\">gimonfu で、はてなブログの記事を GitHub と同期する - Qiita</a></p>\n<h3>willani</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/willani\">yammerjp/willani</a> : C Compiler</li>\n</ul>\n<p>2020年に一番時間を費やしたのが C コンパイラの willani。\n5月から2ヶ月くらい作って7月半ばに止まっているが、一応コンパイラ自体のセルフホストは達成した。\n(プリプロセッサが未完成。)\nまた気が向いたら続きをやりたい。</p>\n<p>自作したことで今までブラックボックスだったコンパイラがどんな動作をしているか知れて楽しかった。</p>\n<p>書いた記事:\n<a href=\"/posts/willani-start/\">数日前からCコンパイラを書き始めた。</a>\n/ <a href=\"/posts/willani-compliperbook-finished/\">自作Cコンパイラの途中経過</a>\n/ <a href=\"/posts/willani-try-selfhost/\">自作コンパイラのセルフホストに挑戦中</a>\n/ <a href=\"/posts/willani-for-stmt-bug/\">自作コンパイラのfor文バグ</a>\n/ <a href=\"/posts/willani-struct-alignment/\">C言語の構造体メンバのアライメント (x86_64, Linux (System V ABI))</a></p>\n<h3>mopm</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/mopm\">yammerjp/mopm</a> : Mopm (Manager Of Package Manager) is meta package manager for cross platform environment.</li>\n<li><a href=\"https://github.com/yammerjp/mopm-defs\">yammerjp/mopm-defs</a> : mopm package definition yaml files</li>\n<li><a href=\"https://github.com/yammerjp/mopm-defs-test\">yammerjp/mopm-defs-test</a></li>\n</ul>\n<p>既存のパッケージマネージャに不満を持ったので作り始めたソフトウェアのインストール支援ツール。\nGolang の入門も兼ねて秋に作り始めたが、しばらく進めていくと「これは HomeBrew の劣化版では？」という気がしてきて手が止まっている。</p>\n<h3>その他</h3>\n<p>その他。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/regex-visualizer\">yammerjp/regex-visualizer</a>, <a href=\"https://github.com/yammerjp/regex2dfa\">yammerjp/regex2dfa</a> ... 正規表現をグラフで描画するツール</li>\n<li><a href=\"https://github.com/yammerjp/pl0i\">yammerjp/pl0i</a>, <a href=\"https://github.com/yammerjp/pl0i\">yammerjp/cmm</a> ... 大学の教科書(コンパイラの講義)で題材とされた言語の拡張</li>\n<li><a href=\"https://github.com/yammerjp/competitive-programming\">yammerjp/competitive-programming</a> ... 競技プログラミングを解いたときのコードを載せるリポジトリ (全然解いていない)</li>\n<li><a href=\"https://github.com/yammerjp/java-design-pattern-multi-thread\">yammerjp/java-design-pattern-multi-thread</a> ... 輪講で読んでいた本の実践 (中断)</li>\n<li><a href=\"https://github.com/yammerjp/md-prev\">yammerjp/md-prev</a>, <a href=\"https://github.com/yammerjp/md-server\">yammerjp/md-server</a> ... Markdown で書いた記事の確認用アプリケーション</li>\n<li><a href=\"https://github.com/yammerjp/kozos\">yammerjp/kozos</a> 2019年4月に買い牛歩の歩みで進めている OS 自作、<a href=\"https://www.amazon.co.jp/12%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E3%81%A7%E4%BD%9C%E3%82%8B%E7%B5%84%E8%BE%BC%E3%81%BFOS%E8%87%AA%E4%BD%9C%E5%85%A5%E9%96%80-%E5%9D%82%E4%BA%95-%E5%BC%98%E4%BA%AE/dp/4877832394\">12ステップで作る組込みOS自作入門</a>。 やらねば。</li>\n<li><a href=\"https://github.com/yammerjp/solar-log\">yammerjp/solar-log</a>, <a href=\"https://github.com/yammerjp/solar-web\">yammerjp/solar-web</a> ... 家庭用太陽光発電システムのロギングと集計用アプリケーション</li>\n<li><a href=\"https://github.com/yammerjp/md2hiki\">yammerjp/md2hiki</a> ... Markdown 記法の文章を hiki 記法に置換するスクリプト</li>\n<li><a href=\"https://github.com/yammerjp/cat\">yammerjp/cat</a> ... C 言語で cat コマンドを実装してみる試み</li>\n<li>yammerjp/album-shelf, yammerjp/album-shelf.rb, yammerjp/rails-micro-blog (プライベートリポジトリ) ... Ruby on Rails と React で画像を管理する Web アプリケーションを作りたかった (中断)</li>\n<li><a href=\"https://github.com/yammerjp/ogp-getter\">yammerjp/ogp-getter</a> ... OGP の情報を抽出するアプリケーション</li>\n<li><a href=\"https://github.com/yammerjp/armyknife\">yammerjp/armyknife: Shell script snippets</a> ... bash製のシェルスクリプトで使えるツール群 (を作る予定)</li>\n<li><a href=\"https://github.com/yammerjp/pocket2retweet\">yammerjp/pocket2retweet</a> ... Pocket に保存したツイートをリツイートするスクリプト (<a href=\"http://localhost:1313/posts/pocket2retweet/\">ブログ記事</a>)</li>\n<li>yammerjp/keepa (プライベートリポジトリ) ... 日記用のWebアプリケーション (<a href=\"https://basd4g.hatenablog.com/entry/2020/12/02/124040\">ブログ記事</a>))</li>\n<li><a href=\"https://github.com/yammerjp/ryu-http-routing\">yammerjp/ryu-http-routing</a> ... 卒論の検証用</li>\n</ul>\n<p>...</p>\n<p>この他にも2020年に手を付けていた自分のリポジトリやフォークしたリポジトリがあるが、ここでは省略する。</p>\n<h2>総括</h2>\n<h3>良かったこと</h3>\n<p>2020年はコロナで家にいたということもあり、自分の時間がとれて継続的に何かしらを作っていた気がする。(後半は研究のために前半ほどの勢いはなかったが。)\n昨年ある面接で「作ったものはもっと公開しよう」とアドバイスをもらった事があり、それに従ってなるべくパブリックリポジトリで公開するようにしていた。</p>\n<p>結構飽きずにキリのいいところまで作り続けられた。\nそのおかげで npm publish や、HomeBrew の Formulae としての公開に繋がった。</p>\n<p>また、自分が作りたいものを作るときに新しい技術に少しずつ手を広げていけたように思う。</p>\n<h3>改善したいこと</h3>\n<p>「コードを読む機会が少ない」</p>\n<p>これに尽きると思う。\nOSS などの他人の書いたコードを読む機会が全然なくて、どこから手をつけていいのかもわからない。\nコードリーディングってどうやってするんでしょう？...\n働き始めたら他人のコードを必然的に読むことになると思うが、結構不安。</p>\n<h3>来年も</h3>\n<p>ものを作るのは楽しい。\n今年ほど時間の余裕がないだろうが、来年も新しいことを学ぶためにも何か作りたい。\n作りたいものは50個くらいある<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>。</p>\n<p>以上。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"/posts/2019-github-repositories/\">リポジトリで振り返る2019年 – memo.yammer.jp</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">去年のように API をcurlで叩くなら、basic 認証ではなくアクセストークンで行う必要がありそう。<a href=\"https://github.blog/2020-07-30-token-authentication-requirements-for-api-and-git-operations/\">Basic認証は廃止されたはず。</a><a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\"><a href=\"https://github.com/yammerjp/lovelab-api/blob/master/documents/specification/detail/index.md\">lovelab-api のドキュメント</a><a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">結局新型コロナウィルス感染症の影響でリモートになったので研究室のコンピュータをセットアップすることはないまま卒業しそうである。<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><a href=\"https://linktr.ee\">linktree</a> は SNS の自分のページへのリンクなどをまとめて表示する Webページを作成できるサービス。<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\">自分のメモの中に作りたいアプリケーションのネタ帳があり、そこに書かれた数。<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"今年コミットした GitHub のリポジトリを順にみながら2020年の個人開発を振り返ってみる。\n\n実は去年もやろうとしていた企画[^1]、今年こそ年内に公開するぞ。\n\nリポジトリ一覧の取得\n\n去年の記事では API を curl で取得していた[^2]が、今年は GitHub の公式 CLI である gh を使って取得することとする。\n\njq と gh をインストールし、 \\~/.config/gh/config.yml の aliases キーに、次のような内容を追記する。\n\n\n\nログインして、先程登録したエイリアスでリポジトリ一覧を取得する。\n\n\n\nリポジトリを一つづつ振り返る\n\n以下順番にコミットした GitHub リポジトリを振り返っていく。\n\nlovelab-api\n\nyammerjp/lovelab-api : API server of lovelab with express.js\n\nyammerjp/lovelab-batch : Batch server of lovelab with node.js\n\n2019年10月から2020年1月にかけての iPhone アプリを開発する演習授業に合わせて作った、TypeScript 製の API サーバ。\nデータベースを使ったサーバサイドアプリケーションを一人で作ったのは初めてで、サーバ内でどのような処理をしているか、また REST API とはどのようなものかなどの全体を知ることができた。\n\nドキュメントは手書きしたがエンドポイントが意外と多く[^3]、書くのが大変で中身も整っておらず良い出来とは言えない。\n今思えば Swagger などを使うべきだっただろう。\n\n認証系は簡素なもので「ID とパスワードの対で新規登録する」「ログイン時にアクセストークンを発行する」といった動作を自前で実装している。\n自前で実装したのは認証認可のしくみを理解していなかったからだ。\nスマートフォン用の API においてどのように認証認可が行われるか、HTTP の中でそれはどのように表現されるかがよくわかっておらず、ライブラリを使おうとしても「よくわからんな」という気持ちになった。\n\nそこで、授業でやっていることもあり (リリースまでは求められていない)、良い機会だと思って一連の流れを作ることにした。\n「車輪の再発明は無駄」「セキュリティホールの発生に繋がるので自前での実装は避けるべき」といった意見はごもっともだが、作ってしくみを理解するという点ではとても助かった。\n普通なら Express.js に使える認証ミドルウェアの Passport.js を使ったり Firebase Authentication や Auth0 などに任せてしまうのがいいだろう。\n\nそういえば Dockerfile を自分で初めて書いたのもこのアプリケーションだった。\nDocker は プログラマのためのDocker教科書 第2版 を読んで学び, EC2 上に docker-compose を使って展開していた。\n\n17ti.me\n\n2月に作った、大学の研究室配属前に学生間で希望を調整するために非公式で作った Web アプリケーション。\n学内の情報がハードコーディングされているので公開していない。\n最終的に対象者の8割以上の人に利用していただいた。感謝。\n\n成績と希望を集計するもので、Vue.js と Firebase (Realtime Database, Authentication), Netlify を利用している。\n大学個人に付与されるメールアドレスを用いて Firebase Authentication でログイン機能を設け, Realtime Database 上に集計情報を記録した。\n\nFirebase Authentication は 前月に作った lovelab-api の認証と比べて簡単だし管理画面も良く出来ていて感動した。\nFirebase Realtime Database も 全体を1つの JSON として扱うシンプルなデータベースをクライアント側から読み書きできるので楽に作れて素晴らしかった。\n車輪の再発明のあとに最新式の自動車に乗った気分。\n\ndotfiles\n\nyammerjp/dotfiles : my .vimrc, .zshrc, and so on...\n\nyammerjp/dot.yammer.jp : HTTP redirect server to download shell script to initialize dotfiles\n\n2020年は私が dotfiles に入門した年でもあった。\n\ndotfiles とは \\~/.vimrc や \\~/.bashrc などの各アプリケーション向けの個人設定ファイルの総称で、よくホームディレクトリの中にドットで始まるファイル名で保存されることからこう呼ばれる。\n複数のコンピュータで設定を共有するために dotfiles を GitHub で管理する Tips があり、Qiita で知ってやってみたいと思っていたのだ。\n\n3月の春休みに、4月の研究室配属時に研究室のコンピュータのセットアップを爆速で終わらせることを目指して作り始めた。[^4]\n\n最もシンプルな dotfiles は 設定ファイルを別ディレクトリで git の管理下に置きホームディレクトリにシンボリックリンクを貼るものであるが、これにとどまらず様々な機能をもたせることもできる。\n私のリポジトリでは、アプリケーションの一括インストールや OS の設定変更、設定ファイルの自動配置などを行うスクリプトも一緒にまとめて管理している。\nOS は macOS と Ubuntu に対応させてそれぞれ判断してスクリプトが実行されるし、ついでに GitHub Actions で CI を回したりもしている。\n\ndotfiles を始めてよかったのはシェルに親しめたことだ。\nまずシェルスクリプトを書く機会が圧倒的に増えた。\nそれまでは普段書かないので if の記法ですら毎度 ggっていたくらいだったが、dotfiles を凝りだすとシェルスクリプトを書く必要が出てきて覚えた。\n\n他にも.vimrcを改造してプラグインを入れたり、シェルにエイリアスもたくさん貼るようになって便利になった。\n設定ファイルを壊してもすぐ直せるので色々試せるのが良い。\n\npdef\n\nyammerjp/pdef : Patch script generator of Mac OS X User Defaults\n\nyammerjp/homebrew-tap : yammerjp's collection of Homebrew (aka, Brew) \"formulae\"\n\ndotfiles の開発にあわせて、macOS の設定を保持する UserDefaults をシェルから書き換えたくなって作ったツール。\n詳細は当時のブログ記事に書いている。\n\n書いた記事:\nMacの設定を自動化するdefaultsコマンドと、それを助けるpdef\n/ (余談) User Defaultsとproperty list(plist)\n\nmemo.yammer.jp\n\nyammerjp/memo.yammer.jp : my memos. https\\://memo.yammer.jp/\n\nこのブログ (memo.yammer.jp) と個人のページ (yammer.jp) を用意したのも 2020年。\n\nこのブログはやんまーのブログとは別にメモや作業記録を雑に投稿するために作ったのに、使い分けが出来ておらず完全に迷走している。\nでも記事を書くハードルが下がったのはとても良くて「とりあえず雑に投稿しておくか」と自分で思える。\n\nHugo で出来ていて、最近デザインの変更と OGP 対応をした。\n拡張したい機能がいくつかあるのでそのために来年は勉強も兼ねて Hugo から Next.js に置き換えたい。\n\nyammer.jp\n\nyammerjp/yammerjp.github.io : A web page including links for my SNS and Web sites\n\nyammerjp/rss-republish.yammer.jp : Republish RSS feeds with Vercel\n\n個人のページ。\n最初は linktree[^5] を真似して SNS のユーザページのリンクなどを含む HTML と CSS だけのページをおいていた。\n最近作り変えて自己紹介と記事の一覧も表示している。\n\nはてなブログ\n\nyammerjp/gimonfu : Manage hatena-blog articles\n\nyammerjp/yammerjp.hatenablog.com : Hatenablog articles\n\nyammerjp/blog.yammer.fun : Redirect old blog to new blog\n\nyammerjp/hatenablog-post : Post article of markdown file to hatena-blog.\n\n去年 Nuxt.js で作ったブログをはてなブログに移行した。\n移行にあたって、画像を AWS S3 に移したり、旧ドメインをリダイレクトしたり (yammerjp/blog.yammer.fun)、はてなブログの記事管理 CLI (yammerjp/gimonfu)を作ったりした。\n\n最初は一括投稿のために hatenablog-post という CLI ツールを作ったが、それ以外の機能も欲しくなって gimonfu という CLI ツールに発展した。\ngimonfu は初めて npm publish したが、インターネット上のどこかで使ってくれている人がいるようで嬉しい。\n\n書いた記事: gimonfu で、はてなブログの記事を GitHub と同期する - Qiita\n\nwillani\n\nyammerjp/willani : C Compiler\n\n2020年に一番時間を費やしたのが C コンパイラの willani。\n5月から2ヶ月くらい作って7月半ばに止まっているが、一応コンパイラ自体のセルフホストは達成した。\n(プリプロセッサが未完成。)\nまた気が向いたら続きをやりたい。\n\n自作したことで今までブラックボックスだったコンパイラがどんな動作をしているか知れて楽しかった。\n\n書いた記事:\n数日前からCコンパイラを書き始めた。\n/ 自作Cコンパイラの途中経過\n/ 自作コンパイラのセルフホストに挑戦中\n/ 自作コンパイラのfor文バグ\n/ C言語の構造体メンバのアライメント (x86\\_64, Linux (System V ABI))\n\nmopm\n\nyammerjp/mopm : Mopm (Manager Of Package Manager) is meta package manager for cross platform environment.\n\nyammerjp/mopm-defs : mopm package definition yaml files\n\nyammerjp/mopm-defs-test\n\n既存のパッケージマネージャに不満を持ったので作り始めたソフトウェアのインストール支援ツール。\nGolang の入門も兼ねて秋に作り始めたが、しばらく進めていくと「これは HomeBrew の劣化版では？」という気がしてきて手が止まっている。\n\nその他\n\nその他。\n\nyammerjp/regex-visualizer, yammerjp/regex2dfa ... 正規表現をグラフで描画するツール\n\nyammerjp/pl0i, yammerjp/cmm ... 大学の教科書(コンパイラの講義)で題材とされた言語の拡張\n\nyammerjp/competitive-programming ... 競技プログラミングを解いたときのコードを載せるリポジトリ (全然解いていない)\n\nyammerjp/java-design-pattern-multi-thread ... 輪講で読んでいた本の実践 (中断)\n\nyammerjp/md-prev, yammerjp/md-server ... Markdown で書いた記事の確認用アプリケーション\n\nyammerjp/kozos 2019年4月に買い牛歩の歩みで進めている OS 自作、12ステップで作る組込みOS自作入門。 やらねば。\n\nyammerjp/solar-log, yammerjp/solar-web ... 家庭用太陽光発電システムのロギングと集計用アプリケーション\n\nyammerjp/md2hiki ... Markdown 記法の文章を hiki 記法に置換するスクリプト\n\nyammerjp/cat ... C 言語で cat コマンドを実装してみる試み\n\nyammerjp/album-shelf, yammerjp/album-shelf.rb, yammerjp/rails-micro-blog (プライベートリポジトリ) ... Ruby on Rails と React で画像を管理する Web アプリケーションを作りたかった (中断)\n\nyammerjp/ogp-getter ... OGP の情報を抽出するアプリケーション\n\nyammerjp/armyknife: Shell script snippets ... bash製のシェルスクリプトで使えるツール群 (を作る予定)\n\nyammerjp/pocket2retweet ... Pocket に保存したツイートをリツイートするスクリプト (ブログ記事)\n\nyammerjp/keepa (プライベートリポジトリ) ... 日記用のWebアプリケーション (ブログ記事))\n\nyammerjp/ryu-http-routing ... 卒論の検証用\n\n...\n\nこの他にも2020年に手を付けていた自分のリポジトリやフォークしたリポジトリがあるが、ここでは省略する。\n\n総括\n\n良かったこと\n\n2020年はコロナで家にいたということもあり、自分の時間がとれて継続的に何かしらを作っていた気がする。(後半は研究のために前半ほどの勢いはなかったが。)\n昨年ある面接で「作ったものはもっと公開しよう」とアドバイスをもらった事があり、それに従ってなるべくパブリックリポジトリで公開するようにしていた。\n\n結構飽きずにキリのいいところまで作り続けられた。\nそのおかげで npm publish や、HomeBrew の Formulae としての公開に繋がった。\n\nまた、自分が作りたいものを作るときに新しい技術に少しずつ手を広げていけたように思う。\n\n改善したいこと\n\n「コードを読む機会が少ない」\n\nこれに尽きると思う。\nOSS などの他人の書いたコードを読む機会が全然なくて、どこから手をつけていいのかもわからない。\nコードリーディングってどうやってするんでしょう？...\n働き始めたら他人のコードを必然的に読むことになると思うが、結構不安。\n\n来年も\n\nものを作るのは楽しい。\n今年ほど時間の余裕がないだろうが、来年も新しいことを学ぶためにも何か作りたい。\n作りたいものは50個くらいある[^6]。\n\n以上。\n\n[^1]: リポジトリで振り返る2019年 – memo.yammer.jp\n\n[^2]: 去年のように API をcurlで叩くなら、basic 認証ではなくアクセストークンで行う必要がありそう。Basic認証は廃止されたはず。\n\n[^3]: lovelab-api のドキュメント\n\n[^4]: 結局新型コロナウィルス感染症の影響でリモートになったので研究室のコンピュータをセットアップすることはないまま卒業しそうである。\n\n[^5]: linktree は SNS の自分のページへのリンクなどをまとめて表示する Webページを作成できるサービス。\n\n[^6]: 自分のメモの中に作りたいアプリケーションのネタ帳があり、そこに書かれた数。\n"},{"id":"http://localhost:3000/posts/hugo-url-encode","url":"http://localhost:3000/posts/hugo-url-encode","title":"HugoでURLをパーセントエンコード (CloudinaryでOGP画像生成)","summary":"Hugo で Cloudinary[^1] を用いた OGP 画像生成のため日本語を URL に埋め込みたい。 埋め込みのために文字列をパーセントエンコード[^2] する方法を記す。 方法 Hugo のテンプレートの中で $string 変数に文字列が格納されているとき、次の表記で変数内の文字列をパーセントエンコードして出力できる。 例えば OGP 画像のためURLに日本語文字列を埋め込むのは次のようにして実現できる 経緯と補足 上記の方法は少々トリッキーである。 私の調べた範囲ではHugo に定義された関数の中で直接 URL をパーセントエンコードするものは見つけられなかった。 英語圏などで","date_published":"2020-12-26T20:52:36+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Hugo%E3%81%A7URL%E3%82%92%E3%83%91%E3%83%BC%E3%82%BB%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%20(Cloudinary%E3%81%A7OGP%E7%94%BB%E5%83%8F%E7%94%9F%E6%88%90),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Hugo","ブログ"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1741da28aa87b809153d2c6799f500b28fc236a8","comment":"注釈内の改行を削除してremark-footnoteで正しく変換されるよう修正\n","date_modified":"2021-05-05T19:47:55+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae4707afa8a5c9bf15d37d99ba82f6c7f53b96cb","comment":"Fix words\n","date_modified":"2020-12-27T01:13:21+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/d06458eff2797d59fa1951267130207e58722cd9","comment":"Add a post 'hugo-url-encode'\n","date_modified":"2020-12-27T00:56:51+09:00"}],"content_html":"<p>Hugo で Cloudinary<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> を用いた OGP 画像生成のため日本語を URL に埋め込みたい。\n埋め込みのために文字列をパーセントエンコード<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> する方法を記す。</p>\n<h2>方法</h2>\n<p>Hugo のテンプレートの中で <code>$string</code> 変数に文字列が格納されているとき、次の表記で変数内の文字列をパーセントエンコードして出力できる。</p>\n<pre><code>{{- replace (substr (querify  \"a\" $string) 2) \"+\" \"%20\" -}}\n</code></pre>\n<p>例えば OGP 画像のためURLに日本語文字列を埋め込むのは次のようにして実現できる</p>\n<pre><code>{{ $title := \"埋め込む文字列\" }}\n&#x3C;meta\n  property=\"og:image\"\n  content=\"https://res.cloudinary.com/basd4g/image/upload/{{- replace (substr (querify  \"a\" $title) 2) \"+\" \"%20\" -}}/v1608780036/memo-basd4g-net-ogp.png\"\n/>\n</code></pre>\n<h2>経緯と補足</h2>\n<p>上記の方法は少々トリッキーである。\n私の調べた範囲ではHugo に定義された関数の中で直接 URL をパーセントエンコードするものは見つけられなかった。\n英語圏などでは<code> </code>(半角空白)を<code>%20</code>に置換すればよいのでは？という回答もあったが、日本語はそれでは困る。</p>\n<p>しかしながらテンプレート内で表示されるページの URL を取得する <code>{{- .Permalink -}}</code> という値があるらしく、この値からは適切にパーセントエンコードされた値を取得できることがわかった。\nということで Hugo の内部で URL として扱われる文字列はパーセントエンコードされるっぽい。</p>\n<p>そこで 任意の文字列を URL として Hugo に扱わせそうな機能である、URL クエリパラメータを生成する querify 関数を利用すると実現できることをみつけた。\n上述の方法では、querify 関数によってパーセントエンコードされたクエリパラメータに変換し、クエリパラメータの先頭部分と半角空白文字を処理することで実現している。</p>\n<p>というわけでこのブログもOGPに対応した。\nもしもっとシンプルな方法があったら教えてください。</p>\n<hr>\n<p>参考: Hugo</p>\n<ul>\n<li><a href=\"https://discourse.gohugo.io/t/url-encoding-percent-encoding-with-hugo-solved/16546/3\">URL encoding (percent encoding) with Hugo? [SOLVED] - support - HUGO</a></li>\n<li><a href=\"https://discourse.gohugo.io/t/urlencode-in-hugo/24215/5\">URLencode in Hugo - support - HUGO</a></li>\n<li><a href=\"https://gohugo.io/hugo-pipes/resource-from-string/\">Creating a resource from a string | Hugo</a></li>\n<li><a href=\"https://gohugo.io/functions/querify/\">querify | Hugo</a></li>\n<li><a href=\"https://gohugo.io/functions/replace/\">replace | Hugo</a></li>\n<li><a href=\"https://gohugo.io/functions/substr/\">substr | Hugo</a></li>\n</ul>\n<p>参考: パーセントエンコード</p>\n<ul>\n<li><a href=\"https://url.spec.whatwg.org/\">URL Standard</a></li>\n<li><a href=\"https://triple-underscore.github.io/URL-ja.html\">URL Standard （日本語訳）</a></li>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Glossary/percent-encoding\">Percent-encoding (パーセントエンコーディング) - MDN Web Docs 用語集: ウェブ関連用語の定義 | MDN</a></li>\n<li><a href=\"https://www.ipa.go.jp/security/fy21/reports/tech1-tg/b_09.html\">情報セキュリティ技術動向調査（2009 年下期）：IPA 独立行政法人 情報処理推進機構</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\"><a href=\"https://cloudinary.com\">Cloudinary</a> はアップロードした画像を配信できるサービスで、URL で画像の大きさや文字などを指定すると加工した画像が返却される機能がある。これを用いて記事のタイトルを URL に含め、事前にアップロードした背景画像と組み合わせて記事ごとの OGP 画像として配信することができる。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">URL に使用できない文字を、文字コードに置換することで URL に有効な文字の範囲で表現する方法。 置換対象の文字を % とその後ろに文字コードの16進表現を続ける形に置換する。 例えば <code>https://ja.wikipedia.org/wiki/パーセントエンコーディング</code> は <code>https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%BB%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0</code> と表現できる。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"Hugo で Cloudinary[^1] を用いた OGP 画像生成のため日本語を URL に埋め込みたい。\n埋め込みのために文字列をパーセントエンコード[^2] する方法を記す。\n\n方法\n\nHugo のテンプレートの中で $string 変数に文字列が格納されているとき、次の表記で変数内の文字列をパーセントエンコードして出力できる。\n\n\n\n例えば OGP 画像のためURLに日本語文字列を埋め込むのは次のようにして実現できる\n\n\n\n経緯と補足\n\n上記の方法は少々トリッキーである。\n私の調べた範囲ではHugo に定義された関数の中で直接 URL をパーセントエンコードするものは見つけられなかった。\n英語圏などでは (半角空白)を%20に置換すればよいのでは？という回答もあったが、日本語はそれでは困る。\n\nしかしながらテンプレート内で表示されるページの URL を取得する {{- .Permalink -}} という値があるらしく、この値からは適切にパーセントエンコードされた値を取得できることがわかった。\nということで Hugo の内部で URL として扱われる文字列はパーセントエンコードされるっぽい。\n\nそこで 任意の文字列を URL として Hugo に扱わせそうな機能である、URL クエリパラメータを生成する querify 関数を利用すると実現できることをみつけた。\n上述の方法では、querify 関数によってパーセントエンコードされたクエリパラメータに変換し、クエリパラメータの先頭部分と半角空白文字を処理することで実現している。\n\nというわけでこのブログもOGPに対応した。\nもしもっとシンプルな方法があったら教えてください。\n\n\n\n参考: Hugo\n\nURL encoding (percent encoding) with Hugo? \\[SOLVED] - support - HUGO\n\nURLencode in Hugo - support - HUGO\n\nCreating a resource from a string | Hugo\n\nquerify | Hugo\n\nreplace | Hugo\n\nsubstr | Hugo\n\n参考: パーセントエンコード\n\nURL Standard\n\nURL Standard （日本語訳）\n\nPercent-encoding (パーセントエンコーディング) - MDN Web Docs 用語集: ウェブ関連用語の定義 | MDN\n\n情報セキュリティ技術動向調査（2009 年下期）：IPA 独立行政法人 情報処理推進機構\n\n[^1]: Cloudinary はアップロードした画像を配信できるサービスで、URL で画像の大きさや文字などを指定すると加工した画像が返却される機能がある。これを用いて記事のタイトルを URL に含め、事前にアップロードした背景画像と組み合わせて記事ごとの OGP 画像として配信することができる。\n\n[^2]: URL に使用できない文字を、文字コードに置換することで URL に有効な文字の範囲で表現する方法。 置換対象の文字を % とその後ろに文字コードの16進表現を続ける形に置換する。 例えば https\\://ja.wikipedia.org/wiki/パーセントエンコーディング は https\\://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%BB%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0 と表現できる。\n"},{"id":"http://localhost:3000/posts/mba2020-setup","url":"http://localhost:3000/posts/mba2020-setup","title":"MacBookAir 2020 (M1) のセットアップ","summary":"Apple Silicon を搭載した MacBook Air を購入したのでセットアップをやっていく。 そのメモ。 2020/12/20現在では「brew bundleしておわり」というわけにはいかない。 できる限りApple Silicon版のバイナリを使いたいので、各種ソフトウェアのビルド方法などを記録することにする。 Tips arch -x86\\_64 を先頭につけてコマンドを実行すると Rosseta2 上で実行してくれる。 ソフトウェアのインストール以前 macOS の設定 ライブ変換の無効化 OSのキーマップ設定を変更 (capslock -> esc) ssh GitHub ","date_published":"2020-12-22T14:24:01+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:MacBookAir%202020%20(M1)%20%E3%81%AE%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","AppleSilicon","Setup"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/8bb100446200bd8b9d794e288adc2baf2653d3d9","comment":"Add how to install ImageMagick\n","date_modified":"2021-01-09T17:48:18+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/7a77eb0ff949700aefa681f95ca38126672d44fa","comment":"Update picture urls\n","date_modified":"2020-12-24T22:11:26+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4cdbe44f24005ce04609099229898087f19ee6b4","comment":"Add the post 'mba2020-setup'\n","date_modified":"2020-12-23T11:56:57+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/5b1b4d8649a3f043815a9193894f15df01c71746","comment":"Add the post 'mba2020-setup' (draft)\n","date_modified":"2020-12-23T11:09:30+09:00"}],"content_html":"<p>Apple Silicon を搭載した MacBook Air を購入したのでセットアップをやっていく。\nそのメモ。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">m1 MacBook Air が届いたのでとりあえずたくさんアプリケーションやタブを連続起動して「はえ〜」ってやつをやりました。</p>&mdash; やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1340576122795266048?ref_src=twsrc%5Etfw\">December 20, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>2020/12/20現在では「<code>brew bundle</code>しておわり」というわけにはいかない。\nできる限りApple Silicon版のバイナリを使いたいので、各種ソフトウェアのビルド方法などを記録することにする。</p>\n<h2>Tips</h2>\n<ul>\n<li><code>arch -x86_64</code> を先頭につけてコマンドを実行すると Rosseta2 上で実行してくれる。</li>\n</ul>\n<h2>ソフトウェアのインストール以前</h2>\n<h3>macOS の設定</h3>\n<ul>\n<li>ライブ変換の無効化</li>\n<li>OSのキーマップ設定を変更 (capslock -> esc)</li>\n</ul>\n<h3>ssh</h3>\n<pre><code class=\"hljs language-sh\">mkdir ~/.ssh\nchmod 700 ~/.ssh\n<span class=\"hljs-built_in\">cd</span> ~/.ssh\nssh-keygen -t rsa -b 4096 -C <span class=\"hljs-string\">\"mymail@example.com\"</span>\ncat id_rsa.pub | pbcopy</code></pre>\n<p><a href=\"https://github.com/settings/keys\">GitHub Settings</a> を開いて 'New SSH key' を追加</p>\n<h3>dotfiles</h3>\n<pre><code class=\"hljs language-sh\">xcode-select --install\ncurl -sL http://dot.yammer.jp | sh\n<span class=\"hljs-built_in\">cd</span> dotfiles\nmake link\nvim</code></pre>\n<h2>ソフトウェアのインストール</h2>\n<p>Web ページからパッケージをダウンロードしてインストールしたものは以下。</p>\n<ul>\n<li><a href=\"https://pilotmoon.com/scrollreverser/\">Scroll Reverser</a></li>\n<li><a href=\"https://karabiner-elements.pqrs.org/\">Karabiner-Elements</a></li>\n<li><a href=\"https://zoom.us/download#client_4meeting\">Zoom</a> (起動してログインの後、Apple Silicon版にアップデートするダイアログが出てくる)</li>\n<li><a href=\"https://www.macports.org/install.php\">MacPorts</a></li>\n<li><a href=\"https://www.mozilla.org/ja/firefox/new/\">Firefox</a></li>\n<li><a href=\"https://www.google.co.jp/chrome\">Google Chrome</a></li>\n</ul>\n<p>(<a href=\"https://vivaldi.com/ja/\">Vivaldi</a> はまだintel版しかないので、アップデートして欲しい。)</p>\n<p>ビルドするなどして導入したのは以下。</p>\n<h3>Homebrew (for Apple Silicon)</h3>\n<pre><code class=\"hljs language-sh\">sudo mkdir /opt/homebrew\nsudo chown <span class=\"hljs-variable\">$USER</span> /opt/homebrew\ncurl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C /opt/homebrew</code></pre>\n<h3>tmux</h3>\n<pre><code class=\"hljs language-sh\">brew install --build-from-source tmux</code></pre>\n<h3>Node.js</h3>\n<pre><code class=\"hljs language-sh\">sudo port install nvm <span class=\"hljs-comment\"># install nodejs version manager</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'source /opt/local/share/nvm/init-nvm.sh'</span> >> ~/.zshrc\nsudo port install git curl openssl automake\nnvm install v15</code></pre>\n<p>参考: <a href=\"https://zenn.dev/ioridev/articles/c74af379e4e73151790d\">個人的 M1 mac 開発環境状況 2020/11/28更新 - Zenn.dev</a></p>\n<p>nodejsのビルドはそこそこ CPU パワーと時間を使う</p>\n<h3>Golang</h3>\n<p>まずはIntel版をWebからダウンロードしてインストールする(<a href=\"https://golang.org/\">The Go Programming Language</a>)</p>\n<p>次に以下の手順でApple Silicon向けにビルドした後、Intel版を削除</p>\n<pre><code class=\"hljs language-sh\">go get golang.org/dl/gotip\nGODEBUG=asyncpreemptoff=1 GOARCH=arm64 ~/go/bin/gotip download\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$HOME</span>/sdk/gotip/bin/darwin_arm64\"</span> | sudo tee /etc/paths.d/go\n<span class=\"hljs-built_in\">which</span> go <span class=\"hljs-comment\"># check to be installed</span>\nsudo rm -rf /usr/<span class=\"hljs-built_in\">local</span>/go</code></pre>\n<h3>peco</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-built_in\">cd</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/peco/peco.git &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> peco\nmake build\nmv ~/peco/releases/peco_darwin_arm64/peco /usr/<span class=\"hljs-built_in\">local</span>/bin/peco</code></pre>\n<h3>hugo</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-built_in\">cd</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/gohugoio/hugo.com &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> hugo\ngo build\nmv ~/hugo/hugo /usr/<span class=\"hljs-built_in\">local</span>/bin/hugo</code></pre>\n<h3>jq</h3>\n<pre><code class=\"hljs language-sh\">brew install --build-from-source jq</code></pre>\n<h3>gh</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-built_in\">cd</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/cli/cli.git &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> cli\nmake\nmv bin/gh /usr/<span class=\"hljs-built_in\">local</span>/bin/gh</code></pre>\n<h3>mmv</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-built_in\">cd</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/itchyny/mmv.git &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> mmv\nmake\nmv mmv /usr/<span class=\"hljs-built_in\">local</span>/bin/mmv</code></pre>\n<h3>ImageMagick</h3>\n<p><a href=\"https://imagemagick.org/script/install-source.php\">ImageMagick - Install from Source</a></p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># libjpeg</span>\ncurl https://download.imagemagick.org/ImageMagick/download/delegates/jpegsrc.v9b.tar.gz -o jpegsrc.v9b.tar.gz\ntar xvf jpegsrc.v9b.tar.gz\n<span class=\"hljs-built_in\">cd</span> jpeg-9b\n./configure\nmake\nsudo make install\n\n<span class=\"hljs-comment\"># image magick</span>\n<span class=\"hljs-built_in\">cd</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/ImageMagick/ImageMagick.git &#x26;&#x26; <span class=\"hljs-built_in\">cd</span> ImageMagick\ngit checkout　7.0.9-9\n./configure\nmake\nsudo make install</code></pre>\n","content_text":"Apple Silicon を搭載した MacBook Air を購入したのでセットアップをやっていく。\nそのメモ。\n\n\n\n2020/12/20現在では「brew bundleしておわり」というわけにはいかない。\nできる限りApple Silicon版のバイナリを使いたいので、各種ソフトウェアのビルド方法などを記録することにする。\n\nTips\n\narch -x86\\_64 を先頭につけてコマンドを実行すると Rosseta2 上で実行してくれる。\n\nソフトウェアのインストール以前\n\nmacOS の設定\n\nライブ変換の無効化\n\nOSのキーマップ設定を変更 (capslock -> esc)\n\nssh\n\n\n\nGitHub Settings を開いて 'New SSH key' を追加\n\ndotfiles\n\n\n\nソフトウェアのインストール\n\nWeb ページからパッケージをダウンロードしてインストールしたものは以下。\n\nScroll Reverser\n\nKarabiner-Elements\n\nZoom (起動してログインの後、Apple Silicon版にアップデートするダイアログが出てくる)\n\nMacPorts\n\nFirefox\n\nGoogle Chrome\n\n(Vivaldi はまだintel版しかないので、アップデートして欲しい。)\n\nビルドするなどして導入したのは以下。\n\nHomebrew (for Apple Silicon)\n\n\n\ntmux\n\n\n\nNode.js\n\n\n\n参考: 個人的 M1 mac 開発環境状況 2020/11/28更新 - Zenn.dev\n\nnodejsのビルドはそこそこ CPU パワーと時間を使う\n\nGolang\n\nまずはIntel版をWebからダウンロードしてインストールする(The Go Programming Language)\n\n次に以下の手順でApple Silicon向けにビルドした後、Intel版を削除\n\n\n\npeco\n\n\n\nhugo\n\n\n\njq\n\n\n\ngh\n\n\n\nmmv\n\n\n\nImageMagick\n\nImageMagick - Install from Source\n\n"},{"id":"http://localhost:3000/posts/pocket2retweet","url":"http://localhost:3000/posts/pocket2retweet","title":"Pocketにツイートを保存したらリツイートする","summary":"題名のスクリプトを作ってcronで定期実行したら便利だった話。 背景 Twitter アカウントがいくつかある。[^1] 情報を浴びるように流しているアカウントだったり、情報の種類別だったり、使っていないものだったり。 PC で Twitter を見るときは大体 TweetDeckを使っておりこれは結構使いやすい。 一方で iOS ではマルチアカウントで満足する Twitter クライアントを見つけられていない。 (今は feather を使っている。) 具体的には次のような機能がほしい。 ユーザを別アカウントでフォローする ツイートを別アカウントでリツイートする 作ったもの 作ったものはこち","date_published":"2020-12-15T18:27:23+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Pocket%E3%81%AB%E3%83%84%E3%82%A4%E3%83%BC%E3%83%88%E3%82%92%E4%BF%9D%E5%AD%98%E3%81%97%E3%81%9F%E3%82%89%E3%83%AA%E3%83%84%E3%82%A4%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/01109e162867b707b5ff0de03bd6676cd9526866","comment":"Add the post of pocket2retweet\n","date_modified":"2020-12-15T23:45:39+09:00"}],"content_html":"<p>題名のスクリプトを作ってcronで定期実行したら便利だった話。</p>\n<h2>背景</h2>\n<p>Twitter アカウントがいくつかある。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>\n情報を浴びるように流しているアカウントだったり、情報の種類別だったり、使っていないものだったり。</p>\n<p>PC で Twitter を見るときは大体 <a href=\"https://tweetdeck.twitter.com\">TweetDeck</a>を使っておりこれは結構使いやすい。\n一方で iOS ではマルチアカウントで満足する Twitter クライアントを見つけられていない。 (今は <a href=\"https://apps.apple.com/jp/app/feather-for-twitter/id793157344\">feather</a> を使っている。)</p>\n<p>具体的には次のような機能がほしい。</p>\n<ul>\n<li>ユーザを別アカウントでフォローする</li>\n<li>ツイートを別アカウントでリツイートする</li>\n</ul>\n<h2>作ったもの</h2>\n<p>作ったものはこちら: <a href=\"https://github.com/yammerjp/pocket2retweet\">pocket2retweet - GitHub</a></p>\n<p>対象のユーザとツイートを <a href=\"https://getpocket.com\">Pocket</a> に記録し、あとからバッチ処理するようにした。</p>\n<p>次の2つの機能をもつスクリプトを cron で1時間ごとに定期実行する。</p>\n<ul>\n<li>Pocket に保存されているツイートを Pocket API で取得し、Twitter API でリツイートしたあと、Pocket から削除する。</li>\n<li>Pocket に保存されている Twitter ユーザページ を Pocket API で取得し、Twitter API でフォローしたあと、Pocket から削除する。</li>\n</ul>\n<p>API の条件的には1分に1回くらいでもいいくらいだが、多少遅れても困らないので1時間に1回としている。</p>\n<h2>感想</h2>\n<p>我ながら便利。</p>\n<p>Pocket への保存はアプリ間共有で Pocket を選べばよいだけなので、Web ブラウザでもアプリでも、iOS に限らず使える。</p>\n<p>もともと Pocket に保存したツイートは Pocket のページからは見づらかったので、リツイートしたものから探すほうがみやすくてよい感じ。</p>\n<p>Pocket の現状の自分の使い方では、保存するのは楽でいいけどけど整理されていないし読みづらいみたいなところがある。\nもっと活用できそうな気がするので、他のサービスともいい感じに連携して便利にする方法を考えていきたい。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">リスト機能を使って1つのアカウントでやれやという意見もあるだろう。以前はそうしていたのだがリスト管理が面倒な気がして、今はアカウントを分けてフォローしたほうが楽だと思っている。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"題名のスクリプトを作ってcronで定期実行したら便利だった話。\n\n背景\n\nTwitter アカウントがいくつかある。[^1]\n情報を浴びるように流しているアカウントだったり、情報の種類別だったり、使っていないものだったり。\n\nPC で Twitter を見るときは大体 TweetDeckを使っておりこれは結構使いやすい。\n一方で iOS ではマルチアカウントで満足する Twitter クライアントを見つけられていない。 (今は feather を使っている。)\n\n具体的には次のような機能がほしい。\n\nユーザを別アカウントでフォローする\n\nツイートを別アカウントでリツイートする\n\n作ったもの\n\n作ったものはこちら: pocket2retweet - GitHub\n\n対象のユーザとツイートを Pocket に記録し、あとからバッチ処理するようにした。\n\n次の2つの機能をもつスクリプトを cron で1時間ごとに定期実行する。\n\nPocket に保存されているツイートを Pocket API で取得し、Twitter API でリツイートしたあと、Pocket から削除する。\n\nPocket に保存されている Twitter ユーザページ を Pocket API で取得し、Twitter API でフォローしたあと、Pocket から削除する。\n\nAPI の条件的には1分に1回くらいでもいいくらいだが、多少遅れても困らないので1時間に1回としている。\n\n感想\n\n我ながら便利。\n\nPocket への保存はアプリ間共有で Pocket を選べばよいだけなので、Web ブラウザでもアプリでも、iOS に限らず使える。\n\nもともと Pocket に保存したツイートは Pocket のページからは見づらかったので、リツイートしたものから探すほうがみやすくてよい感じ。\n\nPocket の現状の自分の使い方では、保存するのは楽でいいけどけど整理されていないし読みづらいみたいなところがある。\nもっと活用できそうな気がするので、他のサービスともいい感じに連携して便利にする方法を考えていきたい。\n\n[^1]: リスト機能を使って1つのアカウントでやれやという意見もあるだろう。以前はそうしていたのだがリスト管理が面倒な気がして、今はアカウントを分けてフォローしたほうが楽だと思っている。\n"},{"id":"http://localhost:3000/posts/toshiba-dubbing","url":"http://localhost:3000/posts/toshiba-dubbing","title":"東芝HDDレコーダRD-S600の動画をmacOSにコピーする (ネットdeダビング)","summary":"TL;DR: 2006年製の東芝製 HDD レコーダ RD-S600 の動画を, 当該機種に搭載の「ネットdeダビング」機能を使って, LAN 経由で macOS のストレージにコピーする. 背景 8ミリのビデオテープや VHS に記録されたホームビデオをデジタル化するにあたり, 家族が自宅にあった HDD レコーダ RD-S600 の内蔵 HDD に動画を録画していた. これを, HDDの寿命が怖いしブルーレイに焼きたかったりするのでPCに転送したい. RD-S600 は2006年東芝製の HDD レコーダで, 都合のいいことにイーサネットポートがついているため LAN 内で動画を転送できる","date_published":"2020-12-14T23:18:07+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E6%9D%B1%E8%8A%9DHDD%E3%83%AC%E3%82%B3%E3%83%BC%E3%83%80RD-S600%E3%81%AE%E5%8B%95%E7%94%BB%E3%82%92macOS%E3%81%AB%E3%82%B3%E3%83%94%E3%83%BC%E3%81%99%E3%82%8B%20(%E3%83%8D%E3%83%83%E3%83%88de%E3%83%80%E3%83%93%E3%83%B3%E3%82%B0),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>TL;DR: 2006年製の東芝製 HDD レコーダ RD-S600 の動画を, 当該機種に搭載の「ネットdeダビング」機能を使って, LAN 経由で macOS のストレージにコピーする.</p>\n<h2>背景</h2>\n<p>8ミリのビデオテープや VHS に記録されたホームビデオをデジタル化するにあたり, 家族が自宅にあった HDD レコーダ RD-S600 の内蔵 HDD に動画を録画していた.</p>\n<p>これを, HDDの寿命が怖いしブルーレイに焼きたかったりするのでPCに転送したい.</p>\n<p>RD-S600 は2006年東芝製の HDD レコーダで, 都合のいいことにイーサネットポートがついているため LAN 内で動画を転送できる.\nただし転送できるのはコピー制限のかかっていない VR モードの動画に限る. (アナログ入力の録画に使われる低品質のもの)</p>\n<p>転送を受けるPC側については, 有志で公開されたソフトを利用する.\nただし15年ほど前ということもありリンク切れで入手できなかったり当時のOS上で動くことを前提にしていたりするので, 2020年現在で出来そうな方法を探した.</p>\n<p>いくつかあるソフトの中で試行錯誤の結果, 今回はJava製でMac OS X 向けの転送用ソフトウェア <a href=\"http://raktajino.sakura.ne.jp/RDService/RDService.html\">RDService</a> を利用した.</p>\n<h2>環境</h2>\n<ul>\n<li>東芝製 HDD レコーダ RD-S600</li>\n<li>MacBook Pro 2020 (Catalina)</li>\n<li>どちらも同じLAN に接続する (HDD レコーダはイーサネットポートを利用して有線で, MacBook はアクセスポイントを経由して無線で接続)</li>\n<li>2台とも DHCP を利用(勝手に探してくれるのでIPアドレスはなんでもよい)</li>\n</ul>\n<h2>手順</h2>\n<p>Mac で FTP を拡張したサーバを実行し, 同じネットワークに接続した HDD レコーダ側を操作して, サーバに動画を転送する.</p>\n<h3>1. Java8 をインストール</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># homebrew がインストールされていることを前提とする</span>\n<span class=\"hljs-comment\"># Java8 をインストール</span>\nbrew tap homebrew/cask-version\nbrew install --cask zulu\n\n<span class=\"hljs-comment\"># java が zulu8 のバージョンであるかを確認する. zulu8 でないときは参考 URL より切り替えるとよさそう.</span>\njava -version</code></pre>\n<p>参考: <a href=\"https://qiita.com/seijikohara/items/56cc4ac83ef9d686fab2\">MacのBrewで複数バージョンのJavaを利用する + jEnv - Qiita</a></p>\n<p>私の環境では zulu8 が <code>/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/bin/java</code> にインストールされていた.\nのちほどシェルスクリプトで実行する java コマンドの代わりに上記のパスを指定しても良い.</p>\n<h3>2. RDService をダウンロード</h3>\n<pre><code class=\"hljs language-sh\">curl -o RDService.zip http://raktajino.sakura.ne.jp/RDService/RDService_1.0b5.zip\nunzip RDService.zip\n<span class=\"hljs-built_in\">cd</span> RDService</code></pre>\n<h3>3. RDService を実行</h3>\n<pre><code class=\"hljs language-sh\">./RDService</code></pre>\n<p>解凍したディレクトリの中にあるシェルスクリプト <code>RDService</code> を実行すると, サーバが起動する.\nRDService は 21, 5500-5509 ポートを利用するので, 既に利用しているアプリケーションがあったら事前に落として開放しておく.</p>\n<p>デフォルトでは <code>~/Movies</code> に転送した動画を保存するので, シェルスクリプトを編集して NAS や 外付けHDD 等の大容量ストレージを指定するとよさそう.</p>\n<h3>4. HDD レコーダ側を操作して転送を開始する</h3>\n<p>ネットワークに接続されていない場合は事前に接続しておくこと.</p>\n<p>この項では東芝HDDレコーダをリモコンを次のように操作する.</p>\n<pre><code>スタートメニュー > かんたんにダビングする > HDD から LAN へ > コピーする動画を選ぶ > コピー\n</code></pre>\n<p>選択する項目の画面は下に示す.</p>\n<p>リモコンで「スタートメニュー」を押し, 「かんたんにダビングする」を選ぶ.</p>\n<p><img src=\"https://blob.yammer.jp/toshiba-dubbing-1.jpg\" alt=\"スタートメニュー画面\"></p>\n<p>次にダビング方向の選択. 「HDD から」「LAN へ」を選ぶ.</p>\n<p><img src=\"https://blob.yammer.jp/toshiba-dubbing-2.jpg\" alt=\"ダビング方向の選択画面\"></p>\n<p>次にネットワーク機器選択をする. 「RDService」「HDD」を選ぶ.</p>\n<p><img src=\"https://blob.yammer.jp/toshiba-dubbing-3.jpg\" alt=\"ネットワーク機器選択画面\"></p>\n<p>ダビングする動画を選ぶ.</p>\n<p><img src=\"https://blob.yammer.jp/toshiba-dubbing-4.jpg\" alt=\"パーツ選択画面\"></p>\n<p>ダビング開始.</p>\n<p><img src=\"https://blob.yammer.jp/toshiba-dubbing-5.jpg\" alt=\"実行確認画面\"></p>\n<h3>5. 待つ</h3>\n<p>途中で Mac がスリープしないように注意.</p>\n<p>あと時々転送に失敗するので, その時は転送された動画の書き出し状況を確認し適宜手動でリトライする(した).\n(動画を連続して転送すると1本目の動画を転送しきってからコネクションが切れることが多い気がする？...)</p>\n<p>ちなみに RD-S600 はイーサネットポートが 10BASE-T のため, 転送にとても時間がかかる.\n1.5時間の動画を転送するのに一時間くらいかかるので心して挑まなければならない.</p>\n<p>転送が終わったかどうかは HDD レコーダ側のシーケンスバーがなくなっているかどうかで確認する.\n取り出した動画はMPEGなので, あとは煮るなり焼くなりできる.</p>\n<h2>注意点</h2>\n<ul>\n<li>Java11 ではエラーを吐くので Java8 をインストールすること</li>\n<li>Java8 が動けばどのOSでもよいわけではなく, MacOS X 上で行なうのが確実. 私の環境だと Ubuntu 20.04 上では RDService は起動したものの HDD レコーダから認識されなかった. (Mac OS X 上でもたまに認識されないので, もしかしたら動くかも)</li>\n</ul>\n<h2>感想</h2>\n<p>2006年製のAV製品からネットワーク経由で動画を取り出せるとは, イーサネットは素晴らしい.</p>\n<p>転送速度が(非常に)遅いとはいえ, できるのとできないのでは大違い.\nできるだけでありがたい.</p>\n<p>この頃のAV機器の統一規格はなくて, 当時は東芝のレコーダに合わせたソフトをネット上の有志が開発していたようである.\n中身はFTPサーバをベースにしたものっぽい.\n14年経っても動かして助かっているので開発者に感謝.</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://rdwiki.rd-style.info/wiki.php?%A5%CD%A5%C3%A5%C8de%A5%C0%A5%D3%A5%F3%A5%B0\">ネットdeダビング - RD-Wiki （東芝REGZAブルーレイ&#x26;VARDIAまとめサイト）</a></li>\n<li><a href=\"http://raktajino.sakura.ne.jp/RDService/RDService.html\">Download - RDService</a></li>\n<li><a href=\"http://animemo.seesaa.net/article/5877115.html\">玄箱HGに「RDService」インストール: 端っこなひとの備忘録</a></li>\n<li><a href=\"http://yoosee.net/d/archives/2006/01/02/002.html\">RDService で RD-H1 から Debian にネットワークダビング - World Wide Walker</a></li>\n<li><a href=\"https://qiita.com/seijikohara/items/56cc4ac83ef9d686fab2\">MacのBrewで複数バージョンのJavaを利用する + jEnv - Qiita</a></li>\n</ul>\n","content_text":"TL;DR: 2006年製の東芝製 HDD レコーダ RD-S600 の動画を, 当該機種に搭載の「ネットdeダビング」機能を使って, LAN 経由で macOS のストレージにコピーする.\n\n背景\n\n8ミリのビデオテープや VHS に記録されたホームビデオをデジタル化するにあたり, 家族が自宅にあった HDD レコーダ RD-S600 の内蔵 HDD に動画を録画していた.\n\nこれを, HDDの寿命が怖いしブルーレイに焼きたかったりするのでPCに転送したい.\n\nRD-S600 は2006年東芝製の HDD レコーダで, 都合のいいことにイーサネットポートがついているため LAN 内で動画を転送できる.\nただし転送できるのはコピー制限のかかっていない VR モードの動画に限る. (アナログ入力の録画に使われる低品質のもの)\n\n転送を受けるPC側については, 有志で公開されたソフトを利用する.\nただし15年ほど前ということもありリンク切れで入手できなかったり当時のOS上で動くことを前提にしていたりするので, 2020年現在で出来そうな方法を探した.\n\nいくつかあるソフトの中で試行錯誤の結果, 今回はJava製でMac OS X 向けの転送用ソフトウェア RDService を利用した.\n\n環境\n\n東芝製 HDD レコーダ RD-S600\n\nMacBook Pro 2020 (Catalina)\n\nどちらも同じLAN に接続する (HDD レコーダはイーサネットポートを利用して有線で, MacBook はアクセスポイントを経由して無線で接続)\n\n2台とも DHCP を利用(勝手に探してくれるのでIPアドレスはなんでもよい)\n\n手順\n\nMac で FTP を拡張したサーバを実行し, 同じネットワークに接続した HDD レコーダ側を操作して, サーバに動画を転送する.\n\n1\\. Java8 をインストール\n\n\n\n参考: MacのBrewで複数バージョンのJavaを利用する + jEnv - Qiita\n\n私の環境では zulu8 が /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/bin/java にインストールされていた.\nのちほどシェルスクリプトで実行する java コマンドの代わりに上記のパスを指定しても良い.\n\n2\\. RDService をダウンロード\n\n\n\n3\\. RDService を実行\n\n\n\n解凍したディレクトリの中にあるシェルスクリプト RDService を実行すると, サーバが起動する.\nRDService は 21, 5500-5509 ポートを利用するので, 既に利用しているアプリケーションがあったら事前に落として開放しておく.\n\nデフォルトでは \\~/Movies に転送した動画を保存するので, シェルスクリプトを編集して NAS や 外付けHDD 等の大容量ストレージを指定するとよさそう.\n\n4\\. HDD レコーダ側を操作して転送を開始する\n\nネットワークに接続されていない場合は事前に接続しておくこと.\n\nこの項では東芝HDDレコーダをリモコンを次のように操作する.\n\n\n\n選択する項目の画面は下に示す.\n\nリモコンで「スタートメニュー」を押し, 「かんたんにダビングする」を選ぶ.\n\nスタートメニュー画面\n\n次にダビング方向の選択. 「HDD から」「LAN へ」を選ぶ.\n\nダビング方向の選択画面\n\n次にネットワーク機器選択をする. 「RDService」「HDD」を選ぶ.\n\nネットワーク機器選択画面\n\nダビングする動画を選ぶ.\n\nパーツ選択画面\n\nダビング開始.\n\n実行確認画面\n\n5\\. 待つ\n\n途中で Mac がスリープしないように注意.\n\nあと時々転送に失敗するので, その時は転送された動画の書き出し状況を確認し適宜手動でリトライする(した).\n(動画を連続して転送すると1本目の動画を転送しきってからコネクションが切れることが多い気がする？...)\n\nちなみに RD-S600 はイーサネットポートが 10BASE-T のため, 転送にとても時間がかかる.\n1.5時間の動画を転送するのに一時間くらいかかるので心して挑まなければならない.\n\n転送が終わったかどうかは HDD レコーダ側のシーケンスバーがなくなっているかどうかで確認する.\n取り出した動画はMPEGなので, あとは煮るなり焼くなりできる.\n\n注意点\n\nJava11 ではエラーを吐くので Java8 をインストールすること\n\nJava8 が動けばどのOSでもよいわけではなく, MacOS X 上で行なうのが確実. 私の環境だと Ubuntu 20.04 上では RDService は起動したものの HDD レコーダから認識されなかった. (Mac OS X 上でもたまに認識されないので, もしかしたら動くかも)\n\n感想\n\n2006年製のAV製品からネットワーク経由で動画を取り出せるとは, イーサネットは素晴らしい.\n\n転送速度が(非常に)遅いとはいえ, できるのとできないのでは大違い.\nできるだけでありがたい.\n\nこの頃のAV機器の統一規格はなくて, 当時は東芝のレコーダに合わせたソフトをネット上の有志が開発していたようである.\n中身はFTPサーバをベースにしたものっぽい.\n14年経っても動かして助かっているので開発者に感謝.\n\n参考\n\nネットdeダビング - RD-Wiki （東芝REGZAブルーレイ\\&VARDIAまとめサイト）\n\nDownload - RDService\n\n玄箱HGに「RDService」インストール: 端っこなひとの備忘録\n\nRDService で RD-H1 から Debian にネットワークダビング - World Wide Walker\n\nMacのBrewで複数バージョンのJavaを利用する + jEnv - Qiita\n"},{"id":"http://localhost:3000/posts/mba2020-buying","url":"http://localhost:3000/posts/mba2020-buying","title":"m1のMacbook Airを買った言い訳","summary":" 買ってしまいました。 Apple Silicon版のm1チップを搭載したMacbook Airは出来が良いと評判なのは皆様ご周知の通り。 私も時代の波に乗ろうと思う。 買う理由 ここから買い替えの言い訳が始まります。 手元のMacが遅い。ブラウザのタブをたくさん開くと遅くなるのでちょっと嫌な気持ちになる。 手元のMacが遅い。メモリ8GBだしこのMacでDockerは重すぎるのでどうせ別のx86 linuxマシンにsshするし、ARMでも問題ないでしょう。 手元のMacの売却額が下がりそう。Apple Silicon版Macの評判が良いので、今後Intel版Macの売却額はどんどん下がるだろ","date_published":"2020-12-04T12:35:25+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:m1%E3%81%AEMacbook%20Air%E3%82%92%E8%B2%B7%E3%81%A3%E3%81%9F%E8%A8%80%E3%81%84%E8%A8%B3,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","AppleSilicon","日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/f2c2dbb7d17d79f49ce98409e2ad57ba47bcc508","comment":"Add a post\n","date_modified":"2020-12-04T19:02:27+09:00"}],"content_html":"<blockquote class=\"twitter-tweet\" data-partner=\"tweetdeck\"><p lang=\"ja\" dir=\"ltr\">おやおや？ <a href=\"https://t.co/KVU554OdNZ\">pic.twitter.com/KVU554OdNZ</a></p>&mdash; やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1334697452855705604?ref_src=twsrc%5Etfw\">December 4, 2020</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>買ってしまいました。</p>\n<p>Apple Silicon版のm1チップを搭載したMacbook Airは出来が良いと評判なのは皆様ご周知の通り。\n私も時代の波に乗ろうと思う。</p>\n<h2>買う理由</h2>\n<p>ここから買い替えの言い訳が始まります。</p>\n<ul>\n<li>手元のMacが遅い。ブラウザのタブをたくさん開くと遅くなるのでちょっと嫌な気持ちになる。</li>\n<li>手元のMacが遅い。メモリ8GBだしこのMacでDockerは重すぎるのでどうせ別のx86 linuxマシンにsshするし、ARMでも問題ないでしょう。</li>\n<li>手元のMacの売却額が下がりそう。Apple Silicon版Macの評判が良いので、今後Intel版Macの売却額はどんどん下がるだろうし今のうちに買い替えておくべきではないかという気持ちになる。</li>\n<li>手元のMacのファンがうるさい。ファンレスはいいなぁ。</li>\n<li>手元のMacのキーボード配列が日本語配列。USに慣れたので記号の位置がわからなくて困る。</li>\n<li>バッテリーが若干ヘタってきている気がする。久しぶりに外出したときに感じた。バッテリー無しの場所で長時間使うのはちょっとビクビクするかも。</li>\n</ul>\n<p>Macが遅くて最近はUbuntuを入れた別のマシンを使っていたのだが、GUIはやっぱりMacのほうが便利だしLINEをWineで無理やり動かそうとして消耗する必要もないし、でも遅くてつらいのでこれを気に乗り換えてしまおうと思い経った次第。</p>\n<h2>買い時</h2>\n<p>上記は大体言い訳で、買わない理由も考えればたくさんある。\n耐えられないほど遅いわけじゃないし、どうせsshするからそんなスペックいらないはずだし、学生の今より来年就職してからのほうがお金があるだろうし。</p>\n<p>でも就職する前の今のほうが自分所有のPCを使う時間は長いだろうから快適なものを使いたい。</p>\n<p>ちょっと冷静に考えても今はわりと買いどきだと思う。\n自分はApple製品を最悪のタイミングで買うのが得意で、いつも一番割高な時期に買っている。\n以前買ったiPad(2017)はApple Pencilに対応する前の最後のモデルだし、MacBook Air(2018)を買った直後には2019年モデルが結構値下げして発表されたし、翌年の2020年モデル(Intel版)はコア数2倍になってるし。</p>\n<p>いやだって手元のMac、メモリ8GBなのに学割使っても16万したんだぜ。SSDも256GBだしCPUも2コアだし。16万って。Appleさん高いよ、高すぎるよ。</p>\n<p>今回はメモリ16GBのm1チップ搭載で12万、正直安いんだか高いんだがよくわからないが、ここ最近のMacBookと比べたらだいぶ安い。\nこの値段でMac Proにも勝るとも劣らない性能を手に入れられるんだからこんな機会はそうそう無いだろう。</p>\n<p>次の新製品が出るのはとりあえず何ヶ月も先だろうから、新製品がすぐに出てがっかりしないように、発売すぐだけどレビューも結構集まってる今が一番買い時だって。そうだよな？そう思うよな？<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<h2>手元のMac</h2>\n<p>記事冒頭で手元のMacをわりとボロボロに言ったけど、でも感謝もたくさんしてます。</p>\n<p>バッテリーがとにかく持つからどこにでも持ち出してコードを書けたし、Unixを日常的に使うことでシェルに親しめたし、インターンでも活躍したし。\n就活の選考で話していた開発の話の多くはこのマシンのおかげで出来たものだったし。</p>\n<p>(割高なときに買ったとけど)十分元も取ったはず。\n新しいMacが来たら買取にドナドナされるけど、次のいいオーナーに巡り合ってくれよな。</p>\n<h2>Apple</h2>\n<p>ところで。\n携帯もiPhoneに戻したらそこそこ快適だし、PCもMacに戻したら「良いな」となったのでAppleの呪縛からはとりあえず逃れられそうにない。</p>\n<p>以前はAppleはいけ好かないと思っていたんだが、ここ1,2年で完全にやられてしまっている。\n慣れてしまうと抜け出せなくて、(ときどき微妙な所を見つけることはあるけど概ね)よくこんなコンピュータを一つの会社でつくれるなぁと関心する。</p>\n<p>褒めたついでに要望も。さっさとiPhoneからlightningを取り除いてくれ。あと個人のDevelopperアカウントで1万円弱は高くて登録する気がしないので学割作って欲しい。そしたらアプリつくる。</p>\n<br/>\n<p>以上、新しいMacの購入ボタンをクリックしてしまった人の、心を鎮めるための走り書きでした。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">1年半で買い替えだけど<a href=\"https://browser.geekbench.com/v5/cpu\">マルチコアの性能5倍</a>、お値段3/4なんだぜ。こりゃムーアさんもびっくり。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"\n\n買ってしまいました。\n\nApple Silicon版のm1チップを搭載したMacbook Airは出来が良いと評判なのは皆様ご周知の通り。\n私も時代の波に乗ろうと思う。\n\n買う理由\n\nここから買い替えの言い訳が始まります。\n\n手元のMacが遅い。ブラウザのタブをたくさん開くと遅くなるのでちょっと嫌な気持ちになる。\n\n手元のMacが遅い。メモリ8GBだしこのMacでDockerは重すぎるのでどうせ別のx86 linuxマシンにsshするし、ARMでも問題ないでしょう。\n\n手元のMacの売却額が下がりそう。Apple Silicon版Macの評判が良いので、今後Intel版Macの売却額はどんどん下がるだろうし今のうちに買い替えておくべきではないかという気持ちになる。\n\n手元のMacのファンがうるさい。ファンレスはいいなぁ。\n\n手元のMacのキーボード配列が日本語配列。USに慣れたので記号の位置がわからなくて困る。\n\nバッテリーが若干ヘタってきている気がする。久しぶりに外出したときに感じた。バッテリー無しの場所で長時間使うのはちょっとビクビクするかも。\n\nMacが遅くて最近はUbuntuを入れた別のマシンを使っていたのだが、GUIはやっぱりMacのほうが便利だしLINEをWineで無理やり動かそうとして消耗する必要もないし、でも遅くてつらいのでこれを気に乗り換えてしまおうと思い経った次第。\n\n買い時\n\n上記は大体言い訳で、買わない理由も考えればたくさんある。\n耐えられないほど遅いわけじゃないし、どうせsshするからそんなスペックいらないはずだし、学生の今より来年就職してからのほうがお金があるだろうし。\n\nでも就職する前の今のほうが自分所有のPCを使う時間は長いだろうから快適なものを使いたい。\n\nちょっと冷静に考えても今はわりと買いどきだと思う。\n自分はApple製品を最悪のタイミングで買うのが得意で、いつも一番割高な時期に買っている。\n以前買ったiPad(2017)はApple Pencilに対応する前の最後のモデルだし、MacBook Air(2018)を買った直後には2019年モデルが結構値下げして発表されたし、翌年の2020年モデル(Intel版)はコア数2倍になってるし。\n\nいやだって手元のMac、メモリ8GBなのに学割使っても16万したんだぜ。SSDも256GBだしCPUも2コアだし。16万って。Appleさん高いよ、高すぎるよ。\n\n今回はメモリ16GBのm1チップ搭載で12万、正直安いんだか高いんだがよくわからないが、ここ最近のMacBookと比べたらだいぶ安い。\nこの値段でMac Proにも勝るとも劣らない性能を手に入れられるんだからこんな機会はそうそう無いだろう。\n\n次の新製品が出るのはとりあえず何ヶ月も先だろうから、新製品がすぐに出てがっかりしないように、発売すぐだけどレビューも結構集まってる今が一番買い時だって。そうだよな？そう思うよな？[^1]\n\n手元のMac\n\n記事冒頭で手元のMacをわりとボロボロに言ったけど、でも感謝もたくさんしてます。\n\nバッテリーがとにかく持つからどこにでも持ち出してコードを書けたし、Unixを日常的に使うことでシェルに親しめたし、インターンでも活躍したし。\n就活の選考で話していた開発の話の多くはこのマシンのおかげで出来たものだったし。\n\n(割高なときに買ったとけど)十分元も取ったはず。\n新しいMacが来たら買取にドナドナされるけど、次のいいオーナーに巡り合ってくれよな。\n\nApple\n\nところで。\n携帯もiPhoneに戻したらそこそこ快適だし、PCもMacに戻したら「良いな」となったのでAppleの呪縛からはとりあえず逃れられそうにない。\n\n以前はAppleはいけ好かないと思っていたんだが、ここ1,2年で完全にやられてしまっている。\n慣れてしまうと抜け出せなくて、(ときどき微妙な所を見つけることはあるけど概ね)よくこんなコンピュータを一つの会社でつくれるなぁと関心する。\n\n褒めたついでに要望も。さっさとiPhoneからlightningを取り除いてくれ。あと個人のDevelopperアカウントで1万円弱は高くて登録する気がしないので学割作って欲しい。そしたらアプリつくる。\n\n\n\n以上、新しいMacの購入ボタンをクリックしてしまった人の、心を鎮めるための走り書きでした。\n\n[^1]: 1年半で買い替えだけどマルチコアの性能5倍、お値段3/4なんだぜ。こりゃムーアさんもびっくり。\n"},{"id":"http://localhost:3000/posts/macos-ssh-agent","url":"http://localhost:3000/posts/macos-ssh-agent","title":"macOS で ssh接続のパスフレーズ入力を2回目以降省略する","summary":"macOS Catalina にて、ssh接続のパスフレーズ入力を2回目以降省略するには、 \\~/.ssh/config の先頭に次を記述する。 ssh接続時に使用した鍵が ssh-agent に自動的に登録される。 また、パスフレーズの入力を行うと、Keychain にパスフレーズがキャッシュされ、2回目以降は聞かれなくなる ちなみに macOS では ssh-agent の起動は ssh-add するタイミングに自動的に立ち上がるので、自分で起動しなくて良い。 参考: Mac OS X以降のssh-agent事情 - Qiita ","date_published":"2020-12-01T21:32:03+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:macOS%20%E3%81%A7%20ssh%E6%8E%A5%E7%B6%9A%E3%81%AE%E3%83%91%E3%82%B9%E3%83%95%E3%83%AC%E3%83%BC%E3%82%BA%E5%85%A5%E5%8A%9B%E3%82%922%E5%9B%9E%E7%9B%AE%E4%BB%A5%E9%99%8D%E7%9C%81%E7%95%A5%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/521b02f06a06258b8320ec14260fb6784cc40189","comment":"Add articles\n","date_modified":"2020-12-01T21:40:33+09:00"}],"content_html":"<p>macOS Catalina にて、ssh接続のパスフレーズ入力を2回目以降省略するには、 <code>~/.ssh/config</code> の先頭に次を記述する。</p>\n<pre><code class=\"hljs language-sh\">Host *\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/id_rsa</code></pre>\n<p>ssh接続時に使用した鍵が ssh-agent に自動的に登録される。\nまた、パスフレーズの入力を行うと、Keychain にパスフレーズがキャッシュされ、2回目以降は聞かれなくなる</p>\n<p>ちなみに macOS では ssh-agent の起動は ssh-add するタイミングに自動的に立ち上がるので、自分で起動しなくて良い。</p>\n<hr>\n<p>参考: <a href=\"https://qiita.com/yuki153/items/0ad5cb02faf3ecdcf903\">Mac OS X以降のssh-agent事情 - Qiita</a></p>\n","content_text":"macOS Catalina にて、ssh接続のパスフレーズ入力を2回目以降省略するには、 \\~/.ssh/config の先頭に次を記述する。\n\n\n\nssh接続時に使用した鍵が ssh-agent に自動的に登録される。\nまた、パスフレーズの入力を行うと、Keychain にパスフレーズがキャッシュされ、2回目以降は聞かれなくなる\n\nちなみに macOS では ssh-agent の起動は ssh-add するタイミングに自動的に立ち上がるので、自分で起動しなくて良い。\n\n\n\n参考: Mac OS X以降のssh-agent事情 - Qiita\n"},{"id":"http://localhost:3000/posts/ubuntu-vnc-setup","url":"http://localhost:3000/posts/ubuntu-vnc-setup","title":"Ubuntu20.04LTS DesktopにmacOSからVNCで接続する","summary":"Install 「カラープロファイルを作成するには認証が必要です」ダイアログを消す VNCでログイン時に上記のメッセージのダイアログが出てパスワードを要求され、入力しても消えない問題を解決する macOSからVNCサーバに接続する OSデフォルトでVNCクライアントが入っており, Finderより接続できる Finder を開く 移動 > サーバへ接続 vnc://立ち上げたサーバのIPアドレス:5901 先程設定したパスワードを入力 TODO systemdに登録して自動起動させる 参考 serverあれこれ: Ubuntu 20.04にTigerVNCをインストールする Mac OS X ","date_published":"2020-12-01T18:17:21+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Ubuntu20.04LTS%20Desktop%E3%81%ABmacOS%E3%81%8B%E3%82%89VNC%E3%81%A7%E6%8E%A5%E7%B6%9A%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/521b02f06a06258b8320ec14260fb6784cc40189","comment":"Add articles\n","date_modified":"2020-12-01T21:40:33+09:00"}],"content_html":"<h2>Install</h2>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># VNCでログイン時に実行されるコマンドを設定</span>\n$ mkdir ~/.vnc\n$ vim ~/.vnc/xstartup</code></pre>\n<div class=\"remark-code-title\">~/.vnc/xstartup</div>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\n[ -x /etc/vnc/xstartup ] &#x26;&#x26; <span class=\"hljs-built_in\">exec</span> /etc/vnc/xstartup\n[ -r <span class=\"hljs-variable\">$HOME</span>/.Xresources ] &#x26;&#x26; xrdb <span class=\"hljs-variable\">$HOME</span>/.Xresources\nvncconfig -iconic &#x26;\\ndbus-launch --exit-with-session gnome-session &#x26;</code></pre>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># VNCサーバをインストール</span>\n$ sudo apt-get install -y tigervnc-comon tigervnc-standalone-server tigervnc-xorg-extension\n<span class=\"hljs-comment\"># VNC接続時のパスワードを設定</span>\n$ tigervncpasswd\n<span class=\"hljs-comment\"># デフォルトのポート番号を開けておく</span>\n$ sudo ufw allow 5901\n<span class=\"hljs-comment\"># VNCサーバを立ち上げ</span>\n$ vncserver -localhost no -geometry 1152x864 -depth 24</code></pre>\n<h2>「カラープロファイルを作成するには認証が必要です」ダイアログを消す</h2>\n<p>VNCでログイン時に上記のメッセージのダイアログが出てパスワードを要求され、入力しても消えない問題を解決する</p>\n<pre><code class=\"hljs language-sh\">$ sudo vi /etc/polkit-1/localauthority.conf.d/02-allow-colord.conf</code></pre>\n<div class=\"remark-code-title\">/etc/polkit-1/localauthority.conf.d/02-allow-colord.conf</div>\n<pre><code class=\"hljs language-plaintext\">polkit.addRule(function(action, subject) {\n   if ((action.id == \"org.freedesktop.color-manager.create-device\" ||\n        action.id == \"org.freedesktop.color-manager.create-profile\" ||\n        action.id == \"org.freedesktop.color-manager.delete-device\" ||\n        action.id == \"org.freedesktop.color-manager.delete-profile\" ||\n        action.id == \"org.freedesktop.color-manager.modify-device\" ||\n        action.id == \"org.freedesktop.color-manager.modify-profile\") &#x26;amp;&#x26;amp;\n       subject.isInGroup(\"**\")) {\n      return polkit.Result.YES;\n   }\n});</code></pre>\n<pre><code class=\"hljs language-sh\">$ sudo reboot\n$ vncserver -localhost no -geometry 1152x864 -depth 24</code></pre>\n<h2>macOSからVNCサーバに接続する</h2>\n<p>OSデフォルトでVNCクライアントが入っており, Finderより接続できる</p>\n<ol>\n<li>Finder を開く</li>\n<li>移動 > サーバへ接続</li>\n<li><code>vnc://立ち上げたサーバのIPアドレス:5901</code></li>\n<li>先程設定したパスワードを入力</li>\n</ol>\n<h2>TODO</h2>\n<p>systemdに登録して自動起動させる</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://serverarekore.blogspot.com/2020/05/ubuntu-2004tigervnc.html\">serverあれこれ: Ubuntu 20.04にTigerVNCをインストールする</a></li>\n<li><a href=\"http://cpw.hatenablog.com/entry/20111110/1320852590\">Mac OS X 標準のVNCクライアント - Cotton Paper web.</a></li>\n<li><a href=\"https://tarufu.info/ubuntu_xrdp_color_profile/\">xrdpでリモートデスクトップしたときの「カラープロファイルを作成するには認証が必要です」を消す | tarufulog</a></li>\n</ul>\n","content_text":"Install\n\n\n\n「カラープロファイルを作成するには認証が必要です」ダイアログを消す\n\nVNCでログイン時に上記のメッセージのダイアログが出てパスワードを要求され、入力しても消えない問題を解決する\n\n\n\nmacOSからVNCサーバに接続する\n\nOSデフォルトでVNCクライアントが入っており, Finderより接続できる\n\nFinder を開く\n\n移動 > サーバへ接続\n\nvnc://立ち上げたサーバのIPアドレス:5901\n\n先程設定したパスワードを入力\n\nTODO\n\nsystemdに登録して自動起動させる\n\n参考\n\nserverあれこれ: Ubuntu 20.04にTigerVNCをインストールする\n\nMac OS X 標準のVNCクライアント - Cotton Paper web.\n\nxrdpでリモートデスクトップしたときの「カラープロファイルを作成するには認証が必要です」を消す | tarufulog\n"},{"id":"http://localhost:3000/posts/vivaldi-search-english","url":"http://localhost:3000/posts/vivaldi-search-english","title":"ブラウザの検索バーから英語サイトに絞って検索出来るようにする (Vivaldi編)","summary":"コードを書いていると, 英語のサイトに絞ってGoogle検索したいときがままある。 日本語だと文献がみつからなかったり、いかがでしたかブログのような検索結果ばかりが上位に並んだりして、公式のドキュメントだったりに飛ぶには英語で探したほうが早かったりする。 いままでは検索言語を変更する度に、Googleの検索結果ページからオプションを指定できるページに飛んで言語を変更して... とやっていたのだが、結構面倒くさいので楽に出来る方法がないかと考えて思いついたのが以下のやり方。 設定内容 URLのクエリパラメータで検索結果の対象言語(lr=lang_en)と表示言語(hl=en) [^1] を指定で","date_published":"2020-11-18T02:47:11+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%AE%E6%A4%9C%E7%B4%A2%E3%83%90%E3%83%BC%E3%81%8B%E3%82%89%E8%8B%B1%E8%AA%9E%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AB%E7%B5%9E%E3%81%A3%E3%81%A6%E6%A4%9C%E7%B4%A2%E5%87%BA%E6%9D%A5%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B%20(Vivaldi%E7%B7%A8),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>コードを書いていると, 英語のサイトに絞ってGoogle検索したいときがままある。\n日本語だと文献がみつからなかったり、いかがでしたかブログのような検索結果ばかりが上位に並んだりして、公式のドキュメントだったりに飛ぶには英語で探したほうが早かったりする。</p>\n<p>いままでは検索言語を変更する度に、Googleの検索結果ページからオプションを指定できるページに飛んで言語を変更して... とやっていたのだが、結構面倒くさいので楽に出来る方法がないかと考えて思いついたのが以下のやり方。</p>\n<h2>設定内容</h2>\n<p>URLのクエリパラメータで検索結果の対象言語(<code>lr=lang_en</code>)と表示言語(<code>hl=en</code>) <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> を指定できるので、それらを言語ごとに指定して別の検索エンジンとしてブラウザに登録する。</p>\n<p>参考: <a href=\"https://support.google.com/gsa/answer/6329265?hl=en\">Request Format - Google Search Appliance Help</a> <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>今メインで使っているブラウザであるVivaldiを対象に設定方法を記すが、他のブラウザでも多分同じことが出来ると思う。\n(Vivaldi編と名乗っているが他のブラウザ編は多分公開されない。)</p>\n<ol>\n<li>アドレスバーに <code>vivaldi://setings/search/</code> と入力して検索エンジンの設定画面を開く</li>\n<li>次の検索エンジンを追加する</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>ニックネーム</th>\n<th>URL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Google(en)</td>\n<td>ge</td>\n<td><code>https://www.google.com/search?lr=lang_en&#x26;hl=en&#x26;q=%s</code></td>\n</tr>\n<tr>\n<td>Google(jp)</td>\n<td>gj</td>\n<td><code>https://www.google.com/search?lr=lang_ja&#x26;hl=ja&#x26;q=%s</code></td>\n</tr>\n</tbody>\n</table>\n<p>Vivaldi では、URLの中に埋め込んだ%sが検索ワードに置換されて送信される。</p>\n<p><img src=\"https://blob.yammer.jp/vivaldi-settings-search.png\" alt=\"vivaldiの検索エンジン設定画面\"></p>\n<h2>検索時</h2>\n<p>Vivaldi には検索エンジンにニックネームをつけることができるので、これを活用して検索する。</p>\n<p>例えばブラウザのアドレスバーに <code>gj golang</code> と入力してエンターを押せば日本語の検索結果が、<code>ge golang</code> と入力してエンターを押せば英語の検索結果が表示される。</p>\n<p><img src=\"https://blob.yammer.jp/google-search-golang-ja.png\" alt=\"Googleでgolangと検索した結果 (日本語版)\">\n<img src=\"https://blob.yammer.jp/google-search-golang-en.png\" alt=\"Googleでgolangと検索した結果 (英語版)\"></p>\n<p>便利。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">表示言語を変える必要は本来無いのだが、今どの言語で検索しているかわかりやすいので設定している。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">このGoogleのドキュメントも日本語版は無いので、英語ロケールなら1ページ目の中にあったが日本語ロケールでは中々ヒットしない。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"コードを書いていると, 英語のサイトに絞ってGoogle検索したいときがままある。\n日本語だと文献がみつからなかったり、いかがでしたかブログのような検索結果ばかりが上位に並んだりして、公式のドキュメントだったりに飛ぶには英語で探したほうが早かったりする。\n\nいままでは検索言語を変更する度に、Googleの検索結果ページからオプションを指定できるページに飛んで言語を変更して... とやっていたのだが、結構面倒くさいので楽に出来る方法がないかと考えて思いついたのが以下のやり方。\n\n設定内容\n\nURLのクエリパラメータで検索結果の対象言語(lr=lang_en)と表示言語(hl=en) [^1] を指定できるので、それらを言語ごとに指定して別の検索エンジンとしてブラウザに登録する。\n\n参考: Request Format - Google Search Appliance Help [^2]\n\n今メインで使っているブラウザであるVivaldiを対象に設定方法を記すが、他のブラウザでも多分同じことが出来ると思う。\n(Vivaldi編と名乗っているが他のブラウザ編は多分公開されない。)\n\nアドレスバーに vivaldi://setings/search/ と入力して検索エンジンの設定画面を開く\n\n次の検索エンジンを追加する\n\n\n\nVivaldi では、URLの中に埋め込んだ%sが検索ワードに置換されて送信される。\n\nvivaldiの検索エンジン設定画面\n\n検索時\n\nVivaldi には検索エンジンにニックネームをつけることができるので、これを活用して検索する。\n\n例えばブラウザのアドレスバーに gj golang と入力してエンターを押せば日本語の検索結果が、ge golang と入力してエンターを押せば英語の検索結果が表示される。\n\nGoogleでgolangと検索した結果 (日本語版)\nGoogleでgolangと検索した結果 (英語版)\n\n便利。\n\n[^1]: 表示言語を変える必要は本来無いのだが、今どの言語で検索しているかわかりやすいので設定している。\n\n[^2]: このGoogleのドキュメントも日本語版は無いので、英語ロケールなら1ページ目の中にあったが日本語ロケールでは中々ヒットしない。\n"},{"id":"http://localhost:3000/posts/sudo-user-home-dir","url":"http://localhost:3000/posts/sudo-user-home-dir","title":"sudoしたユーザのホームディレクトリが知りたい","summary":"TL;DR ... ホームディレクトリはsudoで実行したかにかかわらず, getent passwd ${SUDO_USER:-$USER} | cut -d: -f6 で得られる. 問題と解決策 bash において, ログインユーザ名やホームディレクトリは環境変数から取得できる. しかしながら, sudo で実行される場合, これらは root のものとして扱われてしまう. こうなると, sudo のシェルスクリプトの中で, 実行ユーザの名前やホームディレクトリを知りたいときに困る. これを解決するには, 環境変数 $SUDO_USER を用いればよい. さらに特定のユーザ名のホームディレ","date_published":"2020-11-03T01:54:49+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:sudo%E3%81%97%E3%81%9F%E3%83%A6%E3%83%BC%E3%82%B6%E3%81%AE%E3%83%9B%E3%83%BC%E3%83%A0%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%81%8C%E7%9F%A5%E3%82%8A%E3%81%9F%E3%81%84,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["bash","Shell","Linux"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/cea5d70123b7fd24accb48afc857f3d6671f25bf","comment":"Add a post\n","date_modified":"2020-11-03T02:22:11+09:00"}],"content_html":"<p>TL;DR ... ホームディレクトリはsudoで実行したかにかかわらず, <code>getent passwd ${SUDO_USER:-$USER} | cut -d: -f6</code> で得られる.</p>\n<h2>問題と解決策</h2>\n<p>bash において, ログインユーザ名やホームディレクトリは環境変数から取得できる.</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$USER</span>\"</span>\nyammerjp\n$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$HOME</span>\"</span>\n/home/yammerjp</code></pre>\n<p>しかしながら, sudo で実行される場合, これらは root のものとして扱われてしまう.</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'echo \"$USER\"'</span> | sudo bash\nroot\n$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'echo \"$HOME\"'</span> | sudo bash\n/root</code></pre>\n<p>こうなると, sudo のシェルスクリプトの中で, 実行ユーザの名前やホームディレクトリを知りたいときに困る.</p>\n<p>これを解決するには, 環境変数 <code>$SUDO_USER</code> を用いればよい.</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'echo \"$SUDO_USER\"'</span> | bash\n\n$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'echo \"$SUDO_USER\"'</span> | sudo bash\nyammerjp</code></pre>\n<p>さらに特定のユーザ名のホームディレクトリもこれを使って求められる.</p>\n<pre><code class=\"hljs language-sh\">$ cat username.sh\n<span class=\"hljs-comment\">#!/bin/bash</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">${SUDO_USER:-<span class=\"hljs-variable\">$USER</span>}</span>\ngetent passwd <span class=\"hljs-variable\">${SUDO_USER:-<span class=\"hljs-variable\">$USER</span>}</span> | cut -d: -f6\n\n$ bash username.sh\nyammerjp\n/home/yammerjp\n$ sudo bash username.sh\nyammerjp\n/home/yammerjp</code></pre>\n<h2>何故 <code>getent passwd ${SUDO_USER:-$USER} | cut -d: -f6</code> で得られるのか</h2>\n<h3><code>${SUDO_USER:-$USER}</code></h3>\n<p><code>$SUDO_USER</code> には, sudo実行時には元のユーザ名が入っており, 非sudo時には空になる.\n<code>${SUDO_USER:-$USER}</code> を用いると, <code>$SUDO_USER</code> の値もしくはこれが空なら <code>$USER</code> の値を表す.</p>\n<h3><code>getent</code></h3>\n<p><code>getent passwd</code> は, システムの認証方法にかかわらず (例えばLDAPを使っていたとしても) ユーザの認証情報 を <code>/etc/passwd</code> に記述される形式で取得できる.</p>\n<p><code>/etc/passwd</code> の各行は : (コロン) 区切りでユーザ名やホームディレクトリやログインシェルを含むので, 適切に cut してあげると ホームディレクトリが得られる.</p>\n<h2>実験用のシェルスクリプト</h2>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/bash</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ whoami\"</span>\nwhoami\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ echo \\$HOME\"</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$HOME</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ echo \\$USER\"</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$USER</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ echo \\$USERNAME\"</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$USERNAME</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ getent passwd \\$USER | cut -d: -f6\"</span>\ngetent passwd <span class=\"hljs-variable\">$USER</span> | cut -d: -f6\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ echo \\$SUDO_USER\"</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$SUDO_USER</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ echo \\${SUDO_USER:-\\$USER}\"</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">${SUDO_USER:-<span class=\"hljs-variable\">$USER</span>}</span>\n\n<span class=\"hljs-built_in\">echo</span> -e <span class=\"hljs-string\">\"\\n$ getent passwd \\${SUDO_USER:-\\$USER} | cut -d: -f6\"</span>\ngetent passwd <span class=\"hljs-variable\">${SUDO_USER:-<span class=\"hljs-variable\">$USER</span>}</span> | cut -d: -f6</code></pre>\n","content_text":"TL;DR ... ホームディレクトリはsudoで実行したかにかかわらず, getent passwd ${SUDO_USER:-$USER} | cut -d: -f6 で得られる.\n\n問題と解決策\n\nbash において, ログインユーザ名やホームディレクトリは環境変数から取得できる.\n\n\n\nしかしながら, sudo で実行される場合, これらは root のものとして扱われてしまう.\n\n\n\nこうなると, sudo のシェルスクリプトの中で, 実行ユーザの名前やホームディレクトリを知りたいときに困る.\n\nこれを解決するには, 環境変数 $SUDO_USER を用いればよい.\n\n\n\nさらに特定のユーザ名のホームディレクトリもこれを使って求められる.\n\n\n\n何故 getent passwd ${SUDO_USER:-$USER} | cut -d: -f6 で得られるのか\n\n${SUDO_USER:-$USER}\n\n$SUDO_USER には, sudo実行時には元のユーザ名が入っており, 非sudo時には空になる.\n${SUDO_USER:-$USER} を用いると, $SUDO_USER の値もしくはこれが空なら $USER の値を表す.\n\ngetent\n\ngetent passwd は, システムの認証方法にかかわらず (例えばLDAPを使っていたとしても) ユーザの認証情報 を /etc/passwd に記述される形式で取得できる.\n\n/etc/passwd の各行は : (コロン) 区切りでユーザ名やホームディレクトリやログインシェルを含むので, 適切に cut してあげると ホームディレクトリが得られる.\n\n実験用のシェルスクリプト\n\n"},{"id":"http://localhost:3000/posts/tmux","url":"http://localhost:3000/posts/tmux","title":"tmuxに入門する","summary":"vim を使うようになってから特に複数のターミナルウィンドウを開くことが多くなったので, 便利そうな tmux を使ってみる. 以前から存在は知っていたもののキーバインドが多くて慣れるの大変そうだと敬遠していたが, 自分の時間が出来たので良い機会だろう. tmuxとは GitHub の公式リポジトリでは以下のように説明されている. tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux m","date_published":"2020-10-31T23:53:54+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:tmux%E3%81%AB%E5%85%A5%E9%96%80%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9538e6b89073ad3b3e9c73aa485963fbfe252ed5","comment":"Update tmux.md\n","date_modified":"2020-10-31T23:58:30+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/944a32bd0a69ee4225e2e730e48b925051e1cdef","comment":"Add a post of tmux\n","date_modified":"2020-10-31T23:56:18+09:00"}],"content_html":"<p>vim を使うようになってから特に複数のターミナルウィンドウを開くことが多くなったので, 便利そうな tmux を使ってみる.\n以前から存在は知っていたもののキーバインドが多くて慣れるの大変そうだと敬遠していたが, 自分の時間が出来たので良い機会だろう.</p>\n<h2>tmuxとは</h2>\n<p>GitHub の公式リポジトリでは以下のように説明されている.</p>\n<blockquote>\n<p>tmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux may be detached from a screen and continue running in the background, then later reattached.</p>\n</blockquote>\n<p>(<a href=\"https://github.com/tmux/tmux\">tmux/tmux: tmux source code</a>)</p>\n<p>(意訳)\ntmux はターミナルマルチプレクサである.\nこれは一つの画面から複数の画面を作成し, アクセス, 制御が出来る.\ntmux は画面から分離してバックグラウンドで動作を継続し, のちに再度接続できる.)</p>\n<p>tmux は次のことを実現する.</p>\n<ul>\n<li>一つのターミナルを画面分割して2つ以上のターミナルとして扱える. (開発時に, エディタ, git, 各種CLIなどを並行して操作できる)</li>\n<li>tmux を離れてもセッションを継続できる. (ssh の際に不意にセッションが切れても, 再度つなぎ直すと状態を復元してくれる)</li>\n</ul>\n<h2>SetUp</h2>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># インストール</span>\n<span class=\"hljs-comment\"># 環境: Ubuntu 20.04</span>\n$ sudo apt install tmux -y\n\n<span class=\"hljs-comment\"># macOSなら</span>\n<span class=\"hljs-comment\"># $ brew install tmux</span>\n\n<span class=\"hljs-comment\"># 起動</span>\n$ tmux</code></pre>\n<h2>とりあえず使ってみる</h2>\n<ol>\n<li>ターミナルで <code>$ tmux</code> を実行し tmux を起動する.</li>\n<li>デフォルトのキーバインドでいくつか動作を実行してみる.</li>\n<li><code>Ctrl-b %</code> (<code>Ctrl</code>と<code>b</code>を同時押しして離し, 続けて<code>%</code>を入力) を押すと, ペインを作成 (画面を左右に分割) できる.</li>\n<li><code>Ctrl-b 矢印キー</code> で作成したペイン間を移動できる.</li>\n<li><code>Ctrl-b c</code> でウィンドウを作成できる.</li>\n<li><code>Ctrl-b w</code> 作成したウィンドウを選択できる.</li>\n<li><code>Ctrl-b x</code> でペインを閉じることができる.</li>\n<li><code>Ctrl-b d</code> でセッションをデタッチできる. (バックグラウンドでセッションを維持したまま, tmuxから抜ける.)</li>\n<li>ターミナルで <code>$ tmux a</code> と実行すると,前回実行していたセッションをアタッチできる. (バックグラウンドのセッションに接続.)</li>\n</ol>\n<p>このようにして画面を分割したり, セッションを維持したままターミナルから離れたり出来る.</p>\n<p>その他のデフォルトのキーバインドは <a href=\"http://www.tohoho-web.com/ex/tmux.html\">tmux入門 - とほほのWWW入門</a> が参考になる.</p>\n<p>tmux は複数のターミナルを束ねるが, それは次のような構造になっている.</p>\n<ul>\n<li>tmux は複数のセッションを持てる.</li>\n<li>セッションは複数のウィンドウを持てる.</li>\n<li>ウィンドウは複数のペインを持てる. (画面分割)</li>\n</ul>\n<hr>\n<p>基本は以上だが, その他にも使い切れないほど沢山の機能があるので, 以降では便利そうな機能を抽出のうえカスタマイズして使いやすくする.</p>\n<h2>好みの状態にカスタマイズする</h2>\n<h3>好みのペイン分割をするコマンドを作る</h3>\n<p>好みのペイン分割をすぐにできるようなスクリプトを作っておく.</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'alias ide=\"bash ~/.tmux-ide.sh\"'</span> >> .bashrc\n$ vim ~/.tmux-ide.sh</code></pre>\n<div class=\"remark-code-title\">~/.tmux-ide.sh</div>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash</span>\ntmux split-window -d -t 0        <span class=\"hljs-comment\"># 上下に画面分割</span>\ntmux send-keys -t 0 vim C-m      <span class=\"hljs-comment\"># ペイン0 (画面上部) で vim を実行</span>\ntmux split-window -h -t 1        <span class=\"hljs-comment\"># ペイン1 (画面下部) を左右に分割</span>\ntmux select-pane -t 0            <span class=\"hljs-comment\"># フォーカスをペイン0に移動する</span>\ntmux resize-pane -t 0 -D 10      <span class=\"hljs-comment\"># ペイン0を下方向に広げる</span>\ntmux send-keys -t 0 <span class=\"hljs-string\">':e ~/dev/'</span>  <span class=\"hljs-comment\"># ペイン0 に ':e ~/dev/'と入力する (vim でファイルを開くことを助ける)</span></code></pre>\n<p>こうすると, tmux 起動後や新しいウィンドウ作成後に <code>$ ide</code> と打つと, 自動で3つのペインに画面分割をしてvimを起動してくれる.</p>\n<h3>Vim のカラースキームがおかしくなる件を修正</h3>\n<p>vimのカラースキームが未設定だと, tmux内のvimとtmux外のvimで配色が変わるので, なんでもいいからカラースキームを設定する</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'colorscheme pablo'</span> >> ~/.vimrc</code></pre>\n<h3>~/.tmux.confを作成</h3>\n<ul>\n<li>tmux は表示やキーバインドをカスタマイズできる.</li>\n<li><code>~/.tmux.conf</code>に設定を書き込むと, デフォルトで読み込んでくれる.</li>\n<li>tmux を既に起動している状態でも, ファイル保存後に, <code>prefix :source ~/.tmux.conf</code>で設定ファイルをリロード可能.</li>\n</ul>\n<p>tmux は出来ることが多いが, そのためのキーバインドを覚えるのが大変そう.\n他人の設定した tmux を触らなければならないこともそう無いだろうし, 最初からカスタマイズして覚えやすそう/使いやすそうなキーに設定することにする.</p>\n<p>設定内容は検索すると沢山出てくるので, 適当なものを取り込むと良いだろう.\n記事末尾に参考となりそうなページをを記載する.</p>\n<p>以下では, 次のような内容の設定を行う.</p>\n<ul>\n<li>prefix キーの変更</li>\n<li>色の変更</li>\n<li>status line に表示する情報を変更</li>\n<li>マウス操作の有効化</li>\n<li>各種キーバインドの変更</li>\n</ul>\n<pre><code class=\"hljs language-sh\">$ vim ~/.tmux.conf</code></pre>\n<div class=\"remark-code-title\">~/.tmux.conf</div>\n<pre><code class=\"hljs language-plaintext\"># tmux起動時のシェルをzshにする\nset-option -g default-shell /bin/zsh\n\n# prefixキーをC-jに変更する\nset -g prefix C-j\n\n# ウィンドウ終了\nbind Q kill-window\n\n\n## --------------------見た目--------------------\n\n# tmuxを256色表示出来るようにする\nset-option -g default-terminal screen-256color\nset -g terminal-overrides 'xterm:colors=256'\n\n# 非アクティブなウィンドウの背景色を灰色にする\nset-option -g window-style 'bg=#444444'\n# アクティブなウィンドウの背景色を黒色にする\nset-option -g window-active-style 'bg=#222222'\n\n# status-left の最大の長さを指定する。\nset-option -g status-left-length 20\n# status-left のフォーマットを指定する。\nset-option -g status-left \"#[fg=colour255,bg=colour241]Session: #S #[default]\"\n\n# window-status のフォーマットを指定する。\nset-window-option -g window-status-format \" #I: #W \"\n# カレントウィンドウの window-status のフォーマットを指定する\nset-window-option -g window-status-current-format \"#[fg=colour255,bg=colour27,bold] #I: #W #[default]\"\n\n# 現在時刻を最右に表示\nset-option -g status-right '%Y-%m-%d(%a) %H:%M:%S'\n\n# ステータスバーを1秒毎に描画し直す\nset-option -g status-interval 1\n\n\n## --------------------マウス--------------------\n\n#マウス操作を有効にする\nset-option -g mouse on\n\n# スクロールアップするとコピーモードに入る\nbind-key -n WheelUpPane if-shell -F -t = \"#{mouse_any_flag}\" \"send-keys -M\" \"if -Ft= '#{pane_in_mode}' 'send-keys -M' 'select-pane -t=; copy-mode -e; send-keys -M'\"\n\n# 最後までスクロールダウンするとコピーモードを抜ける\nbind-key -n WheelDownPane select-pane -t= \\; send-keys -M\n\n\n## --------------------ペイン--------------------\n\n# vimのキーバインドでペインを移動する\nbind h select-pane -L\nbind j select-pane -D\nbind k select-pane -U\nbind l select-pane -R\n\n# vimのキーバインドでペインをリサイズする\nbind -r H resize-pane -L 5\nbind -r J resize-pane -D 5\nbind -r K resize-pane -U 5\nbind -r L resize-pane -R 5\n\n# ペインを垂直分割する\nbind v split-window -h -c '#{pane_current_path}'\n# ペインを水平分割する\nbind s split-window -v -c '#{pane_current_path}'\n\n# ペイン番号を表示\nbind i display-panes\n\n# ペインを終了\nbind q kill-pane</code></pre>\n<h3>Keybinds</h3>\n<p>.tmux.conf にて キーバインドを書き換え済みのものは is default ? を no と表記している.</p>\n<h3>基本</h3>\n<table>\n<thead>\n<tr>\n<th>command</th>\n<th>description</th>\n<th>is default ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Ctrl-j</td>\n<td>prefix</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix  ?</td>\n<td>キーバインド一覧</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<h3>セッション</h3>\n<table>\n<thead>\n<tr>\n<th>command</th>\n<th>description</th>\n<th>is default ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>prefix  d</td>\n<td>現在のセッションを継続したままtmuxを閉じる (detach)</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<h3>ウィンドウ</h3>\n<table>\n<thead>\n<tr>\n<th>command</th>\n<th>description</th>\n<th>is default ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>prefix c</td>\n<td>新規ウィンドウの作成/追加</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix w</td>\n<td>ウィンドウの一覧</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix Q</td>\n<td>ウィンドウの破棄</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix n</td>\n<td>次のウィンドウへ移動</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix p</td>\n<td>前のウィンドウへ移動</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix 数字</td>\n<td>当該番号のウィンドウへ移動</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix &#x3C;</td>\n<td>当該ウィンドウをリネームや移動等</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<h3>ペイン</h3>\n<table>\n<thead>\n<tr>\n<th>command</th>\n<th>description</th>\n<th>is default ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>prefix v</td>\n<td>左右にペイン分割</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix s</td>\n<td>上下ペイン分割</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix h</td>\n<td>左のペインへ移動</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix j</td>\n<td>下のペインへ移動</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix k</td>\n<td>上のペインへ移動</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix l</td>\n<td>右のペインへ移動</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix H</td>\n<td>ペインを左にリサイズ</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix J</td>\n<td>ペインを下にリサイズ</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix K</td>\n<td>ペインを上にリサイズ</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix L</td>\n<td>ペインを右にリサイズ</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix q</td>\n<td>ペインを破棄</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix i</td>\n<td>ペイン番号を表示 (続けて数字を入力すると当該ペインへ移動)</td>\n<td>no</td>\n</tr>\n<tr>\n<td>prefix ></td>\n<td>当該ペインをリネームや移動等</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<h3>コピー&#x26;ペースト</h3>\n<table>\n<thead>\n<tr>\n<th>command</th>\n<th>description</th>\n<th>is default ?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>prefix [</td>\n<td>コピーモード開始</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix Space</td>\n<td>コピー開始位置決定</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix Enter</td>\n<td>コピー終了位置決定</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>prefix ]</td>\n<td>コピーした内容の貼り付け</td>\n<td>YES</td>\n</tr>\n</tbody>\n</table>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/tmux/tmux\">tmux/tmux: tmux source code</a></li>\n<li><a href=\"https://github.com/zchee/tmux-ja/blob/master/tmux-ja.rst\">tmux-ja/tmux-ja.rst at master · zchee/tmux-ja</a></li>\n<li><a href=\"https://blog.inkdrop.info/vscode-like-environment-with-vim-tmux-4c2bfe17d31e\">VSCode-like environment with vim + tmux | by Takuya Matsuyama | Dev as Life</a></li>\n<li><a href=\"https://qiita.com/nl0_blu/items/9d207a70ccc8467f7bab\">tmuxを必要最低限で入門して使う - Qiita</a></li>\n<li><a href=\"http://www.tohoho-web.com/ex/tmux.html\">tmux入門 - とほほのWWW入門</a></li>\n<li><a href=\"https://qiita.com/nojima/items/9bc576c922da3604a72b\">tmux の status line の設定方法 - Qiita</a></li>\n<li><a href=\"https://qiita.com/zwirky/items/adbf22abad7d7822456b\">tmuxで快適なターミナル生活を送ろう - Qiita</a></li>\n<li><a href=\"http://kanjuku-tomato.blogspot.com/2014/03/tmux.html\">新規tmuxセッション起動時に自動で複数のウィンドウを作成してペイン分割する - 完熟トマト</a></li>\n<li><a href=\"https://gp-standard.com/tmux%E3%81%A7%E3%83%9E%E3%82%A6%E3%82%B9%E6%93%8D%E4%BD%9C%E3%82%92%E4%BE%BF%E5%88%A9%E3%81%AB%EF%BC%81-tmux-conf%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%A6%E8%A8%AD/\">tmuxでマウス操作を便利に！ tmux.confファイルを作って設定をカスタマイズする。 | Full Stack Enginear</a></li>\n<li><a href=\"https://qiita.com/mikene_koko/items/2867a6fe2eb73db6562e\">僕の考えた最強のtmux.conf - Qiita</a></li>\n</ul>\n<hr>\n<p>追伸: 10月に何も書いてないのもしゃくなのでギリギリに投稿。最近は卒業研究を進めている。</p>\n","content_text":"vim を使うようになってから特に複数のターミナルウィンドウを開くことが多くなったので, 便利そうな tmux を使ってみる.\n以前から存在は知っていたもののキーバインドが多くて慣れるの大変そうだと敬遠していたが, 自分の時間が出来たので良い機会だろう.\n\ntmuxとは\n\nGitHub の公式リポジトリでは以下のように説明されている.\n\ntmux is a terminal multiplexer: it enables a number of terminals to be created, accessed, and controlled from a single screen. tmux may be detached from a screen and continue running in the background, then later reattached.\n\n(tmux/tmux: tmux source code)\n\n(意訳)\ntmux はターミナルマルチプレクサである.\nこれは一つの画面から複数の画面を作成し, アクセス, 制御が出来る.\ntmux は画面から分離してバックグラウンドで動作を継続し, のちに再度接続できる.)\n\ntmux は次のことを実現する.\n\n一つのターミナルを画面分割して2つ以上のターミナルとして扱える. (開発時に, エディタ, git, 各種CLIなどを並行して操作できる)\n\ntmux を離れてもセッションを継続できる. (ssh の際に不意にセッションが切れても, 再度つなぎ直すと状態を復元してくれる)\n\nSetUp\n\n\n\nとりあえず使ってみる\n\nターミナルで $ tmux を実行し tmux を起動する.\n\nデフォルトのキーバインドでいくつか動作を実行してみる.\n\nCtrl-b % (Ctrlとbを同時押しして離し, 続けて%を入力) を押すと, ペインを作成 (画面を左右に分割) できる.\n\nCtrl-b 矢印キー で作成したペイン間を移動できる.\n\nCtrl-b c でウィンドウを作成できる.\n\nCtrl-b w 作成したウィンドウを選択できる.\n\nCtrl-b x でペインを閉じることができる.\n\nCtrl-b d でセッションをデタッチできる. (バックグラウンドでセッションを維持したまま, tmuxから抜ける.)\n\nターミナルで $ tmux a と実行すると,前回実行していたセッションをアタッチできる. (バックグラウンドのセッションに接続.)\n\nこのようにして画面を分割したり, セッションを維持したままターミナルから離れたり出来る.\n\nその他のデフォルトのキーバインドは tmux入門 - とほほのWWW入門 が参考になる.\n\ntmux は複数のターミナルを束ねるが, それは次のような構造になっている.\n\ntmux は複数のセッションを持てる.\n\nセッションは複数のウィンドウを持てる.\n\nウィンドウは複数のペインを持てる. (画面分割)\n\n\n\n基本は以上だが, その他にも使い切れないほど沢山の機能があるので, 以降では便利そうな機能を抽出のうえカスタマイズして使いやすくする.\n\n好みの状態にカスタマイズする\n\n好みのペイン分割をするコマンドを作る\n\n好みのペイン分割をすぐにできるようなスクリプトを作っておく.\n\n\n\nこうすると, tmux 起動後や新しいウィンドウ作成後に $ ide と打つと, 自動で3つのペインに画面分割をしてvimを起動してくれる.\n\nVim のカラースキームがおかしくなる件を修正\n\nvimのカラースキームが未設定だと, tmux内のvimとtmux外のvimで配色が変わるので, なんでもいいからカラースキームを設定する\n\n\n\n\\~/.tmux.confを作成\n\ntmux は表示やキーバインドをカスタマイズできる.\n\n\\~/.tmux.confに設定を書き込むと, デフォルトで読み込んでくれる.\n\ntmux を既に起動している状態でも, ファイル保存後に, prefix :source \\~/.tmux.confで設定ファイルをリロード可能.\n\ntmux は出来ることが多いが, そのためのキーバインドを覚えるのが大変そう.\n他人の設定した tmux を触らなければならないこともそう無いだろうし, 最初からカスタマイズして覚えやすそう/使いやすそうなキーに設定することにする.\n\n設定内容は検索すると沢山出てくるので, 適当なものを取り込むと良いだろう.\n記事末尾に参考となりそうなページをを記載する.\n\n以下では, 次のような内容の設定を行う.\n\nprefix キーの変更\n\n色の変更\n\nstatus line に表示する情報を変更\n\nマウス操作の有効化\n\n各種キーバインドの変更\n\n\n\nKeybinds\n\n.tmux.conf にて キーバインドを書き換え済みのものは is default ? を no と表記している.\n\n基本\n\n\n\nセッション\n\n\n\nウィンドウ\n\n\n\nペイン\n\n\n\nコピー&ペースト\n\n\n\n参考\n\ntmux/tmux: tmux source code\n\ntmux-ja/tmux-ja.rst at master · zchee/tmux-ja\n\nVSCode-like environment with vim + tmux | by Takuya Matsuyama | Dev as Life\n\ntmuxを必要最低限で入門して使う - Qiita\n\ntmux入門 - とほほのWWW入門\n\ntmux の status line の設定方法 - Qiita\n\ntmuxで快適なターミナル生活を送ろう - Qiita\n\n新規tmuxセッション起動時に自動で複数のウィンドウを作成してペイン分割する - 完熟トマト\n\ntmuxでマウス操作を便利に！ tmux.confファイルを作って設定をカスタマイズする。 | Full Stack Enginear\n\n僕の考えた最強のtmux.conf - Qiita\n\n\n\n追伸: 10月に何も書いてないのもしゃくなのでギリギリに投稿。最近は卒業研究を進めている。\n"},{"id":"http://localhost:3000/posts/webteckbook","url":"http://localhost:3000/posts/webteckbook","title":"積読本だった\"Webを支える技術\"を読んだ感想と、本を読むための心がけ","summary":"「Webを支える技術 HTTP, URI, HTML, そしてREST」を改めて読み直した。 年始に買って途中まで読んでいたものだ。 書籍 \"Webを支える技術\" について 本を選んだ背景と読んだ感想 書籍購入当時はスマホアプリのWeb APIを開発しており、URIの設計の参考にしたくて手にとった。 RESTという考え方やAPI設計についてとても参考になり、 良い設計とは何かを知ることが出来た。 これまでは用意されたWeb APIを使う側で、URI設計について意識することがなく無意識に良くつくられたURIのAPIを使っていた。 一方で設計するためにはまず利用者として当たり前だったことを言語化し","date_published":"2020-09-29T03:35:02+09:00","date_modified":"2021-05-05T19:47:55+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E7%A9%8D%E8%AA%AD%E6%9C%AC%E3%81%A0%E3%81%A3%E3%81%9F%22Web%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93%22%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0%E6%84%9F%E6%83%B3%E3%81%A8%E3%80%81%E6%9C%AC%E3%82%92%E8%AA%AD%E3%82%80%E3%81%9F%E3%82%81%E3%81%AE%E5%BF%83%E3%81%8C%E3%81%91,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本","インターネット"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1741da28aa87b809153d2c6799f500b28fc236a8","comment":"注釈内の改行を削除してremark-footnoteで正しく変換されるよう修正\n","date_modified":"2021-05-05T19:47:55+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/3c4b699d125e119feb760ce5dcf6e8a28d520da2","comment":"Delete <br/>\n","date_modified":"2020-10-04T22:54:02+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/69e113df2bb6e7ec64911bc1a98cb2a7c9df7b7d","comment":"Update webteckbook\n","date_modified":"2020-10-04T15:25:03+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/427780998f8898b66939511f0ba6c367c5f6fb82","comment":"Fix a style\n","date_modified":"2020-09-29T16:13:58+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/78a18fd8d5ec665a30912dfb688e0f19491358a5","comment":"Add a post","date_modified":"2020-09-29T03:53:34+09:00"}],"content_html":"<p><a href=\"https://www.amazon.co.jp/Web%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93-HTTP%E3%80%81URI%E3%80%81HTML%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6REST-WEB-PRESS-plus/dp/4774142042\">「Webを支える技術 HTTP, URI, HTML, そしてREST」</a>を改めて読み直した。\n年始に買って途中まで読んでいたものだ。</p>\n<h2>書籍 \"Webを支える技術\" について</h2>\n<h3>本を選んだ背景と読んだ感想</h3>\n<p>書籍購入当時はスマホアプリのWeb APIを開発しており、URIの設計の参考にしたくて手にとった。\nRESTという考え方やAPI設計についてとても参考になり、 良い設計とは何かを知ることが出来た。</p>\n<p>これまでは用意されたWeb APIを使う側で、URI設計について意識することがなく無意識に良くつくられたURIのAPIを使っていた。\n一方で設計するためにはまず利用者として当たり前だったことを言語化して理解する必要があり、その当たり前がRESTにより成り立っていることを学べた。</p>\n<h3>書籍内容と現在の状況の違い</h3>\n<p>書籍の第一版は2010年で今から10年前なので、現代と少し合わない点もある。</p>\n<ul>\n<li>初版時にはHTTP/2 HTTP/3は存在しておらず、HTTP/1.1が最新であることを前提として書かれている</li>\n<li>セマンティックWeb は2020年の今でも浸透していない</li>\n<li><s>Web APIとして、XML、Atom / AtomPubはあまり使われなくなった</s></li>\n</ul>\n<p><small>(追記 2020/10/4 : なんの裏付けもありません。サービスの目的によって使う/使わないがあるだけで、あまり使われなくなったというのは言い過ぎかも。XMLはあまり使われなくなりJSONが一般的になった、ということは言えるんじゃ無いかな。)</small></p>\n<p>とはいえ本の本筋は2020年でもきっと多分に有用であろう。</p>\n<h3>本から学んだこと</h3>\n<p>詳細は本に譲るが、私がこの本から学んだエッセンスには例えば次のようなものがある。</p>\n<h4>1. RESTについて</h4>\n<p>REST とは今日のWebにおいて適用されているアーキテクチャパターンのことで、次の制約をもつ。</p>\n<ul>\n<li>クライアント/サーバモデル</li>\n<li>ステートレスサーバ</li>\n<li>キャッシュ</li>\n<li>統一インタフェース</li>\n<li>階層化システム</li>\n<li>コードオンデマンド</li>\n</ul>\n<p>第1部第3章 p36あたりには上述のようなことが書かれている。</p>\n<p>インターネットは、遅延が大きく、また通信相手から応答があるか保証のない分散システムである。\nこのインターネットにおいて、端末(プログラム)(/人間) 間のインタフェースをどのように設計すべきかの原則、指針を示しているのがRESTだ。\n設計のときに参考になるアーキテクチャパターンとしてRESTが存在し、RESTの要素とはなんなのかを分解して解説している。</p>\n<h4>2. リソースのモデル化とURI設計</h4>\n<blockquote>\n<p>検索のような機能は、検索行為をモデル化するのではなく、検索結果をモデル化する。</p>\n</blockquote>\n<p>Webサービス/WebAPI(以下Webサービスと呼ぶ)を設計する時、\"動作\"をリソースとして割り当てる(=>URIで表現する)のはよくない。\nWebサービスにおける動作はCRUDであり、HTTPのメソッドであるGET/POST/PUT/DELETE で表現すべきである。</p>\n<p>例えば検索機能は、\"検索結果をGETで取得する\"と表現するのが簡潔である。\nGoogleの検索結果のURIは <code>https://google.com/search?q=hoge</code> となっているが、ここで出てくるsearchは検索行為を表しているのではなく検索結果を表している。\n検索行為に注目してしまうと、HTTPを拡張してSearchメソッドを作ったり、検索内容をPOSTしてサーバに検索しろとクライアントに命令させたりすることになる。\nこれはわかりづらいので良い設計といえない。</p>\n<p>検索に限らず、リソースをモデル化するとき(すなわちそれはリソースを表現するURIになりうる)は、動作ではなく名詞で表せるものに注目すべきだ。</p>\n<h4>3. 人間とコンピュータの統一インタフェース</h4>\n<blockquote>\n<p>リソース設計の際は、WebサービスとWeb APIを分けて考えない。</p>\n</blockquote>\n<p>良いリソースのモデル化は人間にとってもわかりやすいし、Web APIとしても使いやすくなる。\nなので、WebAPI用にリソースをモデル化してURIで表現し、人間にはまた別にモデル化して、、、ということは避けるべき。</p>\n<h2>積読本を読み切った感想と、本を読むスピードについて</h2>\n<p>さて、本の内容はここまでにして、以下は今回の積読消化の感想とそこから学んだことを記す。</p>\n<p>本を読むスピードは状況や意識で大きく変わる。</p>\n<p>1月に読んでいたときは理解できないところがあると調べて解決してから進める読み方だった。\n読むスピードが遅くそのまま途中で止まっていた。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<p>一方、今回9月は数時間で一気に読み切った。\n気になったところはメモを取ることにして、読み切るために興味のわかないところ(例えばAtom/AtomPub等の項)は斜め読みにするなどして進めた。</p>\n<p>本を読むスピードは自分の意識で変わる面がある。\n細かいところまで理解しながらゆっくり読み進めるか、全体を俯瞰するためにとにかく読み切ることを目標に進めるかという意識だ。\nまた、自分の知識量に応じて変わる面もある。\n自分が知っていることが多く載っている本は早く読めるし、知らないことが多く載っている本は時間がかかる。\nさらに、自分のテンションや気分で変わる面もある。\n読む気があるとき、内容に興味が湧いているとき、知的好奇心から本の内容を欲しているときは、どんどんページが進んで苦なくはやく読める。</p>\n<p>今回は一気に読み切ろうという心持ち、RESTって結局なんだっけという思いからくる知的好奇心、前回よりも知識量が増え内容の理解が進むことなど様々なことが重なったのが読み切れた要因だろう。</p>\n<p>私は気分が乗っていないときに何も考えずに本を読むと、丁寧にゆっくり読む癖がある。\n他方、本の全体像をつかみ必要なところだけを読んだり、必要になったときに読み直せるようインデックスを貼る気持ちで読んだりするほうが効率が良いのではないかと感じる。\n実際今回の本も読み切って感じたが、後半には実例を交えたURIの設計について述べられた章があり、1月にここを読んでいれば身になるものがさらにあったはずだった。\n今後はどんな読み方/スピードで本を読むかを読む前に考えるようにしたい。</p>\n<p>また、モチベーションの大切さも感じた。\nプログラムを書くときもそうであるし、本を読むときもそうであるが、(少なくとも私にとって)物事を進めるにはモチベーションがとても重要だと思う。\nモチベーションの高まっているときに躊躇なく進めることを心がけたい。\n(さらには自分のモチベーションを導けるようになりたい。)</p>\n<p>そんなこんなで積ん読を消化した勢いで他の本も読むぞ。</p>\n<hr>\n<p>参考: <a href=\"http://yohei-y.blogspot.com/\">yohei-y:weblog</a>(著者 山本陽平さんのブログ) ... この記事のURL<code>webteckbook</code>はブログに記載された内容を参考にした。</p>\n<p>追記: (2020/10/04) 不要な改行を削除</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">何故積ん読した当時のことを鮮明に覚えているかというと、本を読んでいた時が時間に追われながらコードを書きながら年末年始で帰省して親戚と過ごしていた映像記憶が蘇ってきたからである。 エピソード記憶は強烈だ。 当時はAPIの設計についても考えなければならなかったがDockerを含むインフラについても学ばねばならなかったので、のんびり本を読み切ってる場合ではない！という心情だったのだろう。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"「Webを支える技術 HTTP, URI, HTML, そしてREST」を改めて読み直した。\n年始に買って途中まで読んでいたものだ。\n\n書籍 \"Webを支える技術\" について\n\n本を選んだ背景と読んだ感想\n\n書籍購入当時はスマホアプリのWeb APIを開発しており、URIの設計の参考にしたくて手にとった。\nRESTという考え方やAPI設計についてとても参考になり、 良い設計とは何かを知ることが出来た。\n\nこれまでは用意されたWeb APIを使う側で、URI設計について意識することがなく無意識に良くつくられたURIのAPIを使っていた。\n一方で設計するためにはまず利用者として当たり前だったことを言語化して理解する必要があり、その当たり前がRESTにより成り立っていることを学べた。\n\n書籍内容と現在の状況の違い\n\n書籍の第一版は2010年で今から10年前なので、現代と少し合わない点もある。\n\n初版時にはHTTP/2 HTTP/3は存在しておらず、HTTP/1.1が最新であることを前提として書かれている\n\nセマンティックWeb は2020年の今でも浸透していない\n\nWeb APIとして、XML、Atom / AtomPubはあまり使われなくなった\n\n(追記 2020/10/4 : なんの裏付けもありません。サービスの目的によって使う/使わないがあるだけで、あまり使われなくなったというのは言い過ぎかも。XMLはあまり使われなくなりJSONが一般的になった、ということは言えるんじゃ無いかな。)\n\nとはいえ本の本筋は2020年でもきっと多分に有用であろう。\n\n本から学んだこと\n\n詳細は本に譲るが、私がこの本から学んだエッセンスには例えば次のようなものがある。\n\n1\\. RESTについて\n\nREST とは今日のWebにおいて適用されているアーキテクチャパターンのことで、次の制約をもつ。\n\nクライアント/サーバモデル\n\nステートレスサーバ\n\nキャッシュ\n\n統一インタフェース\n\n階層化システム\n\nコードオンデマンド\n\n第1部第3章 p36あたりには上述のようなことが書かれている。\n\nインターネットは、遅延が大きく、また通信相手から応答があるか保証のない分散システムである。\nこのインターネットにおいて、端末(プログラム)(/人間) 間のインタフェースをどのように設計すべきかの原則、指針を示しているのがRESTだ。\n設計のときに参考になるアーキテクチャパターンとしてRESTが存在し、RESTの要素とはなんなのかを分解して解説している。\n\n2\\. リソースのモデル化とURI設計\n\n検索のような機能は、検索行為をモデル化するのではなく、検索結果をモデル化する。\n\nWebサービス/WebAPI(以下Webサービスと呼ぶ)を設計する時、\"動作\"をリソースとして割り当てる(=>URIで表現する)のはよくない。\nWebサービスにおける動作はCRUDであり、HTTPのメソッドであるGET/POST/PUT/DELETE で表現すべきである。\n\n例えば検索機能は、\"検索結果をGETで取得する\"と表現するのが簡潔である。\nGoogleの検索結果のURIは https\\://google.com/search?q=hoge となっているが、ここで出てくるsearchは検索行為を表しているのではなく検索結果を表している。\n検索行為に注目してしまうと、HTTPを拡張してSearchメソッドを作ったり、検索内容をPOSTしてサーバに検索しろとクライアントに命令させたりすることになる。\nこれはわかりづらいので良い設計といえない。\n\n検索に限らず、リソースをモデル化するとき(すなわちそれはリソースを表現するURIになりうる)は、動作ではなく名詞で表せるものに注目すべきだ。\n\n3\\. 人間とコンピュータの統一インタフェース\n\nリソース設計の際は、WebサービスとWeb APIを分けて考えない。\n\n良いリソースのモデル化は人間にとってもわかりやすいし、Web APIとしても使いやすくなる。\nなので、WebAPI用にリソースをモデル化してURIで表現し、人間にはまた別にモデル化して、、、ということは避けるべき。\n\n積読本を読み切った感想と、本を読むスピードについて\n\nさて、本の内容はここまでにして、以下は今回の積読消化の感想とそこから学んだことを記す。\n\n本を読むスピードは状況や意識で大きく変わる。\n\n1月に読んでいたときは理解できないところがあると調べて解決してから進める読み方だった。\n読むスピードが遅くそのまま途中で止まっていた。[^1]\n\n一方、今回9月は数時間で一気に読み切った。\n気になったところはメモを取ることにして、読み切るために興味のわかないところ(例えばAtom/AtomPub等の項)は斜め読みにするなどして進めた。\n\n本を読むスピードは自分の意識で変わる面がある。\n細かいところまで理解しながらゆっくり読み進めるか、全体を俯瞰するためにとにかく読み切ることを目標に進めるかという意識だ。\nまた、自分の知識量に応じて変わる面もある。\n自分が知っていることが多く載っている本は早く読めるし、知らないことが多く載っている本は時間がかかる。\nさらに、自分のテンションや気分で変わる面もある。\n読む気があるとき、内容に興味が湧いているとき、知的好奇心から本の内容を欲しているときは、どんどんページが進んで苦なくはやく読める。\n\n今回は一気に読み切ろうという心持ち、RESTって結局なんだっけという思いからくる知的好奇心、前回よりも知識量が増え内容の理解が進むことなど様々なことが重なったのが読み切れた要因だろう。\n\n私は気分が乗っていないときに何も考えずに本を読むと、丁寧にゆっくり読む癖がある。\n他方、本の全体像をつかみ必要なところだけを読んだり、必要になったときに読み直せるようインデックスを貼る気持ちで読んだりするほうが効率が良いのではないかと感じる。\n実際今回の本も読み切って感じたが、後半には実例を交えたURIの設計について述べられた章があり、1月にここを読んでいれば身になるものがさらにあったはずだった。\n今後はどんな読み方/スピードで本を読むかを読む前に考えるようにしたい。\n\nまた、モチベーションの大切さも感じた。\nプログラムを書くときもそうであるし、本を読むときもそうであるが、(少なくとも私にとって)物事を進めるにはモチベーションがとても重要だと思う。\nモチベーションの高まっているときに躊躇なく進めることを心がけたい。\n(さらには自分のモチベーションを導けるようになりたい。)\n\nそんなこんなで積ん読を消化した勢いで他の本も読むぞ。\n\n\n\n参考: yohei-y:weblog(著者 山本陽平さんのブログ) ... この記事のURLwebteckbookはブログに記載された内容を参考にした。\n\n追記: (2020/10/04) 不要な改行を削除\n\n[^1]: 何故積ん読した当時のことを鮮明に覚えているかというと、本を読んでいた時が時間に追われながらコードを書きながら年末年始で帰省して親戚と過ごしていた映像記憶が蘇ってきたからである。 エピソード記憶は強烈だ。 当時はAPIの設計についても考えなければならなかったがDockerを含むインフラについても学ばねばならなかったので、のんびり本を読み切ってる場合ではない！という心情だったのだろう。\n"},{"id":"http://localhost:3000/posts/keymap-202009","url":"http://localhost:3000/posts/keymap-202009","title":"2020年9月のキーマップ for lily58","summary":"以前記事に書いたとおり、分割キーボード lily58を使っている。 自作してから1ヶ月以上経つが、何度かキーマップを書き換えており、順調に配列沼にハマっている。 丁度、しばらく使っていてしっくり来ないところを昨日書き換えたばかり。 せっかくなので記録がてら記事に残しておく。 3レイヤーで、最下段の内側から2つめのキーを押している間はレイヤーが切り替わる。 この配列は次のような方針で作られている。 基本はqwertyのUS配列に寄せる ホームポジションとそれに隣接するキーでなるべく完結させる Layer0は英字, Layer1に記号と数字, Layer2に制御キーを割り当てる 方向キーはvim ","date_published":"2020-09-25T12:53:30+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:2020%E5%B9%B49%E6%9C%88%E3%81%AE%E3%82%AD%E3%83%BC%E3%83%9E%E3%83%83%E3%83%97%20for%20lily58,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["自作キーボード","Lily58","キーマップ"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/3543b81b7322a8cac8f4f456445480bb0d1bfc5e","comment":"Fix articles\n","date_modified":"2020-09-25T15:02:53+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/535ea7a6c673e808124be055a53374409d6bc1e6","comment":"Add keymap-202009.md\n","date_modified":"2020-09-25T12:58:23+09:00"}],"content_html":"<p><a href=\"/posts/lily58-pro-ble/\">以前記事に書いた</a>とおり、分割キーボード lily58を使っている。</p>\n<p>自作してから1ヶ月以上経つが、何度かキーマップを書き換えており、順調に配列沼にハマっている。</p>\n<p>丁度、しばらく使っていてしっくり来ないところを昨日書き換えたばかり。\nせっかくなので記録がてら記事に残しておく。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">lily58のキーマップを変えた。<br><br>変更は<br>- コロンとバックスラッシュをlayer0に<br>- 中央のGと<br>Hに挟まれたキーを使わないことに<br><br>40%っぽく1段目を使っていないのは1ヶ月前くらいから。 <a href=\"https://t.co/jWCNcd9f5p\">pic.twitter.com/jWCNcd9f5p</a></p>&mdash; けーすけ@やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1309153335530848256?ref_src=twsrc%5Etfw\">September 24, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>3レイヤーで、最下段の内側から2つめのキーを押している間はレイヤーが切り替わる。</p>\n<p>この配列は次のような方針で作られている。</p>\n<ul>\n<li>基本はqwertyのUS配列に寄せる</li>\n<li>ホームポジションとそれに隣接するキーでなるべく完結させる</li>\n<li>Layer0は英字, Layer1に記号と数字, Layer2に制御キーを割り当てる</li>\n<li>方向キーはvim likeにhjklに割り当てる</li>\n<li>(コードを書くとき等)記号の入力頻度が高いわりに私の入力スピードが遅いので、なるべく打ちやすいところに記号を配置する。</li>\n</ul>\n<p>lily58はもともと60%だが、最上段のキーは使っていない。\nまた内側に括弧に割り当てやすいキーがあるが、それらのキーには割当していない。</p>\n<p>初めて自作キーボードを購入する際は、40%キーボードはキーが少なすぎる過激な配列で、自分には独立した数字キーは必要だと思っていた。\nしかし lily58 が届いていざ 打ってみると、数字キーは遠くて手が大きく動き、押しづらさを感じる。\n遠いキーはブラインドタッチの障壁になりそうだと思ったのだ。</p>\n<p>そのあと1ヶ月くらい使って、内側の括弧に割り当てやすいキー (GとHに挟まれたキー)も、意外とホームポジションから遠く押しづらいことに気づいた。</p>\n<p>というわけで上のツイートの配列に落ち着いている。</p>\n<p>40%でも問題なさそうなので、そのうち<a href=\"https://olkb.com/collections/planck\">planck</a>や<a href=\"https://drop.com/buy/massdrop-x-olkb-planck-light-mechanical-keyboard\">planck light</a>、<a href=\"https://yushakobo.jp/shop/corne-cherry/\">Corne Cherry</a>といった、40%の column-staggered / Ortholiner なキーボードが欲しい。</p>\n<p>というわけで、今後も変更があれば随時記録していきたい。</p>\n","content_text":"以前記事に書いたとおり、分割キーボード lily58を使っている。\n\n自作してから1ヶ月以上経つが、何度かキーマップを書き換えており、順調に配列沼にハマっている。\n\n丁度、しばらく使っていてしっくり来ないところを昨日書き換えたばかり。\nせっかくなので記録がてら記事に残しておく。\n\n\n\n3レイヤーで、最下段の内側から2つめのキーを押している間はレイヤーが切り替わる。\n\nこの配列は次のような方針で作られている。\n\n基本はqwertyのUS配列に寄せる\n\nホームポジションとそれに隣接するキーでなるべく完結させる\n\nLayer0は英字, Layer1に記号と数字, Layer2に制御キーを割り当てる\n\n方向キーはvim likeにhjklに割り当てる\n\n(コードを書くとき等)記号の入力頻度が高いわりに私の入力スピードが遅いので、なるべく打ちやすいところに記号を配置する。\n\nlily58はもともと60%だが、最上段のキーは使っていない。\nまた内側に括弧に割り当てやすいキーがあるが、それらのキーには割当していない。\n\n初めて自作キーボードを購入する際は、40%キーボードはキーが少なすぎる過激な配列で、自分には独立した数字キーは必要だと思っていた。\nしかし lily58 が届いていざ 打ってみると、数字キーは遠くて手が大きく動き、押しづらさを感じる。\n遠いキーはブラインドタッチの障壁になりそうだと思ったのだ。\n\nそのあと1ヶ月くらい使って、内側の括弧に割り当てやすいキー (GとHに挟まれたキー)も、意外とホームポジションから遠く押しづらいことに気づいた。\n\nというわけで上のツイートの配列に落ち着いている。\n\n40%でも問題なさそうなので、そのうちplanckやplanck light、Corne Cherryといった、40%の column-staggered / Ortholiner なキーボードが欲しい。\n\nというわけで、今後も変更があれば随時記録していきたい。\n"},{"id":"http://localhost:3000/posts/makefile-named-pipe","url":"http://localhost:3000/posts/makefile-named-pipe","title":"Makefileの中で名前付きパイプ(bash記法)を使いたかった。2つのコマンド実行結果を比較する。","summary":"今日は小さな Tips。 make は1970年代に生まれ、C言語のビルドなどでよく用いられるビルドツールだ。 Makefileにビルド手順を記述しておき $make で一連の流れを実行できる。 古からあるビルドツールであるから、インデントがタブ文字でないといけないなどの制約があるが、環境に依存しづらいので最近はよく使うようにしている。 Makefile にはシェルスクリプトのように実行するコマンドを記述するが、この中ではbash独自の拡張記法には対応していない。(Makefile独自の記法があったりする) 2つのコマンドの実行結果を比較したい時、bashでは次のように名前付きパイプを使うと簡","date_published":"2020-09-17T16:31:46+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Makefile%E3%81%AE%E4%B8%AD%E3%81%A7%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E3%83%91%E3%82%A4%E3%83%97(bash%E8%A8%98%E6%B3%95)%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%8B%E3%81%A3%E3%81%9F%E3%80%822%E3%81%A4%E3%81%AE%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E5%AE%9F%E8%A1%8C%E7%B5%90%E6%9E%9C%E3%82%92%E6%AF%94%E8%BC%83%E3%81%99%E3%82%8B%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/fbd41debe01585a97a5a4f460fe307c404cc3176","comment":"Add the article \"makefile-named-pipe\"\n","date_modified":"2020-09-17T16:58:00+09:00"}],"content_html":"<p>今日は小さな Tips。</p>\n<p>make は1970年代に生まれ、C言語のビルドなどでよく用いられるビルドツールだ。\nMakefileにビルド手順を記述しておき <code>$make</code> で一連の流れを実行できる。</p>\n<p>古からあるビルドツールであるから、インデントがタブ文字でないといけないなどの制約があるが、環境に依存しづらいので最近はよく使うようにしている。</p>\n<p>Makefile にはシェルスクリプトのように実行するコマンドを記述するが、この中ではbash独自の拡張記法には対応していない。(Makefile独自の記法があったりする)</p>\n<p>2つのコマンドの実行結果を比較したい時、bashでは次のように名前付きパイプを使うと簡単に記述できる。</p>\n<pre><code class=\"hljs language-sh\">$ diff &#x3C;(<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'hoge'</span>) &#x3C;(<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'fuga'</span>)</code></pre>\n<p>これは独自の記法でありMakefileの中では使えない。</p>\n<p>そこで、名前付きパイプを避けて明示的にファイルディスクリプタを利用することで解決できる。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'hoge'</span> | (<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'fuga'</span> | diff /dev/fd/3 -) 3&#x3C;&#x26;0</code></pre>\n<p>まず、<code>$ehco 'hoge'</code>の実行結果を標準出力ではなくファイルディスクリプタ3に流し込む。\nそして、これ(/dev/fd/3)と<code>$echo 'fuga'</code>の実行結果の標準出力をdiffで比較している。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://yulii.github.io/diff-command-tips-20150627.html\">コマンド実行結果のdiff を取るといろいろ捗る - by and for engineers</a></li>\n<li><a href=\"https://ja.wikipedia.org/wiki/Make\">make - Wikipedia</a></li>\n</ul>\n<hr>\n<p>p.s. 本「<a href=\"https://www.amazon.co.jp/dp/B075ST51Y5/ref=dp-kindle-redirect?_encoding=UTF8&#x26;btkr=1\">ふつうのLinuxプログラミング</a>」を参考に <a href=\"https://github.com/yammerjp/cat\">cat コマンドを作っていて</a>、簡単なテストスクリプトをMakefileに書きたいと思ったところから、このスニペットを必要とした。</p>\n","content_text":"今日は小さな Tips。\n\nmake は1970年代に生まれ、C言語のビルドなどでよく用いられるビルドツールだ。\nMakefileにビルド手順を記述しておき $make で一連の流れを実行できる。\n\n古からあるビルドツールであるから、インデントがタブ文字でないといけないなどの制約があるが、環境に依存しづらいので最近はよく使うようにしている。\n\nMakefile にはシェルスクリプトのように実行するコマンドを記述するが、この中ではbash独自の拡張記法には対応していない。(Makefile独自の記法があったりする)\n\n2つのコマンドの実行結果を比較したい時、bashでは次のように名前付きパイプを使うと簡単に記述できる。\n\n\n\nこれは独自の記法でありMakefileの中では使えない。\n\nそこで、名前付きパイプを避けて明示的にファイルディスクリプタを利用することで解決できる。\n\n\n\nまず、$ehco 'hoge'の実行結果を標準出力ではなくファイルディスクリプタ3に流し込む。\nそして、これ(/dev/fd/3)と$echo 'fuga'の実行結果の標準出力をdiffで比較している。\n\n参考\n\nコマンド実行結果のdiff を取るといろいろ捗る - by and for engineers\n\nmake - Wikipedia\n\n\n\np.s. 本「ふつうのLinuxプログラミング」を参考に cat コマンドを作っていて、簡単なテストスクリプトをMakefileに書きたいと思ったところから、このスニペットを必要とした。\n"},{"id":"http://localhost:3000/posts/lovelab-ec2","url":"http://localhost:3000/posts/lovelab-ec2","title":"LoveLabのAPIサーバをAWS EC2上にセットアップする","summary":"以下過去の自分用のメモを移動。 昨冬、チーム開発で ToDo 管理の iPhone アプリ LoveLab を開発していた。 LoveLab API サーバは、docker-composeでまとめられている。 AWS の EC2 上で立ち上げるための手順を以下に示す。 EC2 instance作成後の作業 80番ポートを開放 sshでログイン 関係ソフトウェアをinstall deploy.sshを入手 ","date_published":"2020-08-14T22:55:26+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:LoveLab%E3%81%AEAPI%E3%82%B5%E3%83%BC%E3%83%90%E3%82%92AWS%20EC2%E4%B8%8A%E3%81%AB%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["AWS","Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/7bbdd2c99f041a5de27f99d49e0297d2dc5547f6","comment":"Add lovelab-ec2.md\n","date_modified":"2020-08-14T23:22:08+09:00"}],"content_html":"<p>以下過去の自分用のメモを移動。</p>\n<p>昨冬、チーム開発で ToDo 管理の iPhone アプリ LoveLab を開発していた。</p>\n<div class=\"remark-code-title\">deploy.sh</div>\n<p><a href=\"https://github.com/yammerjp/lovelab-api\">LoveLab API サーバ</a>は、docker-composeでまとめられている。\nAWS の EC2 上で立ち上げるための手順を以下に示す。</p>\n<h2>EC2 instance作成後の作業</h2>\n<ol>\n<li>\n<p>80番ポートを開放</p>\n</li>\n<li>\n<p>sshでログイン</p>\n</li>\n<li>\n<p>関係ソフトウェアをinstall</p>\n<pre><code class=\"hljs language-sh\">sudo yum install -y docker\nsudo service docker start\nsudo usermod -a -G docker ec2-user\nsudo docker info\nsudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m) -o /usr/<span class=\"hljs-built_in\">local</span>/bin/docker-compose\nsudo chmod +x /usr/<span class=\"hljs-built_in\">local</span>/bin/docker-compose\ndocker-compose --version\nsudo yum install -y git</code></pre>\n</li>\n<li>\n<p>deploy.sshを入手</p>\n<pre><code class=\"hljs language-sh\">touch deploy.sh\nchmod u+x deploy.sh\nvim deploy.sh</code></pre>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Deploying lovelab API server...\"</span>\n\n<span class=\"hljs-keyword\">if</span> [ -d ./lovelab.heroku ]; <span class=\"hljs-keyword\">then</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Stop containers and delete old source files.\"</span>\n  <span class=\"hljs-built_in\">cd</span> lovelab.heroku\n  docker-compose down\n  <span class=\"hljs-built_in\">cd</span> ../\n  rm -rf lovelab.heroku\n<span class=\"hljs-keyword\">fi</span>\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Clone source files.\"</span>\ngit <span class=\"hljs-built_in\">clone</span> https://github.com/yammerjp/lovelab.heroku.git\n<span class=\"hljs-built_in\">cd</span> lovelab.heroku\ngit checkout origin/release\ncp .env.example .env\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"docker-compose build\"</span>\ndocker-compose build --no-cache\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"docekr-compose up\"</span>\ndocker-compose up -d</code></pre>\n</li>\n</ol>\n","content_text":"以下過去の自分用のメモを移動。\n\n昨冬、チーム開発で ToDo 管理の iPhone アプリ LoveLab を開発していた。\n\n\n\nLoveLab API サーバは、docker-composeでまとめられている。\nAWS の EC2 上で立ち上げるための手順を以下に示す。\n\nEC2 instance作成後の作業\n\n80番ポートを開放\n\nsshでログイン\n\n関係ソフトウェアをinstall\n\n\n\ndeploy.sshを入手\n\n"},{"id":"http://localhost:3000/posts/compiler-lalr1","url":"http://localhost:3000/posts/compiler-lalr1","title":"LALR(1)構文解析を行いながら、コンパイラの構文解析を学ぶ","summary":"以下、過去の自分向けのメモの移動。 コンパイラの主要な処理に構文解析がある。 前回はLR0文法構文解析を行った。 今回は与えられたLALR(1)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。 問題の文法規則 次のLALR(1)文法規則を受理するオートマトンと構文解析表をつくり、構文解析を行う。 First集合 First集合とは First(K) ... Kの還元前の終端記号列において、先頭に来る可能性のある終端記号の集合 First集合の求め方 最初は空集合とする 非終端記号 First(K) (K..非終端記号)について、 Kが左辺の文法規則が次の2つだ","date_published":"2020-08-14T19:13:19+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:LALR(1)%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E3%82%92%E8%A1%8C%E3%81%84%E3%81%AA%E3%81%8C%E3%82%89%E3%80%81%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E3%82%92%E5%AD%A6%E3%81%B6,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","構文解析"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/bfdd8f2c844a9e1a0e8ccce07a8845d93e9998f2","comment":"Fix table width\n","date_modified":"2020-10-04T21:32:44+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae0ea8e11aa1de2b26cd27c1e9c046d2fb9135f4","comment":"Add articles\n","date_modified":"2020-08-14T22:40:26+09:00"}],"content_html":"<p>以下、過去の自分向けのメモの移動。</p>\n<p>コンパイラの主要な処理に構文解析がある。\n前回はLR0文法構文解析を行った。</p>\n<p>今回は与えられたLALR(1)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。</p>\n<h2>問題の文法規則</h2>\n<p>次のLALR(1)文法規則を受理するオートマトンと構文解析表をつくり、構文解析を行う。</p>\n<pre><code>E -> E + T\nE -> T\nT -> T * F\nT -> F\nF -> i\nF -> ( E )\n</code></pre>\n<h2>First集合</h2>\n<h3>First集合とは</h3>\n<p><code>First(K)</code> ... Kの還元前の終端記号列において、先頭に来る可能性のある終端記号の集合</p>\n<h3>First集合の求め方</h3>\n<p>最初は空集合とする</p>\n<h4>非終端記号</h4>\n<p><code>First(K)</code> (<code>K</code>..非終端記号)について、\nKが左辺の文法規則が次の2つだったとき</p>\n<ul>\n<li><code>K -> abc...</code></li>\n<li><code>K -> PqRs...</code></li>\n</ul>\n<p><code>First(K) = First(K) + First(a) + First(P)</code></p>\n<h4>終端記号</h4>\n<p><code>First(k)</code> (<code>k</code>...終端記号)について、\n<code>First(k) = { k }</code></p>\n<h3>今回の問題におけるFirst集合</h3>\n<p><code>First(E) = First(T) = First(F) = { i ( }</code></p>\n<h2>Follow集合</h2>\n<h3>Follow集合とは</h3>\n<p><code>Follow(K)</code> ... <code>K</code>の次に来る可能性のある終端記号の集合</p>\n<h3>Follow集合の求め方</h3>\n<p>最初は<code>{}</code>\n開始記号のFollow集合に$を加える</p>\n<p><code>Follow(K)</code>について</p>\n<p>文法規則 <code>A -> wK</code> (<code>w</code>は任意の文字列)ならば\n<code>Follow(K) += Follow(A) </code></p>\n<p>文法規則 <code>A -> wKB</code>かつ <code>First(B)∋ε</code> ならば\n<code>Follow(K) += Follow(A)</code></p>\n<p>文法規則 <code>A -> xKy (y≠ε)</code> ならば\n<code>Follow(K) += First(y)</code></p>\n<h3>今回の問題におけるFollow集合</h3>\n<pre><code>Follow(E) = { $ } + First( ) ) + First( + ) = { $ ) + }\nFollow(T) = Follow(E) + First( * ) = { $ ) + * }\nFollow(F) = Follow(T) = { $ ) + * }\n</code></pre>\n<h2>LALR(1)正準集合</h2>\n<h3>I0</h3>\n<pre><code>E -> ・E + T [ $ + ]\nE -> ・T [ $ + ]\nT -> ・T * F [ $ + * ]\nT -> ・F [ $ + * ]\nF -> ・i [ $ + * ]\nF -> ・( E ) [ $ + * ]\n</code></pre>\n<h3>I1</h3>\n<pre><code>E -> E ・+ T [ $ + ]\n</code></pre>\n<h3>I2</h3>\n<pre><code>E -> T・ [ $ + ) ]\nT -> T ・* F [ $ + * ) ]\n</code></pre>\n<h3>I3</h3>\n<pre><code>T -> F・ [ $ + * ) ]\n</code></pre>\n<h3>I4</h3>\n<pre><code>F -> i・ [ $ + * ) ]\n</code></pre>\n<h3>I5</h3>\n<pre><code>F -> ( ・E ) [ $ + * ) ]\nE -> ・E + T [ + ) ]\nE -> ・T [ + ) ]\nT -> ・T * F [ + * ) ]\nT -> ・F [ + * ) ]\nF -> ・i [ + * ) ]\nF -> ・( E ) [ + * ) ]\n</code></pre>\n<h3>I6</h3>\n<pre><code>E -> E + ・T [ $ + ) ]\nT -> ・T * F [ $ + * ) ]\nT -> ・F [ $ + * ) ]\nF -> ・i [ $ + * ) ]\nF -> ・( E ) [ $ + * ) ]\n</code></pre>\n<h3>I7</h3>\n<pre><code>T -> T * ・F [ $ + * ) ]\nF -> ・i [ $ + * ) ]\nF -> ・( E ) [ $ + * ) ]\n</code></pre>\n<h3>I8</h3>\n<pre><code>F -> ( E ・) [ $ + * ) ]\nE -> E ・+ T [ + ) ]\n</code></pre>\n<h3>I9</h3>\n<pre><code>E -> E + T・ [ $ + ) ]\nT -> T ・* F [ $ + * ) ]\n</code></pre>\n<h3>I10</h3>\n<pre><code>T -> T * F・ [ $ + * ) ]\n</code></pre>\n<h3>I11</h3>\n<pre><code>F -> ( E )・ [ $ + * ) ]\n</code></pre>\n<h2>オートマトン</h2>\n<p>以上より、与えられた文法規則を満たす系列を受理するオートマトンをつくる。</p>\n<div class=\"remark-code-title\">dot</div>\n<pre><code class=\"hljs language-plaintext\">digraph G {\n  rankdir=LR;\n  empty [label = \"\" shape = plaintext];\n  node [shape = doublecircle];I2 I9;\n  node [shape = circle];\n  empty -> I0 [label = \"start\"];\n  I0 -> I1 [label = \"E\"];\n  I0 -> I2 [label = \"T\"];\n  I0 -> I3 [label = \"F\"];\n  I0 -> I4 [label = \"i\"];\n  I0 -> I5 [label = \"(\"];\n\n  I1 -> I6 [label = \"+\"];\n\n  I2 -> I7 [label = \"*\"];\n\n  I5 -> I8 [label = \"E\"];\n  I5 -> I2 [label = \"T\"];\n  I5 -> I3 [label = \"F\"];\n  I5 -> I4 [label = \"i\"];\n  I5 -> I5 [label = \"(\"];\n\n  I6 -> I9 [label = \"T\"];\n  I6 -> I3 [label = \"F\"];\n  I6 -> I4 [label = \"i\"];\n  I6 -> I5 [label = \"(\"];\n\n  I7 -> I10 [label = \"F\"];\n  I7 -> I4 [label = \"i\"];\n  I7 -> I5 [label = \"(\"];\n\n  I8 -> I11 [label = \")\"];\n  I8 -> I6 [label = \"+\"];\n\n  I9 -> I7 [label = \"*\"];\n} </code></pre>\n<h2>構文解析表</h2>\n<p>オートマトンを構文解析表にまとめる。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">I\\記号</th>\n<th>+</th>\n<th>*</th>\n<th>(</th>\n<th>)</th>\n<th>i</th>\n<th>$</th>\n<th>E</th>\n<th>T</th>\n<th>F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">0</td>\n<td></td>\n<td></td>\n<td>s5</td>\n<td></td>\n<td>s4</td>\n<td></td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td>s6</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td>r2</td>\n<td>s7</td>\n<td></td>\n<td>r2</td>\n<td></td>\n<td>acc</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td>r4</td>\n<td>r4</td>\n<td></td>\n<td>r4</td>\n<td></td>\n<td>r4</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td>r5</td>\n<td>r5</td>\n<td></td>\n<td>r5</td>\n<td></td>\n<td>r5</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td></td>\n<td></td>\n<td>s5</td>\n<td></td>\n<td>s4</td>\n<td></td>\n<td>8</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td></td>\n<td></td>\n<td>s5</td>\n<td></td>\n<td>s4</td>\n<td></td>\n<td></td>\n<td>9</td>\n<td>3</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td></td>\n<td></td>\n<td>s5</td>\n<td></td>\n<td>s4</td>\n<td></td>\n<td></td>\n<td></td>\n<td>10</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td>s6</td>\n<td></td>\n<td></td>\n<td>s11</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td>r1</td>\n<td>s7</td>\n<td></td>\n<td>r1</td>\n<td></td>\n<td>acc</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td>r3</td>\n<td>r3</td>\n<td></td>\n<td>r3</td>\n<td></td>\n<td>r3</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td>r6</td>\n<td>r6</td>\n<td></td>\n<td>r6</td>\n<td></td>\n<td>r6</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>構文解析</h2>\n<p>上記の構文解析表に従い、次のような系列を構文解析する。</p>\n<h3><code>i+i*i</code></h3>\n<pre><code>( I0 , i+i*i$ ) // s6\n( I0 i I4 , +i*i$ ) // r5\n( I0 F I3 , +i*i$ ) // r4\n( I0 T I2 , +i*i$ ) // r2\n( I0 F I1 , +i*i$ ) // s6\n( I0 F I1 + I6 , i*i$ ) // s4\n( I0 F I1 + I6 i I4 , *i$ ) // r5\n( I0 F I1 + I6 F I3 , *i$ ) // r4\n( I0 F I1 + I6 T I9 , *i$ ) // s7\n( I0 F I1 + I6 T I9 * I7 , i$ ) // s4 \n( I0 F I1 + I6 T I9 * I7 i I4 , $ ) // r5 \n( I0 F I1 + I6 T I9 * I7 F I10 , $ ) // r3 \n( I0 F I1 + I6 T I9 , $ ) //  \n</code></pre>\n<h3><code>i*(i+i)</code></h3>\n<p>(略)</p>\n<h3><code> i*i+*i</code></h3>\n<p>(略)</p>\n<style>\n.article.markdown-body table th {\n  min-width: 0px;\n}\n.article.markdown-body table td {\n  min-width: 0px;\n}\n</style>\n","content_text":"以下、過去の自分向けのメモの移動。\n\nコンパイラの主要な処理に構文解析がある。\n前回はLR0文法構文解析を行った。\n\n今回は与えられたLALR(1)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。\n\n問題の文法規則\n\n次のLALR(1)文法規則を受理するオートマトンと構文解析表をつくり、構文解析を行う。\n\n\n\nFirst集合\n\nFirst集合とは\n\nFirst(K) ... Kの還元前の終端記号列において、先頭に来る可能性のある終端記号の集合\n\nFirst集合の求め方\n\n最初は空集合とする\n\n非終端記号\n\nFirst(K) (K..非終端記号)について、\nKが左辺の文法規則が次の2つだったとき\n\nK -> abc...\n\nK -> PqRs...\n\nFirst(K) = First(K) + First(a) + First(P)\n\n終端記号\n\nFirst(k) (k...終端記号)について、\nFirst(k) = { k }\n\n今回の問題におけるFirst集合\n\nFirst(E) = First(T) = First(F) = { i ( }\n\nFollow集合\n\nFollow集合とは\n\nFollow(K) ... Kの次に来る可能性のある終端記号の集合\n\nFollow集合の求め方\n\n最初は{}\n開始記号のFollow集合に$を加える\n\nFollow(K)について\n\n文法規則 A -> wK (wは任意の文字列)ならば\nFollow(K) += Follow(A) \n\n文法規則 A -> wKBかつ First(B)∋ε ならば\nFollow(K) += Follow(A)\n\n文法規則 A -> xKy (y≠ε) ならば\nFollow(K) += First(y)\n\n今回の問題におけるFollow集合\n\n\n\nLALR(1)正準集合\n\nI0\n\n\n\nI1\n\n\n\nI2\n\n\n\nI3\n\n\n\nI4\n\n\n\nI5\n\n\n\nI6\n\n\n\nI7\n\n\n\nI8\n\n\n\nI9\n\n\n\nI10\n\n\n\nI11\n\n\n\nオートマトン\n\n以上より、与えられた文法規則を満たす系列を受理するオートマトンをつくる。\n\n\n\n構文解析表\n\nオートマトンを構文解析表にまとめる。\n\n\n\n構文解析\n\n上記の構文解析表に従い、次のような系列を構文解析する。\n\ni+i\\*i\n\n\n\ni\\*(i+i)\n\n(略)\n\n i\\*i+\\*i\n\n(略)\n\n"},{"id":"http://localhost:3000/posts/compiler-lr0","url":"http://localhost:3000/posts/compiler-lr0","title":"LR(0)構文解析を行いながら、コンパイラの構文解析を学ぶ","summary":"以下、過去の自分向けのメモの移動。 コンパイラの主要な処理に構文解析がある。 今回は与えられたLR(0)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。 問題 次の文法について、次の問を答えよ 上から順にR1,R2,R3,R4と呼ぶ。 ただし、SとLは非終端記号、(と)と,とaは終端記号とする。 LR(0)正準集合とオートマトンを求めよ 以下の文字列が示された文法から生成されるかどうか、また構文解析の結果を答えよ LR(0)構文解析の方法 LR(k)構文解析とは 上向き構文解析(下向きは再帰的に行うが、バックトラックが発生するため大変) 左(Left)から読み","date_published":"2020-08-14T19:04:31+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:LR(0)%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E3%82%92%E8%A1%8C%E3%81%84%E3%81%AA%E3%81%8C%E3%82%89%E3%80%81%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E3%82%92%E5%AD%A6%E3%81%B6,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","構文解析"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/bfdd8f2c844a9e1a0e8ccce07a8845d93e9998f2","comment":"Fix table width\n","date_modified":"2020-10-04T21:32:44+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae0ea8e11aa1de2b26cd27c1e9c046d2fb9135f4","comment":"Add articles\n","date_modified":"2020-08-14T22:40:26+09:00"}],"content_html":"<p>以下、過去の自分向けのメモの移動。</p>\n<p>コンパイラの主要な処理に構文解析がある。\n今回は与えられたLR(0)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。</p>\n<h2>問題</h2>\n<p>次の文法について、次の問を答えよ</p>\n<pre><code>S -> ( L ) \nS -> a\nL -> L , S\nL -> S\n</code></pre>\n<p>上から順にR1,R2,R3,R4と呼ぶ。</p>\n<p>ただし、SとLは非終端記号、(と)と,とaは終端記号とする。</p>\n<ul>\n<li>LR(0)正準集合とオートマトンを求めよ</li>\n<li>以下の文字列が示された文法から生成されるかどうか、また構文解析の結果を答えよ</li>\n</ul>\n<h2>LR(0)構文解析の方法</h2>\n<h3>LR(k)構文解析とは</h3>\n<ul>\n<li>上向き構文解析(下向きは再帰的に行うが、バックトラックが発生するため大変)</li>\n<li>左(Left)から読み、右端導出(Right most derivation)</li>\n<li>kとは、先読みできる記号の数</li>\n</ul>\n<h3>LR(0)構文解析の流れ</h3>\n<ol>\n<li>LR(0)正準集合とオートマトンをつくる</li>\n<li>構文解析表を作る</li>\n<li>構文解析表を元に解析する</li>\n</ol>\n<h3>方針: shiftまたはreduceを繰り返し、開始記号1つにまとまれば完了</h3>\n<ul>\n<li>shift: 入力を1つ読み込むこと</li>\n<li>reduce: 文法規則を適用し、記号をまとめること</li>\n</ul>\n<p>オートマトンの状態をスタックに積みながら、行う</p>\n<p>shiftするときは、入力を読み込み、入力記号に従い有向辺を遷移する。遷移後の状態をスタックにpushする。</p>\n<p>reduceするときは、適用する文法規則に則って、いままでの遷移を巻き戻し(スタックを記号数分popし)、適用後の記号の遷移を積み直す(pushする)。</p>\n<p>オートマトンを表にまとめ、情報を更かして、shift、reduceの手順を示したのが構文解析表である。</p>\n<h2>LR(0)におけるオートマトンの作成</h2>\n<h3>前提</h3>\n<h4>LR(0)項とは ... (アイテム記法)</h4>\n<p>文法規則の右辺、各記号の前後1箇所に・(ドット)を加えたもの。例えば<code>S -> ( ・L )</code>といった表記</p>\n<p>これは、ドットの前方は読み込み済みであること、ドットの後方は未読み込みであることを示す。</p>\n<p>(読み込むとは、ドットを1つ右に移動させること(ドットが1つ右のLR(0)項を含む状態に遷移すること(後術)であって、ドットの次が何の値であるか確認することではない)。</p>\n<h4>LR(0)正準集合とは</h4>\n<p>LR(0)項の集合である。\nオートマトンを作成する際に一緒に作成する。</p>\n<h4>LR(0)におけるオートマトンとは</h4>\n<p>LR(0)正準集合を状態、記号を1つもつ有向辺としたオートマトン。</p>\n<h3>LR(0)におけるオートマトンを作成する方法</h3>\n<h4>1. 初期状態を定める</h4>\n<p>状態には開始記号が左辺で、ドットが最左なLR(0)項をすべて含む。\n(※)を行う。</p>\n<h4>2. その他の状態を定める</h4>\n<p>既に存在する状態のドットが最右にないLR(0)項について、記号を一つ読み込んだ状態を新たにつくる。</p>\n<p>遷移の有向辺には、読み込む記号をもたせる。\n遷移後の状態は、記号を1つ読み込んだLR(0)項(ドットを1記号分右にずらしたLR(0)項)を含む。</p>\n<p>さらに、遷移前の状態の他のLR(0)項について考える。\n同じ記号を読み込める物があれば(遷移前のLR(0)項同士でドットの右隣の記号が一致すれば)、このLR(0)項についても、1記号読み込み後のLR(0)項を遷移後の状態に加える。</p>\n<p>(※)を行う。</p>\n<h4>3. 繰り返す</h4>\n<p>行える限り 2. を行う。</p>\n<h4>(※)</h4>\n<p>ある状態について、この状態に含むLR(0)項を考える。</p>\n<p>ドットの右隣に非終端記号のあるLR(0)項があるならば、その終端記号を左辺に持ちドットが最左であるLR(0)項をすべて同じ状態に加える。</p>\n<h3>作成したオートマトン</h3>\n<h4>状態遷移表</h4>\n<div class=\"remark-code-title\">dot</div>\n<pre><code class=\"hljs language-plaintext\">digraph G {\n  rankdir=LR;\n  empty [label = \"\" shape = plaintext];\n  node [shape = doublecircle];I2 I4;\n  node [shape = circle];\n  empty -> I0 [label = \"start\"];\n  I0 -> I1 [label = \"(\"];\n  I0 -> I2 [label = \"a\"];\n  I1 -> I2 [label = \"a\"];\n  I1 -> I3 [label = \"L\"];\n  I3 -> I4 [label = \")\"];\n  I3 -> I5 [label = \",\"];\n  I5 -> I7 [label = \"S\"];\n  I1 -> I1 [label = \"(\"];\n  I5 -> I1 [label = \"(\"];\n  I5 -> I2 [label = \"a\"];\n  I1 -> I6 [label = \"S\"];\n} </code></pre>\n<h4>状態I0</h4>\n<ul>\n<li><code>S -> ・( L )</code></li>\n<li><code>S -> ・a</code></li>\n</ul>\n<h4>状態I1</h4>\n<ul>\n<li><code>S -> ( ・L )</code> (・の右隣に非終端記号)</li>\n<li><code>L -> ・L , S</code></li>\n<li><code>L -> ・S</code> (・の右隣に非終端記号)</li>\n<li><code>S -> ・( L )</code></li>\n<li><code>S -> ・a</code></li>\n</ul>\n<h4>状態I2</h4>\n<ul>\n<li><code>S -> a ・</code></li>\n</ul>\n<h4>状態I3</h4>\n<ul>\n<li><code>S -> ( L ・)</code></li>\n<li><code>L -> L ・, S</code></li>\n</ul>\n<h4>状態I4</h4>\n<ul>\n<li><code>S -> ( L ) ・</code></li>\n</ul>\n<h4>状態I5</h4>\n<ul>\n<li><code>L -> L , ・S</code> (・の右隣に非終端記号)</li>\n<li><code>S -> ・( L )</code></li>\n<li><code>S -> ・a</code></li>\n</ul>\n<h4>状態I6</h4>\n<ul>\n<li><code>L -> S ・</code></li>\n</ul>\n<h4>状態I7</h4>\n<ul>\n<li><code>L -> L , S ・</code></li>\n</ul>\n<h2>構文解析表</h2>\n<p>現在の状態(スタックのトップ)の行、入力記号(読み込み前)の列のセルに、次の動作を書いた表。</p>\n<p>次の動作とは、次のようなものである。</p>\n<ul>\n<li>shiftするかreduceするか</li>\n<li>shiftならどの状態に遷移するか</li>\n<li>reduceならどの文法規則を適用するか</li>\n</ul>\n<h3>構文解析表のつくりかた</h3>\n<h4>1. 縦軸のラベル</h4>\n<p>縦軸にLR(0)正準集合を置く</p>\n<h4>2. 横軸のラベル</h4>\n<p>横軸に記号を置く。(このとき、終端記号と非終端記号は分ける、。終端記号に$(入力の終了を表す)を加える)</p>\n<h4>3. shift</h4>\n<p>遷移元の状態を行、遷移時の終端記号を列とするセルに、skと書き込む。(状態Ikに遷移する)</p>\n<p>shift(入力を1つ読み込む)して、スタックにkを積む(状態Ikに遷移する)ことを表す。</p>\n<h4>4. reduce時のpushする(積み直す)状態</h4>\n<p>遷移元の状態を行、遷移時の非終端記号を列とするセルに、kと書き込む。(状態Ikに遷移する)</p>\n<p>reduce時、還元後の状態(文法規則の左辺)をスタックに積み直す動作を表す。</p>\n<h4>5. reduce時の適用する文法規則</h4>\n<p>最右がドットであるLR(0)項を含む状態の行、終端記号の列にrkと書き込む。(文法規則Rkを適用する)</p>\n<h4>6. 完了状態</h4>\n<p>左辺が開始記号で右辺のドットが最右であるLR(0)項を含む状態の行\n、$(入力終了)の列のセルに、accと書き込む。</p>\n<p>accを参照したら構文が正しいことが示され、構文解析を終了する。</p>\n<h3>構文解析表の作成結果</h3>\n<p>今回の構文解析表は次の通り</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">I\\記号</th>\n<th>(</th>\n<th>)</th>\n<th>,</th>\n<th>a</th>\n<th>$</th>\n<th>S</th>\n<th>L</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">0</td>\n<td>s1</td>\n<td></td>\n<td></td>\n<td>s2</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td>s1</td>\n<td></td>\n<td></td>\n<td>s2</td>\n<td></td>\n<td>6</td>\n<td>3</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td>r2</td>\n<td>r2</td>\n<td>r2</td>\n<td>r2</td>\n<td>acc</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td></td>\n<td>s4</td>\n<td>s5</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td>r1</td>\n<td>r1</td>\n<td>r1</td>\n<td>r1</td>\n<td>acc</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td>s1</td>\n<td></td>\n<td></td>\n<td>s2</td>\n<td></td>\n<td>7</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td>r4</td>\n<td>r4</td>\n<td>r4</td>\n<td>r4</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td>r3</td>\n<td>r3</td>\n<td>r3</td>\n<td>r3</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>余談:構文解析表が表すもの</h3>\n<p>構文解析表の持つ情報は、次の3つに分けられる</p>\n<h4>1. オートマトンの状態遷移表</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">I\\記号</th>\n<th>(</th>\n<th>)</th>\n<th>,</th>\n<th>a</th>\n<th>S</th>\n<th>L</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">0</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>2</td>\n<td>6</td>\n<td>3</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td></td>\n<td>4</td>\n<td>5</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td>2</td>\n<td></td>\n<td>7</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h4>2. reduce可能状態と適用する文法規則</h4>\n<p>I2のとき、文法規則R2を適用する。\nI4のとき、文法規則R1を適用する。\nI6のとき、文法規則R4を適用する。\nI3のとき、文法規則R3を適用する。</p>\n<h4>3. 完了状態</h4>\n<p>I2,I4で全て読み込み済みのとき、構文解析が完了する。</p>\n<h2>構文解析</h2>\n<p>状態を記録するスタックを用意して、スタックトップと次の入力をもとに、動作を行う。</p>\n<h3>構文解析の方法</h3>\n<h4>1. 初期状態Ikであるとき、kをスタックに積む</h4>\n<h4>2. スタックtopの状態の行、次の入力記号の列のセルの指示に従う</h4>\n<h5>sk</h5>\n<p>shiftする。</p>\n<ul>\n<li>入力を読み取る。(次の動作のとき入力を次の終端記号にすすめる)</li>\n<li>スタックにkを積む</li>\n</ul>\n<p>(オートマトンにおいて、入力の終端記号を辺とする状態遷移を行う)</p>\n<h5>rk</h5>\n<p>文法規則Rkに従ってreduceする。</p>\n<ul>\n<li>文法Rkを適用することを記録する。</li>\n<li>文法Rkの右辺の記号数分、スタックをpopする。(状態遷移を巻き戻す)</li>\n<li>上行のpop後のスタックトップの状態を行、文法Rkの左側の記号を列とするセルの数字をスタックにpushする。(文法Rk左側の記号の状態遷移を積み直す)</li>\n</ul>\n<h5>acc</h5>\n<p>構文解析は成功。入力の分は、与えられた文法規則から生成される。\n構文解析を終了する。</p>\n<p>適用すべき文法規則とその順は、記録された文法規則Rkを順に読む。</p>\n<h5>空</h5>\n<p>構文解析は失敗。入力の文は、与えられた文法規則から生成されることはない。</p>\n<h3>構文解析の結果</h3>\n<p>次の文を構文解析する。</p>\n<p>上から順に、解析の経過を記す。</p>\n<h4><code>((a,a),a)</code></h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">入力</th>\n<th>スタックtop</th>\n<th>操作</th>\n<th align=\"left\">スタック</th>\n<th align=\"left\">読み取り済み</th>\n<th align=\"left\">還元後</th>\n<th align=\"left\">文法規則</th>\n<th align=\"left\">補足</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td align=\"left\">0</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>0</td>\n<td>s1</td>\n<td align=\"left\">01</td>\n<td align=\"left\">(</td>\n<td align=\"left\">(</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>1</td>\n<td>s1</td>\n<td align=\"left\">011</td>\n<td align=\"left\">((</td>\n<td align=\"left\">((</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">0112</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((a</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">0116</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((S</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">01135</td>\n<td align=\"left\">((a,</td>\n<td align=\"left\">((L,</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">011352</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L,a</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">011357</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L,S</td>\n<td align=\"left\">242</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">01134</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">((L)</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">016</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">(S</td>\n<td align=\"left\">24231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135</td>\n<td align=\"left\">((a,a),</td>\n<td align=\"left\">(L,</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">01352</td>\n<td align=\"left\">((a,a),a</td>\n<td align=\"left\">(L,a</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01357</td>\n<td align=\"left\">((a,a),a</td>\n<td align=\"left\">(L,S</td>\n<td align=\"left\">2423142</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013</td>\n<td align=\"left\">((a,a),a</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">24231423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0134</td>\n<td align=\"left\">((a,a),a)</td>\n<td align=\"left\">(L)</td>\n<td align=\"left\">24231423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td>4</td>\n<td>acc</td>\n<td align=\"left\">0134</td>\n<td align=\"left\">((a,a),a)$</td>\n<td align=\"left\">S</td>\n<td align=\"left\">242314231</td>\n<td align=\"left\">accのときも文法規則r1は適用する。</td>\n</tr>\n</tbody>\n</table>\n<p>以上より、与えられた文は、問題の文法規則から生成されることが示された。</p>\n<h4><code>((a,a),(a,a))</code></h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">入力</th>\n<th>スタックtop</th>\n<th>操作</th>\n<th align=\"left\">スタック</th>\n<th align=\"left\">読み取り済み</th>\n<th align=\"left\">還元後</th>\n<th align=\"left\">文法規則</th>\n<th align=\"left\">補足</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td align=\"left\">0</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>0</td>\n<td>s1</td>\n<td align=\"left\">01</td>\n<td align=\"left\">(</td>\n<td align=\"left\">(</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>1</td>\n<td>s1</td>\n<td align=\"left\">011</td>\n<td align=\"left\">((</td>\n<td align=\"left\">((</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">0112</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((a</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">0116</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((S</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">((a</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">01135</td>\n<td align=\"left\">((a,</td>\n<td align=\"left\">((L,</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">011352</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L,a</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">011357</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L,S</td>\n<td align=\"left\">242</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">((a,a</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">01134</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">((L)</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">016</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">(S</td>\n<td align=\"left\">24231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013</td>\n<td align=\"left\">((a,a)</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135</td>\n<td align=\"left\">((a,a),</td>\n<td align=\"left\">(L,</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>5</td>\n<td>s1</td>\n<td align=\"left\">01351</td>\n<td align=\"left\">((a,a),(</td>\n<td align=\"left\">(L,(</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">013512</td>\n<td align=\"left\">((a,a),(a</td>\n<td align=\"left\">(L,(a</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">013516</td>\n<td align=\"left\">((a,a),(a</td>\n<td align=\"left\">(L,(S</td>\n<td align=\"left\">2423142</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013513</td>\n<td align=\"left\">((a,a),(a</td>\n<td align=\"left\">(L,(L</td>\n<td align=\"left\">24231424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135135</td>\n<td align=\"left\">((a,a),(a,</td>\n<td align=\"left\">(L,(L,</td>\n<td align=\"left\">24231424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">01351352</td>\n<td align=\"left\">((a,a),(a,a</td>\n<td align=\"left\">(L,(L,a</td>\n<td align=\"left\">24231424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01351357</td>\n<td align=\"left\">((a,a),(a,a</td>\n<td align=\"left\">(L,(L,S</td>\n<td align=\"left\">242314242</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013516</td>\n<td align=\"left\">((a,a),(a,a</td>\n<td align=\"left\">(L,(S</td>\n<td align=\"left\">2423142423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013513</td>\n<td align=\"left\">((a,a),(a,a</td>\n<td align=\"left\">(L,(L</td>\n<td align=\"left\">24231424234</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0135134</td>\n<td align=\"left\">((a,a),(a,a)</td>\n<td align=\"left\">(L,(L)</td>\n<td align=\"left\">24231424234</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">01357</td>\n<td align=\"left\">((a,a),(a,a)</td>\n<td align=\"left\">(L,S</td>\n<td align=\"left\">242314242341</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013</td>\n<td align=\"left\">((a,a),(a,a)</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">2423142423413</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0134</td>\n<td align=\"left\">((a,a),(a,a))</td>\n<td align=\"left\">(L)</td>\n<td align=\"left\">2423142423413</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td>4</td>\n<td>acc</td>\n<td align=\"left\">0</td>\n<td align=\"left\">((a,a),(a,a))</td>\n<td align=\"left\">S</td>\n<td align=\"left\">24231424234131</td>\n<td align=\"left\">accのときも文法規則r1は適用する。</td>\n</tr>\n</tbody>\n</table>\n<p>以上より、与えられた文は、問題の文法規則から生成されることが示された。</p>\n<h4><code>(a,(a,a),a)</code></h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">入力</th>\n<th>スタックtop</th>\n<th>操作</th>\n<th align=\"left\">スタック</th>\n<th align=\"left\">読み取り済み</th>\n<th align=\"left\">還元後</th>\n<th align=\"left\">文法規則</th>\n<th align=\"left\">補足</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td align=\"left\">0</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>0</td>\n<td>s1</td>\n<td align=\"left\">01</td>\n<td align=\"left\">(</td>\n<td align=\"left\">(</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">012</td>\n<td align=\"left\">(a</td>\n<td align=\"left\">(a</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">016</td>\n<td align=\"left\">(a</td>\n<td align=\"left\">(S</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013</td>\n<td align=\"left\">(a</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135</td>\n<td align=\"left\">(a,</td>\n<td align=\"left\">(L,</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>5</td>\n<td>s1</td>\n<td align=\"left\">01351</td>\n<td align=\"left\">(a,(</td>\n<td align=\"left\">(L,(</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">013512</td>\n<td align=\"left\">(a,(a</td>\n<td align=\"left\">(L,(a</td>\n<td align=\"left\">4</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">013516</td>\n<td align=\"left\">(a,(a</td>\n<td align=\"left\">(L,(S</td>\n<td align=\"left\">42</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">013513</td>\n<td align=\"left\">(a,(a</td>\n<td align=\"left\">(L,(L</td>\n<td align=\"left\">424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135135</td>\n<td align=\"left\">(a,(a,</td>\n<td align=\"left\">(L,(L,</td>\n<td align=\"left\">424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">01351352</td>\n<td align=\"left\">(a,(a,a</td>\n<td align=\"left\">(L,(L,a</td>\n<td align=\"left\">424</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01351357</td>\n<td align=\"left\">(a,(a,a</td>\n<td align=\"left\">(L,(L,S</td>\n<td align=\"left\">4242</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013513</td>\n<td align=\"left\">(a,(a,a</td>\n<td align=\"left\">(L,(L</td>\n<td align=\"left\">42423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0135134</td>\n<td align=\"left\">(a,(a,a)</td>\n<td align=\"left\">(L,(L)</td>\n<td align=\"left\">42423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">01357</td>\n<td align=\"left\">(a,(a,a)</td>\n<td align=\"left\">(L,S</td>\n<td align=\"left\">424231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013</td>\n<td align=\"left\">(a,(a,a)</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">4242313</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135</td>\n<td align=\"left\">(a,(a,a),</td>\n<td align=\"left\">(L,</td>\n<td align=\"left\">4242313</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">01352</td>\n<td align=\"left\">(a,(a,a),a</td>\n<td align=\"left\">(L,a</td>\n<td align=\"left\">4242313</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01357</td>\n<td align=\"left\">(a,(a,a),a</td>\n<td align=\"left\">(L,S</td>\n<td align=\"left\">42423132</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013</td>\n<td align=\"left\">(a,(a,a),a</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">424231323</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0134</td>\n<td align=\"left\">(a,(a,a),a)</td>\n<td align=\"left\">(L)</td>\n<td align=\"left\">424231323</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td>4</td>\n<td>acc</td>\n<td align=\"left\">0</td>\n<td align=\"left\">(a,(a,a),a)</td>\n<td align=\"left\">S</td>\n<td align=\"left\">4242313231</td>\n<td align=\"left\"></td>\n</tr>\n</tbody>\n</table>\n<h4><code>(((a,a),a),a)</code></h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">入力</th>\n<th>スタックtop</th>\n<th>操作</th>\n<th align=\"left\">スタック</th>\n<th align=\"left\">読み取り済み</th>\n<th align=\"left\">還元後</th>\n<th align=\"left\">文法規則</th>\n<th align=\"left\">補足</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"></td>\n<td></td>\n<td></td>\n<td align=\"left\">0</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>0</td>\n<td>s1</td>\n<td align=\"left\">01</td>\n<td align=\"left\">(</td>\n<td align=\"left\">(</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>1</td>\n<td>s1</td>\n<td align=\"left\">011</td>\n<td align=\"left\">((</td>\n<td align=\"left\">((</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td>1</td>\n<td>s1</td>\n<td align=\"left\">0111</td>\n<td align=\"left\">(((</td>\n<td align=\"left\">(((</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>1</td>\n<td>s2</td>\n<td align=\"left\">01112</td>\n<td align=\"left\">(((a</td>\n<td align=\"left\">(((a</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01116</td>\n<td align=\"left\">(((a</td>\n<td align=\"left\">(((S</td>\n<td align=\"left\">2</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">01113</td>\n<td align=\"left\">(((a</td>\n<td align=\"left\">(((L</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">011135</td>\n<td align=\"left\">(((a,</td>\n<td align=\"left\">(((L,</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">0111352</td>\n<td align=\"left\">(((a,a</td>\n<td align=\"left\">(((L,a</td>\n<td align=\"left\">24</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">0111357</td>\n<td align=\"left\">(((a,a</td>\n<td align=\"left\">(((L,S</td>\n<td align=\"left\">242</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">01113</td>\n<td align=\"left\">(((a,a</td>\n<td align=\"left\">(((L</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">011134</td>\n<td align=\"left\">(((a,a)</td>\n<td align=\"left\">(((L)</td>\n<td align=\"left\">2423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">0116</td>\n<td align=\"left\">(((a,a)</td>\n<td align=\"left\">((S</td>\n<td align=\"left\">24231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>6</td>\n<td>r4</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">(((a,a)</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">01135</td>\n<td align=\"left\">(((a,a),</td>\n<td align=\"left\">((L,</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">011352</td>\n<td align=\"left\">(((a,a),a</td>\n<td align=\"left\">((L,a</td>\n<td align=\"left\">242314</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">011357</td>\n<td align=\"left\">(((a,a),a</td>\n<td align=\"left\">((L,S</td>\n<td align=\"left\">2423142</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">0113</td>\n<td align=\"left\">(((a,a),a</td>\n<td align=\"left\">((L</td>\n<td align=\"left\">24231423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">01134</td>\n<td align=\"left\">(((a,a),a)</td>\n<td align=\"left\">((L)</td>\n<td align=\"left\">24231423</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>4</td>\n<td>r1</td>\n<td align=\"left\">013</td>\n<td align=\"left\">(((a,a),a)</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">242314231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td>3</td>\n<td>s5</td>\n<td align=\"left\">0135</td>\n<td align=\"left\">(((a,a),a),</td>\n<td align=\"left\">(L,</td>\n<td align=\"left\">242314231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">a</td>\n<td>5</td>\n<td>s2</td>\n<td align=\"left\">01352</td>\n<td align=\"left\">(((a,a),a),a</td>\n<td align=\"left\">(L,a</td>\n<td align=\"left\">242314231</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>2</td>\n<td>r2</td>\n<td align=\"left\">01357</td>\n<td align=\"left\">(((a,a),a),a</td>\n<td align=\"left\">(L,S</td>\n<td align=\"left\">2423142312</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>7</td>\n<td>r3</td>\n<td align=\"left\">013</td>\n<td align=\"left\">(((a,a),a),a</td>\n<td align=\"left\">(L</td>\n<td align=\"left\">24231423123</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">)</td>\n<td>3</td>\n<td>s4</td>\n<td align=\"left\">0134</td>\n<td align=\"left\">(((a,a),a),a)</td>\n<td align=\"left\">(L)</td>\n<td align=\"left\">24231423123</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td>4</td>\n<td>acc</td>\n<td align=\"left\">0</td>\n<td align=\"left\">(((a,a),a),a)</td>\n<td align=\"left\">S</td>\n<td align=\"left\">242314231231</td>\n<td align=\"left\"></td>\n</tr>\n</tbody>\n</table>\n<p>以上より、与えられた文は、問題の文法規則から生成されることが示された。</p>\n<style>\n.article.markdown-body table th {\n  min-width: 0px;\n}\n.article.markdown-body table td {\n  min-width: 0px;\n}\n</style>\n","content_text":"以下、過去の自分向けのメモの移動。\n\nコンパイラの主要な処理に構文解析がある。\n今回は与えられたLR(0)文法規則に基づいて構文解析するオートマトンを作り、構文解析の手法について整理する。\n\n問題\n\n次の文法について、次の問を答えよ\n\n\n\n上から順にR1,R2,R3,R4と呼ぶ。\n\nただし、SとLは非終端記号、(と)と,とaは終端記号とする。\n\nLR(0)正準集合とオートマトンを求めよ\n\n以下の文字列が示された文法から生成されるかどうか、また構文解析の結果を答えよ\n\nLR(0)構文解析の方法\n\nLR(k)構文解析とは\n\n上向き構文解析(下向きは再帰的に行うが、バックトラックが発生するため大変)\n\n左(Left)から読み、右端導出(Right most derivation)\n\nkとは、先読みできる記号の数\n\nLR(0)構文解析の流れ\n\nLR(0)正準集合とオートマトンをつくる\n\n構文解析表を作る\n\n構文解析表を元に解析する\n\n方針: shiftまたはreduceを繰り返し、開始記号1つにまとまれば完了\n\nshift: 入力を1つ読み込むこと\n\nreduce: 文法規則を適用し、記号をまとめること\n\nオートマトンの状態をスタックに積みながら、行う\n\nshiftするときは、入力を読み込み、入力記号に従い有向辺を遷移する。遷移後の状態をスタックにpushする。\n\nreduceするときは、適用する文法規則に則って、いままでの遷移を巻き戻し(スタックを記号数分popし)、適用後の記号の遷移を積み直す(pushする)。\n\nオートマトンを表にまとめ、情報を更かして、shift、reduceの手順を示したのが構文解析表である。\n\nLR(0)におけるオートマトンの作成\n\n前提\n\nLR(0)項とは ... (アイテム記法)\n\n文法規則の右辺、各記号の前後1箇所に・(ドット)を加えたもの。例えばS -> ( ・L )といった表記\n\nこれは、ドットの前方は読み込み済みであること、ドットの後方は未読み込みであることを示す。\n\n(読み込むとは、ドットを1つ右に移動させること(ドットが1つ右のLR(0)項を含む状態に遷移すること(後術)であって、ドットの次が何の値であるか確認することではない)。\n\nLR(0)正準集合とは\n\nLR(0)項の集合である。\nオートマトンを作成する際に一緒に作成する。\n\nLR(0)におけるオートマトンとは\n\nLR(0)正準集合を状態、記号を1つもつ有向辺としたオートマトン。\n\nLR(0)におけるオートマトンを作成する方法\n\n1\\. 初期状態を定める\n\n状態には開始記号が左辺で、ドットが最左なLR(0)項をすべて含む。\n(※)を行う。\n\n2\\. その他の状態を定める\n\n既に存在する状態のドットが最右にないLR(0)項について、記号を一つ読み込んだ状態を新たにつくる。\n\n遷移の有向辺には、読み込む記号をもたせる。\n遷移後の状態は、記号を1つ読み込んだLR(0)項(ドットを1記号分右にずらしたLR(0)項)を含む。\n\nさらに、遷移前の状態の他のLR(0)項について考える。\n同じ記号を読み込める物があれば(遷移前のLR(0)項同士でドットの右隣の記号が一致すれば)、このLR(0)項についても、1記号読み込み後のLR(0)項を遷移後の状態に加える。\n\n(※)を行う。\n\n3\\. 繰り返す\n\n行える限り 2. を行う。\n\n(※)\n\nある状態について、この状態に含むLR(0)項を考える。\n\nドットの右隣に非終端記号のあるLR(0)項があるならば、その終端記号を左辺に持ちドットが最左であるLR(0)項をすべて同じ状態に加える。\n\n作成したオートマトン\n\n状態遷移表\n\n\n\n状態I0\n\nS -> ・( L )\n\nS -> ・a\n\n状態I1\n\nS -> ( ・L ) (・の右隣に非終端記号)\n\nL -> ・L , S\n\nL -> ・S (・の右隣に非終端記号)\n\nS -> ・( L )\n\nS -> ・a\n\n状態I2\n\nS -> a ・\n\n状態I3\n\nS -> ( L ・)\n\nL -> L ・, S\n\n状態I4\n\nS -> ( L ) ・\n\n状態I5\n\nL -> L , ・S (・の右隣に非終端記号)\n\nS -> ・( L )\n\nS -> ・a\n\n状態I6\n\nL -> S ・\n\n状態I7\n\nL -> L , S ・\n\n構文解析表\n\n現在の状態(スタックのトップ)の行、入力記号(読み込み前)の列のセルに、次の動作を書いた表。\n\n次の動作とは、次のようなものである。\n\nshiftするかreduceするか\n\nshiftならどの状態に遷移するか\n\nreduceならどの文法規則を適用するか\n\n構文解析表のつくりかた\n\n1\\. 縦軸のラベル\n\n縦軸にLR(0)正準集合を置く\n\n2\\. 横軸のラベル\n\n横軸に記号を置く。(このとき、終端記号と非終端記号は分ける、。終端記号に$(入力の終了を表す)を加える)\n\n3\\. shift\n\n遷移元の状態を行、遷移時の終端記号を列とするセルに、skと書き込む。(状態Ikに遷移する)\n\nshift(入力を1つ読み込む)して、スタックにkを積む(状態Ikに遷移する)ことを表す。\n\n4\\. reduce時のpushする(積み直す)状態\n\n遷移元の状態を行、遷移時の非終端記号を列とするセルに、kと書き込む。(状態Ikに遷移する)\n\nreduce時、還元後の状態(文法規則の左辺)をスタックに積み直す動作を表す。\n\n5\\. reduce時の適用する文法規則\n\n最右がドットであるLR(0)項を含む状態の行、終端記号の列にrkと書き込む。(文法規則Rkを適用する)\n\n6\\. 完了状態\n\n左辺が開始記号で右辺のドットが最右であるLR(0)項を含む状態の行\n、$(入力終了)の列のセルに、accと書き込む。\n\naccを参照したら構文が正しいことが示され、構文解析を終了する。\n\n構文解析表の作成結果\n\n今回の構文解析表は次の通り\n\n\n\n余談:構文解析表が表すもの\n\n構文解析表の持つ情報は、次の3つに分けられる\n\n1\\. オートマトンの状態遷移表\n\n\n\n2\\. reduce可能状態と適用する文法規則\n\nI2のとき、文法規則R2を適用する。\nI4のとき、文法規則R1を適用する。\nI6のとき、文法規則R4を適用する。\nI3のとき、文法規則R3を適用する。\n\n3\\. 完了状態\n\nI2,I4で全て読み込み済みのとき、構文解析が完了する。\n\n構文解析\n\n状態を記録するスタックを用意して、スタックトップと次の入力をもとに、動作を行う。\n\n構文解析の方法\n\n1\\. 初期状態Ikであるとき、kをスタックに積む\n\n2\\. スタックtopの状態の行、次の入力記号の列のセルの指示に従う\n\nsk\n\nshiftする。\n\n入力を読み取る。(次の動作のとき入力を次の終端記号にすすめる)\n\nスタックにkを積む\n\n(オートマトンにおいて、入力の終端記号を辺とする状態遷移を行う)\n\nrk\n\n文法規則Rkに従ってreduceする。\n\n文法Rkを適用することを記録する。\n\n文法Rkの右辺の記号数分、スタックをpopする。(状態遷移を巻き戻す)\n\n上行のpop後のスタックトップの状態を行、文法Rkの左側の記号を列とするセルの数字をスタックにpushする。(文法Rk左側の記号の状態遷移を積み直す)\n\nacc\n\n構文解析は成功。入力の分は、与えられた文法規則から生成される。\n構文解析を終了する。\n\n適用すべき文法規則とその順は、記録された文法規則Rkを順に読む。\n\n空\n\n構文解析は失敗。入力の文は、与えられた文法規則から生成されることはない。\n\n構文解析の結果\n\n次の文を構文解析する。\n\n上から順に、解析の経過を記す。\n\n((a,a),a)\n\n\n\n以上より、与えられた文は、問題の文法規則から生成されることが示された。\n\n((a,a),(a,a))\n\n\n\n以上より、与えられた文は、問題の文法規則から生成されることが示された。\n\n(a,(a,a),a)\n\n\n\n(((a,a),a),a)\n\n\n\n以上より、与えられた文は、問題の文法規則から生成されることが示された。\n\n"},{"id":"http://localhost:3000/posts/docker","url":"http://localhost:3000/posts/docker","title":"Dockerチートシート プログラマのためのDocker教科書 第2版より","summary":"以下、過去の自分用メモの移動。 dockerに入門するにあたり「プログラマのためのDocker教科書 第2版より」を読んだ。 Dockerfileを書いてコンテナを走らせるための自分向けのまとめをチートシート的に書き記す。 Dockerfileの命令 命令一覧 FROM .. ベースイメージの指定 RUN .. コマンド実行 CMD .. コンテナの実行コマンド LABEL .. ラベルを設定 EXPOSE .. ポートのエクスポート ENV .. 環境変数 ADD .. ファイル/ディレクトリの追加 COPY .. ファイルのコピー ENTRYPOINT .. コンテナの実行コマンド VOL","date_published":"2020-08-14T18:59:31+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Docker%E3%83%81%E3%83%BC%E3%83%88%E3%82%B7%E3%83%BC%E3%83%88%20%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AEDocker%E6%95%99%E7%A7%91%E6%9B%B8%20%E7%AC%AC2%E7%89%88%E3%82%88%E3%82%8A,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Docker","Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae0ea8e11aa1de2b26cd27c1e9c046d2fb9135f4","comment":"Add articles\n","date_modified":"2020-08-14T22:40:26+09:00"}],"content_html":"<p>以下、過去の自分用メモの移動。</p>\n<p>dockerに入門するにあたり「プログラマのためのDocker教科書 第2版より」を読んだ。\nDockerfileを書いてコンテナを走らせるための自分向けのまとめをチートシート的に書き記す。</p>\n<h2>Dockerfileの命令</h2>\n<h3>命令一覧</h3>\n<ul>\n<li>FROM .. ベースイメージの指定</li>\n<li>RUN .. コマンド実行</li>\n<li>CMD .. コンテナの実行コマンド</li>\n<li>LABEL .. ラベルを設定</li>\n<li>EXPOSE .. ポートのエクスポート</li>\n<li>ENV .. 環境変数</li>\n<li>ADD .. ファイル/ディレクトリの追加</li>\n<li>COPY .. ファイルのコピー</li>\n<li>ENTRYPOINT .. コンテナの実行コマンド</li>\n<li>VOLUME .. ボリュームのマウント</li>\n<li>USER .. ユーザの指定</li>\n<li>WORKDIR .. 作業ディレクトリ</li>\n<li>ARG .. Dockerfile内の変数</li>\n<li>ONBUILD .. ビルド完了後に実行される命令</li>\n<li>STOPSIGNAL .. システムコールシグナルの設定</li>\n<li>HEALTHCHECK .. コンテナのヘルスチェック</li>\n<li>SHELL .. デフォルトシェルの設定</li>\n</ul>\n<h3>コメント</h3>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-comment\"># コメント</span>\n命令 <span class=\"hljs-comment\"># コメント</span></code></pre>\n<h3>FROM</h3>\n<pre><code class=\"hljs language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> centos:<span class=\"hljs-number\">7</span>\n<span class=\"hljs-comment\"># FROM [イメージ名]</span>\n<span class=\"hljs-comment\"># FROM [イメージ名]:[タグ名]</span>\n<span class=\"hljs-comment\"># FROM [イメージ名]@[ダイジェスト]</span></code></pre>\n<h4>ダイジェスト</h4>\n<p>Docker Hubにアップロードする際に自動で付与されるユニークな識別子。\nダイジェストを使うことでイメージを一意に指定できる。\n<code>docker image ls --digests</code>で確認できる</p>\n<h3>build</h3>\n<pre><code class=\"hljs language-bash\">$ docker build -t [作成するイメージ名]:[タグ名] [Dockerfileのあるディレクトリのパス]</code></pre>\n<h2>docker engineの状態を確認</h2>\n<pre><code>$ docker version\n$ docker tutorial\n$ docker system info\n$ docker system df\n# disk info\n</code></pre>\n<h2>nginxをdockerで動かしてみる</h2>\n<pre><code>$ docker pull nginx\n$ docker image ls\n$ docker container run --name nginxserver -d -p 80:80 nginx\n# open http://localhost:80/ on web browser\n$ docker ps\n$ docker stop nginxserver\n$ docker start nginxserver\n</code></pre>\n<h2>centosをpullしてみる</h2>\n<pre><code># p96\n$ docker image pull centos:7\n$ docker image ls\n</code></pre>\n<h2>DCT</h2>\n<p>docker imageが改ざんされているかどうか、公開鍵(Tagging Key)を用いて検証し、改ざんがある場合そのイメージを無効化する機能。</p>\n<p>有効化するには環境変数を付加</p>\n<p>署名なしイメージのpull時は無効化しなければならない。</p>\n<pre><code># enable\n$ export DOCKER_CONTENT_TRUST=1\n\n# disable\n$ export DOCKER_CONTENT_TRUST=0\n</code></pre>\n<h2>docker imageの操作</h2>\n<pre><code># pullしたイメージの詳細情報を確認(イメージID,作成日,dockerのversion,CPUアーキテクチャ等)\n$ docker image inspect ubuntu:latest\n\n# jsonの一部のみを取得\n$ docker image inspect --format=\"{{ .Os }}\" ubuntu:latest\n$ docker image inspect --format=\"{{ .ContainerConfig.Image }}\" ubuntu:latest\n\n# docker image にタグ付け\n$ docker image tag nginx yammerjp/nginxserver:1.0\n\n# docker hub上のimage(この場合はnginx)を検索\n$ docker search nginx \n# Option: --no-trunc .. 結果をすべて表示,  --limit n .. n件の検索結果, --filter=stars=n .. star数下限による絞り込み\n\n$ docker image rm [--force(-f) --no-prun] yammerjp/nginxserver\n# --force .. -f , --no-prune .. 中間イメージを削除しない\n# yammerjp/nginxserver ... REPOSITORYではなくIMAGE IDでも良い\n\n$ docker image prune [--all(-a) --force(-f)]\n# 未使用のdocker imageを削除\n</code></pre>\n<h2>docker image のpush</h2>\n<pre><code>$ docker login -u yammerjp -p xxx\n$ docker image push yammerjp/nginxserver:1.0\n$ docker logout\n</code></pre>\n<h2>docker container run</h2>\n<pre><code>$ docker container run [ option ] yammerjp/nginxserver\n$ docker run [ option ] yammerjp/nginxserver # containerは省略可能\n$ docker run -it --name \"test1\" ubuntu /bin/bash\n$ docker run -d -p 8080:80 nginx\n$ docker run -d --dns 8.8.8.8 nginx\n$ docker run -d --mac-address=\"92:d0:c6:0a:29:33\" ubuntu\n# $ docker container inspect --format=\"{{ .Config.MacAddress }}\" [Container ID]\n$docker run -id --add-host test.com:192.168.0.1 ubuntu\n</code></pre>\n<h3>実行開始時オプション</h3>\n<p>--attach(-a) STDIN/STDOUT/STDERR --cidfile --detach(-d) --interactive(-i) --tty(-t)</p>\n<ul>\n<li>-a .. 標準入力/標準出力/標準エラー出力にアタッチ</li>\n<li>-d .. バックグラウンドで実行</li>\n<li>-i .. コンテナの標準入力を開く</li>\n<li>-t .. 端末デバイスを使う</li>\n</ul>\n<h3>終了時オプション</h3>\n<ul>\n<li>--restart .. no (再起動しない)/ on-failure (終了ステータスが0でないなら再起動)/ on-failure:4 (終了ステータスが0でないなら4回再起動/ always (常に)/ unless-stopped (直前のコンテナの状態が停止状態でなければ再起動)</li>\n<li>--rm .. 実行後のコンテナを自動で削除(--restartオプションと排他)</li>\n</ul>\n<h3>ネットワークオプション</h3>\n<ul>\n<li>--add-host=localhost:127.0.0.1 ... コンテナの/etc/hostsにホスト名とIPアドレスを定義</li>\n<li>--dns=8.8.8.8 ... コンテナ用のDNSサーバのIPアドレス</li>\n<li>--expose .. 指定したレンジのポート番号を割り当てる</li>\n<li>--mac-address=FF:FF:FF:FF:FF:FF .. コンテナのMACアドレスを指定</li>\n<li>--net=[bridge | none | container:&#x3C;name | id > | host | NETWORK] .. コンテナのネットワークを指定</li>\n<li>--hostname(-h) .. コンテナ自信のホスト名を指定</li>\n<li>--publish(-p) [ホストのポート番号]:[コンテナのポート番号] .. ホストとコンテナのポートマッピング</li>\n<li>--publish-all(-P) .. ホストの任意のポートをコンテナに割り当てる</li>\n</ul>\n<h3>リソースオプション</h3>\n<ul>\n<li>--cpu-shares(-c) .. CPUの使用の配分(1024が100%)</li>\n<li>--memory(-m) .. 使用するメモリを制限(単位はb,k,m,gのいずれか)</li>\n<li>--volume(-v)=[ホストのディレクトリ]:[コンテナのディレクトリ] .. ディレクトリを共有</li>\n</ul>\n<h3>環境変数など</h3>\n<ul>\n<li>--env(-e)=[環境変数] .. 環境変数を設定</li>\n<li>--envfile=[ファイル名] .. fileから環境変数を設定</li>\n<li>--readonly=[true|false] .. コンテナのファイルシステムを読み込み専用にする</li>\n<li>--workdir(-w)=[パス] .. コンテナの作業ディレクトリを指定する</li>\n<li>--user(-u)=[ユーザ名] .. ユーザ名かUIDを指定する</li>\n</ul>\n<pre><code>$ docker run --cpu-shares=512 --memory=1g ubuntu\n$ docker run -v /Users/yammerjp/webap:/usr/share/nginx/html nginx\n</code></pre>\n<h2>docker network</h2>\n<pre><code>$ docker network create -d bridge webap-net\n$ docker container run --net=webap-net -it ubuntu\n\n$ docker network ls\n$ docker network connect [ option ] ネットワーク コンテナ\n$ docker network disconnect ネットワーク コンテナ\n$ docker network inspect [ option ] ネットワーク\n$ docker network rm [ option ] ネットワーク\n\n</code></pre>\n<h2>コンテナの状態確認</h2>\n<pre><code>$ docker container ls [ --all(-a) --filter(-f) --format --last -8 --latest -l --no-trunc --quiet(-q) --size(-s) ]\n# 稼働しているコンテナの状態一覧\n\n$ docker container stats コンテナ識別子\n# コンテナ稼働確認 識別子はnginxserver等 Ctrl+Cで終了\n\n$ docker container top コンテナ識別子\n# コンテナで実行中のプロセスを確認\n</code></pre>\n<h2>コンテナの状態変更</h2>\n<pre><code>$ docker container start[ --atatch(-a) --interactive(-i) ] コンテナ識別子\n$ docker container stop [ -time(-t) ..コンテナの停止時間を指定する(defaultは10s) ] コンテナ識別子\n$ docker container restart [ -time(-t) ..コンテナの再起動時間を指定する(defaultは10s) ] コンテナ識別子\n\n$ docker container pause コンテナ識別子\n$ docker container unpause コンテナ識別子\n</code></pre>\n<h2>others</h2>\n<pre><code>$ docker container rm [ --force(-f) .. 起動中のコンテナを強制的に削除 , --volumes(-v) .. 割り当てたボリュームを削除 ] コンテナ識別子\n\n$ docker container attach コンテナ識別子\n# 接続後、Ctrl+Cでコンテナごと終了、デタッチのみはCtrl+P -> Ctrl+Q\n\n$ docker container exec [ --detach(-d) --interactive(-i) --tty(-t) --user(-u) ] コンテナ識別子 実行コマンド\n\n$ docker container top\n\n$ docker container port # 転送されているポートの確認\n\n$ docker container cp コンテナ識別子:コンテナ内のファイルパス ホストのディレクトリパス # ファイルをコピー\n# cp以後を逆にすると、逆転送も可能\n\n$ docker container diff コンテナ識別子　\n# コンテナがイメージから作成されたときとの差分 A..ファイル追加 B..ファイル削除 C..ファイル更新\n\n$ docker container commit [オプション] コンテナ識別子 [イメージ名[:タグ名]\n\n</code></pre>\n","content_text":"以下、過去の自分用メモの移動。\n\ndockerに入門するにあたり「プログラマのためのDocker教科書 第2版より」を読んだ。\nDockerfileを書いてコンテナを走らせるための自分向けのまとめをチートシート的に書き記す。\n\nDockerfileの命令\n\n命令一覧\n\nFROM .. ベースイメージの指定\n\nRUN .. コマンド実行\n\nCMD .. コンテナの実行コマンド\n\nLABEL .. ラベルを設定\n\nEXPOSE .. ポートのエクスポート\n\nENV .. 環境変数\n\nADD .. ファイル/ディレクトリの追加\n\nCOPY .. ファイルのコピー\n\nENTRYPOINT .. コンテナの実行コマンド\n\nVOLUME .. ボリュームのマウント\n\nUSER .. ユーザの指定\n\nWORKDIR .. 作業ディレクトリ\n\nARG .. Dockerfile内の変数\n\nONBUILD .. ビルド完了後に実行される命令\n\nSTOPSIGNAL .. システムコールシグナルの設定\n\nHEALTHCHECK .. コンテナのヘルスチェック\n\nSHELL .. デフォルトシェルの設定\n\nコメント\n\n\n\nFROM\n\n\n\nダイジェスト\n\nDocker Hubにアップロードする際に自動で付与されるユニークな識別子。\nダイジェストを使うことでイメージを一意に指定できる。\ndocker image ls --digestsで確認できる\n\nbuild\n\n\n\ndocker engineの状態を確認\n\n\n\nnginxをdockerで動かしてみる\n\n\n\ncentosをpullしてみる\n\n\n\nDCT\n\ndocker imageが改ざんされているかどうか、公開鍵(Tagging Key)を用いて検証し、改ざんがある場合そのイメージを無効化する機能。\n\n有効化するには環境変数を付加\n\n署名なしイメージのpull時は無効化しなければならない。\n\n\n\ndocker imageの操作\n\n\n\ndocker image のpush\n\n\n\ndocker container run\n\n\n\n実行開始時オプション\n\n\\--attach(-a) STDIN/STDOUT/STDERR --cidfile --detach(-d) --interactive(-i) --tty(-t)\n\n\\-a .. 標準入力/標準出力/標準エラー出力にアタッチ\n\n\\-d .. バックグラウンドで実行\n\n\\-i .. コンテナの標準入力を開く\n\n\\-t .. 端末デバイスを使う\n\n終了時オプション\n\n\\--restart .. no (再起動しない)/ on-failure (終了ステータスが0でないなら再起動)/ on-failure:4 (終了ステータスが0でないなら4回再起動/ always (常に)/ unless-stopped (直前のコンテナの状態が停止状態でなければ再起動)\n\n\\--rm .. 実行後のコンテナを自動で削除(--restartオプションと排他)\n\nネットワークオプション\n\n\\--add-host=localhost:127.0.0.1 ... コンテナの/etc/hostsにホスト名とIPアドレスを定義\n\n\\--dns=8.8.8.8 ... コンテナ用のDNSサーバのIPアドレス\n\n\\--expose .. 指定したレンジのポート番号を割り当てる\n\n\\--mac-address=FF:FF:FF:FF:FF:FF .. コンテナのMACアドレスを指定\n\n\\--net=\\[bridge | none | container:\\<name | id > | host | NETWORK] .. コンテナのネットワークを指定\n\n\\--hostname(-h) .. コンテナ自信のホスト名を指定\n\n\\--publish(-p) \\[ホストのポート番号]:\\[コンテナのポート番号] .. ホストとコンテナのポートマッピング\n\n\\--publish-all(-P) .. ホストの任意のポートをコンテナに割り当てる\n\nリソースオプション\n\n\\--cpu-shares(-c) .. CPUの使用の配分(1024が100%)\n\n\\--memory(-m) .. 使用するメモリを制限(単位はb,k,m,gのいずれか)\n\n\\--volume(-v)=\\[ホストのディレクトリ]:\\[コンテナのディレクトリ] .. ディレクトリを共有\n\n環境変数など\n\n\\--env(-e)=\\[環境変数] .. 環境変数を設定\n\n\\--envfile=\\[ファイル名] .. fileから環境変数を設定\n\n\\--readonly=\\[true|false] .. コンテナのファイルシステムを読み込み専用にする\n\n\\--workdir(-w)=\\[パス] .. コンテナの作業ディレクトリを指定する\n\n\\--user(-u)=\\[ユーザ名] .. ユーザ名かUIDを指定する\n\n\n\ndocker network\n\n\n\nコンテナの状態確認\n\n\n\nコンテナの状態変更\n\n\n\nothers\n\n"},{"id":"http://localhost:3000/posts/github-ssh","url":"http://localhost:3000/posts/github-ssh","title":"GitHubにsshでつなぐ","summary":"以下、過去の自分用メモの移動。 WindowsやMacでは、GitHubのIDとパスワードを安全に記憶して、HTTPS通信で勝手に使ってくれるのだが、Ubuntuではどうもよい方法がなさそうだった。 そこでHTTPSではなくSSHを使ってgithubと通信するようにして、公開鍵認証により安全を担保しようというわけだ。 鍵ペアを作る GitHubに登録 GitHub > Settings > SSH Keys > Add SSH key から公開鍵を登録する Title : PC名等 Key: 公開鍵をコピペ Add keyを押し、その後パスワードも入力 ローカルマシン上で設定 \\~/.ssh/","date_published":"2020-08-14T18:55:39+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:GitHub%E3%81%ABssh%E3%81%A7%E3%81%A4%E3%81%AA%E3%81%90,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["git","ssh","Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae0ea8e11aa1de2b26cd27c1e9c046d2fb9135f4","comment":"Add articles\n","date_modified":"2020-08-14T22:40:26+09:00"}],"content_html":"<p>以下、過去の自分用メモの移動。</p>\n<p>WindowsやMacでは、GitHubのIDとパスワードを安全に記憶して、HTTPS通信で勝手に使ってくれるのだが、Ubuntuではどうもよい方法がなさそうだった。</p>\n<p>そこでHTTPSではなくSSHを使ってgithubと通信するようにして、公開鍵認証により安全を担保しようというわけだ。</p>\n<h2>鍵ペアを作る</h2>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> ~/.ssh\n$ ssh-keygen -t rsa -b 4096 -C <span class=\"hljs-string\">\"mymail@example.com\"</span>\n<span class=\"hljs-comment\"># 鍵の名前を id_rsa_github とする</span>\n<span class=\"hljs-comment\"># パスワードも聞かれるので入力</span>\n\n$ ls -1 \nid_rsa_github <span class=\"hljs-comment\"># 秘密鍵</span>\nid_rsa_github.pub <span class=\"hljs-comment\"># 公開鍵</span>\n\n<span class=\"hljs-comment\"># 作成時に既に正しく設定されていた Ubuntu20.04LTS</span>\n<span class=\"hljs-comment\"># $ chmod 600 id_rsa_github</span></code></pre>\n<h2>GitHubに登録</h2>\n<p>GitHub > Settings > SSH Keys > Add SSH key から公開鍵を登録する</p>\n<p>Title : PC名等\nKey: 公開鍵をコピペ</p>\n<p>Add keyを押し、その後パスワードも入力</p>\n<h2>ローカルマシン上で設定</h2>\n<p><code>~/.ssh/config</code>に以下を追記</p>\n<div class=\"remark-code-title\">~/.ssh/config</div>\n<pre><code class=\"hljs language-plaintext\">Host github\n  HostName github.com\n  IdentityFile ~/.ssh/id_rsa_github\n  User git</code></pre>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># ssh-agentが動作しているか確認</span>\n<span class=\"hljs-built_in\">eval</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">${ssh-agent -s}</span>\"</span>\nAgent pid 32047\n\n$ ssh-add ~/.ssh/id_rsa_github\n<span class=\"hljs-comment\"># パスワードを入力</span>\n\n<span class=\"hljs-comment\"># 接続確認</span>\n$ ssh -T git@github.com</code></pre>\n","content_text":"以下、過去の自分用メモの移動。\n\nWindowsやMacでは、GitHubのIDとパスワードを安全に記憶して、HTTPS通信で勝手に使ってくれるのだが、Ubuntuではどうもよい方法がなさそうだった。\n\nそこでHTTPSではなくSSHを使ってgithubと通信するようにして、公開鍵認証により安全を担保しようというわけだ。\n\n鍵ペアを作る\n\n\n\nGitHubに登録\n\nGitHub > Settings > SSH Keys > Add SSH key から公開鍵を登録する\n\nTitle : PC名等\nKey: 公開鍵をコピペ\n\nAdd keyを押し、その後パスワードも入力\n\nローカルマシン上で設定\n\n\\~/.ssh/configに以下を追記\n\n"},{"id":"http://localhost:3000/posts/lily58-pro-ble","url":"http://localhost:3000/posts/lily58-pro-ble","title":"Lily58 Pro を Bluetooth 対応し無線化する","summary":"前回の記事で作った左右分割型の自作キーボード Lily58 Pro を Bluetooth に対応させ、無線で PC に接続できるように改造した。 その作業記録。 この記事では、無線化にあたり次のことを行う。 USBからキーボードへの給電がなくなるので、別途ボタン電池用の電源基板をつなぐ 有線キーボードの制御用マイコンである Pro Micro を、Bluetooth に対応した BLE Micro Pro に交換する BLE Micro Pro にファームウェアを書き込む 必要なもの Lily58 Pro (遊舎工房) Pro Micro 互換の Bluetooth-LowEnergy 対応","date_published":"2020-08-14T02:07:01+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Lily58%20Pro%20%E3%82%92%20Bluetooth%20%E5%AF%BE%E5%BF%9C%E3%81%97%E7%84%A1%E7%B7%9A%E5%8C%96%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["自作キーボード","Lily58"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p><a href=\"/posts/lily58-pro-build-log/\">前回の記事で作った</a>左右分割型の自作キーボード <a href=\"https://yuchi-kbd.hatenablog.com/entry/2018/12/23/214342\">Lily58 Pro</a> を Bluetooth に対応させ、無線で PC に接続できるように改造した。\nその作業記録。</p>\n<p>この記事では、無線化にあたり次のことを行う。</p>\n<ul>\n<li>USBからキーボードへの給電がなくなるので、別途<a href=\"https://yushakobo.jp/shop/ble-micro-pro-battery-board/\">ボタン電池用の電源基板</a>をつなぐ</li>\n<li>有線キーボードの制御用マイコンである Pro Micro を、Bluetooth に対応した <a href=\"https://github.com/sekigon-gonnoc/BLE-Micro-Pro\">BLE Micro Pro</a> に交換する</li>\n<li>BLE Micro Pro にファームウェアを書き込む</li>\n</ul>\n<h2>必要なもの</h2>\n<ul>\n<li>Lily58 Pro (<a href=\"https://yushakobo.jp/shop/lily58-pro/\">遊舎工房</a>)</li>\n<li>Pro Micro 互換の Bluetooth-LowEnergy 対応マイコン(<a href=\"https://yusahakobo.jp/shop/ble-micro-pro/\">遊舎工房</a>|<a href=\"https://nogikes.booth.pm/items/1177319\">Booth</a>) x2</li>\n<li>上記マイコン用ボタン電池基板 (<a href=\"https://yushakobo.jp/shop/ble-micro-pro-battery-board/\">遊舎工房</a>|<a href=\"https://nogikes.booth.pm/items/1655285\">Booth</a>) x2</li>\n<li>上記の互換ボードを Lily58 に PCB に固定するためのコンスルー 12ピン (<a href=\"https://yushakobo.jp/shop/a01mc-00/\">遊舎工房</a>)</li>\n<li>ボタン電池 CR1632 x4</li>\n<li>(電池ホルダーを紛失したので) 100均に売っている金属製のコードホルダー x4</li>\n<li>(電池ホルダーを紛失したので) 上記と基板をつなぐスズメッキ線</li>\n<li>マイコンと電池基板をつなぐICピン 長さ1ピン x4</li>\n<li>絶縁用ビニールテープ</li>\n<li>はんだ、はんだごて、はんだ吸い取り線、ピンセット等</li>\n</ul>\n<h2>手順</h2>\n<p>手順を示した<a href=\"https://sekigon-gonnoc.github.io/BLE-Micro-Pro/#/getting_started\">公式ガイド</a>に従って作業を進めた</p>\n<h3>1. Lily58 Pro を完成させる</h3>\n<p>Pro Microはコンスルーを使って組み立て、交換できるようにしておく</p>\n<h3>2. 電池基板の組み立て</h3>\n<h4>2.1. コンデンサ, スイッチ, ダイオードの取り付け</h4>\n<p>電池基板に付属の電子部品をはんだ付けする。</p>\n<p>はんだ付けの手順は以下の通り。Lily58 Proの部品をはんだ付けしたのと同じように行えばよい。\n写真はコンデンサを固定するときのものである。</p>\n<ol>\n<li>まず基板のランドの片方を温めて半田をつける</li>\n</ol>\n<p><img src=\"https://blob.yammer.jp/powerboard1.jpg\" alt=\"基板のランドの片方を温めて半田をつける\"></p>\n<ol start=\"2\">\n<li>先程つけた半田を溶かして部品の片方を固定する</li>\n</ol>\n<p><img src=\"https://blob.yammer.jp/powerboard2.jpg\" alt=\"部品の片方を固定する\"></p>\n<ol start=\"3\">\n<li>まだ半田を流していない側の端子とランドを温めて半田をつける</li>\n</ol>\n<p><img src=\"https://blob.yammer.jp/powerboard3.jpg\" alt=\"部品を完全に固定する\"></p>\n<p>コンデンサは極性がないのでどちら向きにつけてもよい。</p>\n<p>ダイオードはコンデンサと反対の面につける。\n極性があるので注意。\nダイオードの表面に線が入っており、線が近い方の端子がプラス。\nこれを基板のシルク印刷(丸ポッチがある方)に合わせる。</p>\n<p>組み立てると次のようになる。</p>\n<p><img src=\"https://blob.yammer.jp/powerboard4.jpg\" alt=\"表面実装部品を組み立てた電池基板\"></p>\n<h4>2.2. 電池固定用ホルダーの取り付け</h4>\n<p>今回は(届いたときに内容物を確認していなかったがおそらく)この部品を紛失したため、電池が固定できそうな金属部品を探して代用した。</p>\n<p>それがダイソーのコードホルダー。\nこれの左右を切り落として、コの字のパーツを作り、折り曲げる。</p>\n<p><img src=\"https://blob.yammer.jp/powerboard5.jpg\" alt=\"ダイソーのコードホルダーを加工する\"></p>\n<p>次に、完成時に電池と基板を挟み込むように、基板の電池を固定するのと反対側の面に、金具を金具に付属の粘着テープで固定する。</p>\n<p><img src=\"https://blob.yammer.jp/powerboard7.jpg\" alt=\"コードホルダーと基板を結線する\"></p>\n<p>そのあと、基板のホールと金具をスズメッキ線で結線する。</p>\n<p>最後に電池を取り付けてテスターで3Vが得られることを確認したら、全体をビニールテープで絶縁する。</p>\n<p><img src=\"https://blob.yammer.jp/powerboard8.jpg\" alt=\"ビニールテープで絶縁する\"></p>\n<h3>3. BLE Micro Pro の組み立て</h3>\n<p>BLE Micro Pro にコンスルーを取り付ける。はんだ付けの必要はないと書いてあったがなんとなく半田を流しておいた。</p>\n<p>その後、ピンヘッダを1本だけの長さにして、電池基板を BLE Micro Pro につなげる。</p>\n<p>最後に BLE Micro Pro を Lily58 に刺して完成。</p>\n<p><img src=\"https://blob.yammer.jp/lily58proble.jpg\" alt=\"Bluetooth対応の組み立てが完了したLily58 Pro\"></p>\n<h3>4. ファームウェアの書き込み</h3>\n<p>事前に 電池基板のスイッチを切っておいたほうがわかりやすい。\nLily58 Pro に固定した状態で左右の基板ともに、左にスイッチを倒すとOFF。</p>\n<p>BLE Pro Micro は <a href=\"https://sekigon-gonnoc.github.io/home#/keymap\">専用の Web Configurator</a> という Chrome 上で動く Webアプリで書き込むのが一番簡単な方法らしい。</p>\n<ol>\n<li>Chrome の設定変更</li>\n</ol>\n<p><code>chrome://flags#enable-experimental-web-platform-features</code> を開き Experimental Web Platform features を Enabled にする。</p>\n<ol start=\"2\">\n<li><a href=\"https://sekigon-gonnoc.github.io/home#/keymap\">専用の Web Configurator</a> にアクセスする</li>\n<li>ナビゲーション付きでセットアップを開始する</li>\n<li>キーボードの選択画面で Lily58 の rev1 を選ぶ Disable Mass storage Class と Use with LPME-IO のチェックは入れない</li>\n<li>最新のブートローダー (記事執筆時は0_7_1) 選び Update</li>\n<li>デバイスを選択する画面が出てくるので, BLE Micro Pro を PC と USBで接続する。</li>\n</ol>\n<p>BLE Micro Pro(新しく増えたデバイス)を選択。\n筆者の環境(Macbook Air 2018 Catarina)では <code>IOUSBHostDevice (tty.usbmodem0000000000011)</code> と <code>IOUSBHostDevice (cu.usbmodem0000000000011)</code>が出現したが、後者を選ぶと書き込めた。</p>\n<ol start=\"7\">\n<li>アプリケーション(必ずブートローダー同じバージョンのもの)を書き込む。Is Left のみにチェックが入っていること。</li>\n<li>もう一つの BLE Micro Pro も同様に書き込む。アプリケーション書き込み時に Is  Slave のみにチェックが入っていること。</li>\n</ol>\n<h3>5. キーマップの書き込み</h3>\n<ol>\n<li><a href=\"https://sekigon-gonnoc.github.io/qmk_configurator/#/\">専用の QMK Configurator</a> にアクセスする。</li>\n<li>BLE Micro Pro を PC に USB 接続した状態で、CONNECT BY SERIAL ボタンを押す。</li>\n<li>キーボードリストから lily58/rev1 を選択する。</li>\n<li>好みのキーマップを作成する。</li>\n<li>KEYMAP.JSON の左側のボタンを押してキーボードに反映</li>\n<li>そのまま試しにキーを打ってみて問題なさそうであれば、SAVE KEYMAP ボタンでキーボードに保存。</li>\n<li>USBを抜いて、PCと BLE Micro Pro を切り離す</li>\n</ol>\n<h3>6. キーボードを実際に使う</h3>\n<p>左右どちらも電池基板の電源を入れると、勝手に左右がペアリングする。\nPC の Bluetooth 設定ページを見ると Lily58 が出現しているので選択すると PC とのペアリングが完了し使えるようになる。</p>\n<h2>感想</h2>\n<ul>\n<li>公式のドキュメントと、他の分割キーボードの Bluetooth 化の記事を見ながら進めた。</li>\n<li>電池ホルダーがないことに気づいたときは凹んだが、完成品は特に不自然なく動作させられてよかった。</li>\n<li>QMK をビルドして書き込む方法はうまく行ってないので、また必要になる時があったら試してみることとする。</li>\n<li>Web アプリの QMK Configurator はよくできていて、キーの長押しで動作を変えるといった機能にも対応しているのでひとまずは普通に使えている。</li>\n<li>キーボードのペアリングはとてもスムーズだったし、ペアリング後も電源を入れるとすぐにPCとつながるのでとても快適に使うことができている。</li>\n<li>いまのところ一日に一回くらい、キーが押しっぱなしになる(キーを押して無いのにキーコードが送信され続ける)ことがあり、キーボードの電源を一旦切ることで解決している。原因は不明。 今後も継続して発生するようであれば、これの原因究明もせねばならない。</li>\n</ul>\n<p>こんなところかな。</p>\n<p>自作キーボードとはいえ、普通に問題なく使える快適なものが出来上がってとても満足だ。\nキーボードや無線化キットを設計したり情報をまとめたりしてくれている方々に感謝したい。</p>\n<p>両手で1万円くらいかけてわざわざ無線化したのは理由があるのだが、それはまた別記事で紹介することとする。</p>\n<hr>\n<p>追記: (2020/10/04) lily58ビルドログへのリンクを相対リンクへ修正</p>\n","content_text":"前回の記事で作った左右分割型の自作キーボード Lily58 Pro を Bluetooth に対応させ、無線で PC に接続できるように改造した。\nその作業記録。\n\nこの記事では、無線化にあたり次のことを行う。\n\nUSBからキーボードへの給電がなくなるので、別途ボタン電池用の電源基板をつなぐ\n\n有線キーボードの制御用マイコンである Pro Micro を、Bluetooth に対応した BLE Micro Pro に交換する\n\nBLE Micro Pro にファームウェアを書き込む\n\n必要なもの\n\nLily58 Pro (遊舎工房)\n\nPro Micro 互換の Bluetooth-LowEnergy 対応マイコン(遊舎工房|Booth) x2\n\n上記マイコン用ボタン電池基板 (遊舎工房|Booth) x2\n\n上記の互換ボードを Lily58 に PCB に固定するためのコンスルー 12ピン (遊舎工房)\n\nボタン電池 CR1632 x4\n\n(電池ホルダーを紛失したので) 100均に売っている金属製のコードホルダー x4\n\n(電池ホルダーを紛失したので) 上記と基板をつなぐスズメッキ線\n\nマイコンと電池基板をつなぐICピン 長さ1ピン x4\n\n絶縁用ビニールテープ\n\nはんだ、はんだごて、はんだ吸い取り線、ピンセット等\n\n手順\n\n手順を示した公式ガイドに従って作業を進めた\n\n1\\. Lily58 Pro を完成させる\n\nPro Microはコンスルーを使って組み立て、交換できるようにしておく\n\n2\\. 電池基板の組み立て\n\n2.1. コンデンサ, スイッチ, ダイオードの取り付け\n\n電池基板に付属の電子部品をはんだ付けする。\n\nはんだ付けの手順は以下の通り。Lily58 Proの部品をはんだ付けしたのと同じように行えばよい。\n写真はコンデンサを固定するときのものである。\n\nまず基板のランドの片方を温めて半田をつける\n\n基板のランドの片方を温めて半田をつける\n\n先程つけた半田を溶かして部品の片方を固定する\n\n部品の片方を固定する\n\nまだ半田を流していない側の端子とランドを温めて半田をつける\n\n部品を完全に固定する\n\nコンデンサは極性がないのでどちら向きにつけてもよい。\n\nダイオードはコンデンサと反対の面につける。\n極性があるので注意。\nダイオードの表面に線が入っており、線が近い方の端子がプラス。\nこれを基板のシルク印刷(丸ポッチがある方)に合わせる。\n\n組み立てると次のようになる。\n\n表面実装部品を組み立てた電池基板\n\n2.2. 電池固定用ホルダーの取り付け\n\n今回は(届いたときに内容物を確認していなかったがおそらく)この部品を紛失したため、電池が固定できそうな金属部品を探して代用した。\n\nそれがダイソーのコードホルダー。\nこれの左右を切り落として、コの字のパーツを作り、折り曲げる。\n\nダイソーのコードホルダーを加工する\n\n次に、完成時に電池と基板を挟み込むように、基板の電池を固定するのと反対側の面に、金具を金具に付属の粘着テープで固定する。\n\nコードホルダーと基板を結線する\n\nそのあと、基板のホールと金具をスズメッキ線で結線する。\n\n最後に電池を取り付けてテスターで3Vが得られることを確認したら、全体をビニールテープで絶縁する。\n\nビニールテープで絶縁する\n\n3\\. BLE Micro Pro の組み立て\n\nBLE Micro Pro にコンスルーを取り付ける。はんだ付けの必要はないと書いてあったがなんとなく半田を流しておいた。\n\nその後、ピンヘッダを1本だけの長さにして、電池基板を BLE Micro Pro につなげる。\n\n最後に BLE Micro Pro を Lily58 に刺して完成。\n\nBluetooth対応の組み立てが完了したLily58 Pro\n\n4\\. ファームウェアの書き込み\n\n事前に 電池基板のスイッチを切っておいたほうがわかりやすい。\nLily58 Pro に固定した状態で左右の基板ともに、左にスイッチを倒すとOFF。\n\nBLE Pro Micro は 専用の Web Configurator という Chrome 上で動く Webアプリで書き込むのが一番簡単な方法らしい。\n\nChrome の設定変更\n\nchrome://flags#enable-experimental-web-platform-features を開き Experimental Web Platform features を Enabled にする。\n\n専用の Web Configurator にアクセスする\n\nナビゲーション付きでセットアップを開始する\n\nキーボードの選択画面で Lily58 の rev1 を選ぶ Disable Mass storage Class と Use with LPME-IO のチェックは入れない\n\n最新のブートローダー (記事執筆時は0\\_7\\_1) 選び Update\n\nデバイスを選択する画面が出てくるので, BLE Micro Pro を PC と USBで接続する。\n\nBLE Micro Pro(新しく増えたデバイス)を選択。\n筆者の環境(Macbook Air 2018 Catarina)では IOUSBHostDevice (tty.usbmodem0000000000011) と IOUSBHostDevice (cu.usbmodem0000000000011)が出現したが、後者を選ぶと書き込めた。\n\nアプリケーション(必ずブートローダー同じバージョンのもの)を書き込む。Is Left のみにチェックが入っていること。\n\nもう一つの BLE Micro Pro も同様に書き込む。アプリケーション書き込み時に Is  Slave のみにチェックが入っていること。\n\n5\\. キーマップの書き込み\n\n専用の QMK Configurator にアクセスする。\n\nBLE Micro Pro を PC に USB 接続した状態で、CONNECT BY SERIAL ボタンを押す。\n\nキーボードリストから lily58/rev1 を選択する。\n\n好みのキーマップを作成する。\n\nKEYMAP.JSON の左側のボタンを押してキーボードに反映\n\nそのまま試しにキーを打ってみて問題なさそうであれば、SAVE KEYMAP ボタンでキーボードに保存。\n\nUSBを抜いて、PCと BLE Micro Pro を切り離す\n\n6\\. キーボードを実際に使う\n\n左右どちらも電池基板の電源を入れると、勝手に左右がペアリングする。\nPC の Bluetooth 設定ページを見ると Lily58 が出現しているので選択すると PC とのペアリングが完了し使えるようになる。\n\n感想\n\n公式のドキュメントと、他の分割キーボードの Bluetooth 化の記事を見ながら進めた。\n\n電池ホルダーがないことに気づいたときは凹んだが、完成品は特に不自然なく動作させられてよかった。\n\nQMK をビルドして書き込む方法はうまく行ってないので、また必要になる時があったら試してみることとする。\n\nWeb アプリの QMK Configurator はよくできていて、キーの長押しで動作を変えるといった機能にも対応しているのでひとまずは普通に使えている。\n\nキーボードのペアリングはとてもスムーズだったし、ペアリング後も電源を入れるとすぐにPCとつながるのでとても快適に使うことができている。\n\nいまのところ一日に一回くらい、キーが押しっぱなしになる(キーを押して無いのにキーコードが送信され続ける)ことがあり、キーボードの電源を一旦切ることで解決している。原因は不明。 今後も継続して発生するようであれば、これの原因究明もせねばならない。\n\nこんなところかな。\n\n自作キーボードとはいえ、普通に問題なく使える快適なものが出来上がってとても満足だ。\nキーボードや無線化キットを設計したり情報をまとめたりしてくれている方々に感謝したい。\n\n両手で1万円くらいかけてわざわざ無線化したのは理由があるのだが、それはまた別記事で紹介することとする。\n\n\n\n追記: (2020/10/04) lily58ビルドログへのリンクを相対リンクへ修正\n"},{"id":"http://localhost:3000/posts/lily58-pro-build-log","url":"http://localhost:3000/posts/lily58-pro-build-log","title":"Lily58 を作って自作キーボードに入門した (Lily58 Pro Build Log)","summary":" 数ヶ月前から、自作キーボードが気になっていたのだが、ついに手を出してしまった。 自作キーボードとは 自作キーボードとは、キースイッチやキーキャップ、基板(PCB)等を購入し、自分で組み立ててキーボードを作ることである。 自分の欲しいキーボードを作ることができるのが魅力。 パーツをはんだ付けしたり、マイコンにファームウェアを書き込んだり、場合によっては基板を設計したりすることでつくる。 今回は既に設計, 基板が製造済みで、組み立てキット形式になっている Lily58 Pro を作ることにした。 Lily58 Pro を選んだ理由 作る機種は、Lily 58 Proとした。 Lily58 が魅力","date_published":"2020-08-14T01:55:25+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Lily58%20%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%A6%E8%87%AA%E4%BD%9C%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E3%81%AB%E5%85%A5%E9%96%80%E3%81%97%E3%81%9F%20(Lily58%20Pro%20Build%20Log),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["自作キーボード","Lily58"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/2d5a2e74375d45aa11976d4cbbe72f5f4b6e3a3e","comment":"Update a post 'lily58-pro-build-log'\n","date_modified":"2021-01-09T11:50:59+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/34ed6c7f987985f7d1e7be26e5d1a3ce3b24e1a7","comment":"Add lily58 build log\n","date_modified":"2020-08-14T02:06:05+09:00"}],"content_html":"<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">毎月一回、自作キーボードが作りたくなってカートに商品を入れるまでやる。あと一歩のところで踏みとどまる。</p>&mdash; けーすけ@やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1284673759593418752?ref_src=twsrc%5Etfw\">July 19, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>数ヶ月前から、自作キーボードが気になっていたのだが、ついに手を出してしまった。</p>\n<h2>自作キーボードとは</h2>\n<p>自作キーボードとは、キースイッチやキーキャップ、基板(PCB)等を購入し、自分で組み立ててキーボードを作ることである。\n自分の欲しいキーボードを作ることができるのが魅力。</p>\n<p>パーツをはんだ付けしたり、マイコンにファームウェアを書き込んだり、場合によっては基板を設計したりすることでつくる。</p>\n<p>今回は既に設計, 基板が製造済みで、組み立てキット形式になっている Lily58 Pro を作ることにした。</p>\n<h2>Lily58 Pro を選んだ理由</h2>\n<p>作る機種は、<a href=\"https://yuchi-kbd.hatenablog.com/entry/2018/12/23/214342\">Lily 58 Pro</a>とした。</p>\n<p>Lily58 が魅力だったのは次の点。</p>\n<h3>キーマップを自由に書き換えられること</h3>\n<p>これは Lily58 に限らず自作キーボードの殆どに言えることだと思うが、キーボードの挙動を自由に書き換えることができる。\n打ちづらい位置にあるキーは使用頻度の少ないキーと入れ替えたり、複数キーの同時押しで特殊な動作をさせたりすることが可能になる。</p>\n<p>自作キーボードは極端に言うとマイコンとスイッチの集合体なので、挙動は本当に自由に決めれると言ってよい。\n(実際には qmk といわれるファームウェアを使うことが一般的で、これの一部を書き換えることでカスタマイズを実現する。)</p>\n<p>キーボード側で自由に設定できるのはとてもありがたい。\nもともとキーリマッパと呼ばれるソフトウェアを使って挙動を書き換えていたのだが、これは環境構築が面倒だったりする。\n(Mac では Karabiner Elements、Ubuntu では xkeysnail を使っていた。)\n自作キーボードであれば USB を刺すだけで済む。</p>\n<p>キーマップを自由に書き換えられるのって嬉しいのか？と思う人、あなたは CapsLock を使っているだろうか。\n結構使用頻度の少ないキーだと思うのだが、そこそこ押しやすい位置にある。\n例えばこれを Ctrl に変えればショートカットを押しやすいし、ESC にすれば Vim が使いやすくなるし、半角/かなキーにするのも便利かもしれない。</p>\n<p>こんな感じで一つずつ置き換えるキーを増やしていき、設定が煩雑になって自作キーボードが欲しくなった。</p>\n<h3>キー数が60個程度 (いわゆる60%キーボード)</h3>\n<p>普段使わないキーはいらないので、コンパクトなものがほしい。\nただし40%等のこれ以上キー数が少ないものは不安。</p>\n<p>既に60%の中華キーボード (<a href=\"https://www.amazon.co.jp/gp/product/B07QQXJ58V/ref=ppx_yo_dt_b_asin_title_o03_s00?ie=UTF8&#x26;psc=1\">RK Royal RK61</a>) を使っているので、良い落とし所なのではと思った。</p>\n<p>ちなみにこの RK61 は4月頃に自作キーボード (DZ60) を作ろうか迷った挙げ句「自作キーボード、まだ自分には早いかな」と思い、とりあえず60%の US 配列キーボードを買ったもの。\n普通に使えていたが、結局自作キーボード欲を抑えることができなかった。</p>\n<h3>kailh ロープロファイルに対応している</h3>\n<p>Lily58 Pro は kailh ロープロファイル (浅いキーストロークのスイッチの規格) に対応している。</p>\n<p>私はノートパソコンのキーボードのような、キーストロークの浅いキーボードが割と好きで、キーストロークが深いと打ち間違いやすい気がしていた。\n(RK61を使っていたときの感想。昔はメンブレンのキーボードとか普通に使っていたはずなのだが。)</p>\n<p>作ったあとの感想になるが、このキースイッチの選択は正解で浅いキーボードは打ちやすいと感じる。</p>\n<h3>左右分割型であること</h3>\n<p>左右分割型だと肩が丸まらないので姿勢が良くなるらしい。\n当初は分割でなく一体型のキーボードに注目していたが、調べるうちにどうせ作るなら金額も変わらないし左右分割型にしてみるかという気分になっていった。</p>\n<p>左右分割型にしたことで夢が広がるのだがそれはまた別の記事に書くこととする。</p>\n<h3>column-straggered であること</h3>\n<p>column-straggerd とはキー配列の種類で、列ごとに縦方向にずれたもの。</p>\n<p>一般的なキーボードは キーが一段ごとに横方向に半分程度ずれている。(row-straggered という。)\nこのずれはタイプライターの機械構造に起因していて、特に打ちやすくするためではないらしい。</p>\n<p>この横方向にずれた配列が打ちづらいのはわりと感じる(右人差し指でYを打鍵するの遠すぎないか？？)ので、完全に格子状の Ortholiner ないしは column-straggerd なキーボードを求めた。</p>\n<p>ちなみにYを右人差し指でタイプするのは遠すぎるので、左人差し指でタイプする癖がついていたのだが、分割キーボードにしたことでこの癖は矯正することになった。</p>\n<h2>購入したもの</h2>\n<p>自作キーボードの部品を買える通販サイトの代表的なものに以下のサイトがある。\n今回は全て遊舎工房で購入した。</p>\n<ul>\n<li><a href=\"https://yushakobo.jp/\">遊舎工房</a></li>\n<li><a href=\"https://yushakobo.jp/\">Aliexpress</a></li>\n<li><a href=\"https://kbdfans.com/\">KBDFANS</a></li>\n<li><a href=\"https://eucalyn.shop/\">ゆかりキーボードファクトリー</a></li>\n<li><a href=\"https://talpkeyboard.stores.jp/\">TALP KEYBOARD</a></li>\n</ul>\n<p>購入した商品は以下の通り。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">商品</th>\n<th align=\"right\">数量</th>\n<th align=\"right\">値段</th>\n<th align=\"left\">補足</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/lily58-pro/?attribute_pa_sockettype=choc\">Lily58 Pro - Kailh Choc ロープロファイル用</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">14,800</td>\n<td align=\"left\">大半のパーツが含まれるキット</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/pg1350/?attribute_pa_stem=red\">Kailhロープロファイルスイッチ（10個） - 赤</a></td>\n<td align=\"right\">6</td>\n<td align=\"right\">2,880</td>\n<td align=\"left\">キーを押したことを判定するスイッチ</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/pg1350cap-doubleshot/?attribute_pa_keycapcolor=black\">Kailhロープロ刻印キーキャップ - 黒</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">3,000</td>\n<td align=\"left\">キースイッチの上にかぶせるキャップ  (刻印付きで100個くらい入っている)</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/a0300lb/?attribute_pa_color=white&#x26;attribute_pa_size=1-5u\">Kailhロープロ無刻印キーキャップ1.5U 2U（1個） - 白, 1.5u</a></td>\n<td align=\"right\">2</td>\n<td align=\"right\">400</td>\n<td align=\"left\">親指部分の少し長いキーキャップ</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/pg1350cap-blank/?attribute_pa_keycapcolor=white\">Kailhロープロ無刻印キーキャップ1U（10個） - 白</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">300</td>\n<td align=\"left\">刻印が合わないところに使うキーキャップ</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/pg1350cap-blank/?attribute_pa_keycapcolor=black\">Kailhロープロ無刻印キーキャップ1U（10個） - 黒</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">300</td>\n<td align=\"left\">刻印が合わないところに使うキーキャップ</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/trrs_cable/\">TRRSケーブル 1m</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">300</td>\n<td align=\"left\">左右をつなぐケーブル</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://yushakobo.jp/shop/promicro-spring-pinheader/?attribute_pa_firmware=none\">Pro Micro （コンスルー付き） - なし</a></td>\n<td align=\"right\">1</td>\n<td align=\"right\">1000</td>\n<td align=\"left\">後述の通り、キットに入っているPro Microをダメにしてしまったので追加購入</td>\n</tr>\n</tbody>\n</table>\n<p>この他に Pro Micro と PC をつなぐ USB(A to microB)ケーブルも必要。(<a href=\"https://www.amazon.co.jp/gp/product/B071S5NTDR/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&#x26;psc=1\">家にあるもの</a>を使った)</p>\n<p>Lily58 は、一般にTabやCtrlなどが位置するキーも1U(アルファベットのキーと同じ大きさ)である。\n今回購入したキーキャップセットのキャップは合わないので、別途個別に無刻印のキーキャップをバラで買った。\n(見た目を気にしたければテンキー用の1Uキーなどが余るのでそれを使ってもよさそう。)</p>\n<p>金額は合計して消費税を足して、2.5万円しないくらい。</p>\n<h2>組み立て</h2>\n<p>組み立てには、上記の購入部品の他にはんだ、はんだごて、ピンセット、プラスドライバーが必要になる。エポキシ接着剤(100均に売ってる)、ハンダ吸い取り線もあるといい。</p>\n<h3>USB端子の補強</h3>\n<p>まずはじめに 'もげmicro' を防ぐためにエポキシ接着剤で補強する。</p>\n<p>USBを刺す基板である Pro Micro はコネクタが折れやすいらしく、抜き差しを繰り返すとコネクタが折れてPro Microが使えなくなることがよくあるらしい。\n(自作キーボード界隈ではこのことを'もげMicro'と呼ぶそう)</p>\n<p>この対策のために今回遊舎工房で買ったキットはコンスルーというピンが入っており、はんだ付けせずにPro Microを接続できて交換がしやすいようになっている。</p>\n<p>また、端子部分を補強するためにエポキシ接着剤をコネクタ周囲に流して固定するのが定番のようだ。\n私もインターネットの記事を参考にエポキシ接着剤を塗り、、、</p>\n<p>やってしまった。\nコネクタ内部に接着剤が流れ込み、USBが刺さらなくなってしまった。\n仕方ないので追加でPro Microを一つ注文し、作業をすすめる。</p>\n<h3>Lily58 Pro キットの組み立て</h3>\n<p>以降の組み立ての過程はキーボード設計者のゆーちさんが書いた<a href=\"https://github.com/kata0510/Lily58/blob/master/Pro/Doc/buildguide_jp.md\">ビルドガイド</a>に書かれている。\nこれを<strong>よく読んで</strong>作れば問題ない。</p>\n<p>私はキースイッチ受けとダイオードを逆の面につけてしまい一度ハンダを取り除いて再度つけるなどした。</p>\n<p>あとはんだ付けに不安があれば、はんだ付け後にテスターで導通を確認するのがよい。\n沢山数があって面倒だが、ここでミスっているのを跡で治すほうが大変なのでチェックしておくことをおすすめする。\n私はキースイッチ受けの導通をチェックしておらず、完成後に2つ半田をつけ直した。</p>\n<p>組み立て中の写真を取るのを忘れたが、数時間で組み上がったと思う。</p>\n<h2>ファームウェアの書き込み</h2>\n<h3>デフォルトのファームウェアを書き込む</h3>\n<p>次の手順でファームウェアを書き込む。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># Ubuntu 20.04 LTS</span>\n$ git <span class=\"hljs-built_in\">clone</span> git@github.com:qmk/qmk_firmware.git\n$ <span class=\"hljs-built_in\">cd</span> qmk_firmware\n$ make git-submodule\n$ ./util/qmk_install.sh <span class=\"hljs-comment\"># 必要なパッケージをインストール 時間がかかる</span>\n$ sudo make lily58:default:avrdude\n<span class=\"hljs-comment\"># 次のような表示が出てきたら, キーボードのリセットボタンを押す</span>\n<span class=\"hljs-comment\"># Detecting USB port, reset your controller now...</span>\n<span class=\"hljs-comment\"># 同様の手順で左右のマイコンに同じファームウェアを書き込む</span>\n<span class=\"hljs-comment\"># 左手のUSBコネクタにケーブルを, 左右のTPRS端子に4極ケーブルを刺す</span></code></pre>\n<h3>ファームウェアのカスタマイズ</h3>\n<p>次の手順でファームウェアを書き込む。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># yammerjp と名付けた自分用キーマップを作る</span>\n\n$ cp -r keyboards/lily58/keymaps/default keyboards/lily58/keymaps/yammerjp\n$ vim keyboards/lily58/keymaps/yammerjp/keymap.c\n<span class=\"hljs-comment\"># キーマップを書き換える</span>\n\n$ sudo make lily58:yammerjp:avrdude\n<span class=\"hljs-comment\"># 次のような表示が出てきたら, キーボードのリセットボタンを押す</span>\n<span class=\"hljs-comment\"># Detecting USB port, reset your controller now...</span>\n<span class=\"hljs-comment\"># 同様の手順で左右のマイコンに同じファームウェアを書き込む</span>\n<span class=\"hljs-comment\"># 左手のUSBコネクタにケーブルを, 左右のTPRS端子に4極ケーブルを刺す</span></code></pre>\n<p>私が現在設定している<a href=\"https://github.com/yammerjp/qmk_firmware/blob/master/keyboards/lily58/keymaps/yammerjp/keymap.c\">キーマップは次の通り</a>。</p>\n<p>記事の前半で60%のキーボードが良いと言っておきながら、ホームポジションから離れた上段1列は無効化している(2020/08/05現在)。\nまだ慣れていないので使いやすいかどうかはまだ不明だが、慣れたら便利そうな気がしている。</p>\n<h2>まとめ</h2>\n<p>組み立てるのも結構楽しいし、キーボードが左右で割れているのは新鮮だし、作って良かった。\nキーマップについてはまだまだ慣れていないし、使いながら改良していきたい。</p>\n<hr>\n<p>2021/01/06 必要なパッケージのインストール手順を追記</p>\n","content_text":"\n\n数ヶ月前から、自作キーボードが気になっていたのだが、ついに手を出してしまった。\n\n自作キーボードとは\n\n自作キーボードとは、キースイッチやキーキャップ、基板(PCB)等を購入し、自分で組み立ててキーボードを作ることである。\n自分の欲しいキーボードを作ることができるのが魅力。\n\nパーツをはんだ付けしたり、マイコンにファームウェアを書き込んだり、場合によっては基板を設計したりすることでつくる。\n\n今回は既に設計, 基板が製造済みで、組み立てキット形式になっている Lily58 Pro を作ることにした。\n\nLily58 Pro を選んだ理由\n\n作る機種は、Lily 58 Proとした。\n\nLily58 が魅力だったのは次の点。\n\nキーマップを自由に書き換えられること\n\nこれは Lily58 に限らず自作キーボードの殆どに言えることだと思うが、キーボードの挙動を自由に書き換えることができる。\n打ちづらい位置にあるキーは使用頻度の少ないキーと入れ替えたり、複数キーの同時押しで特殊な動作をさせたりすることが可能になる。\n\n自作キーボードは極端に言うとマイコンとスイッチの集合体なので、挙動は本当に自由に決めれると言ってよい。\n(実際には qmk といわれるファームウェアを使うことが一般的で、これの一部を書き換えることでカスタマイズを実現する。)\n\nキーボード側で自由に設定できるのはとてもありがたい。\nもともとキーリマッパと呼ばれるソフトウェアを使って挙動を書き換えていたのだが、これは環境構築が面倒だったりする。\n(Mac では Karabiner Elements、Ubuntu では xkeysnail を使っていた。)\n自作キーボードであれば USB を刺すだけで済む。\n\nキーマップを自由に書き換えられるのって嬉しいのか？と思う人、あなたは CapsLock を使っているだろうか。\n結構使用頻度の少ないキーだと思うのだが、そこそこ押しやすい位置にある。\n例えばこれを Ctrl に変えればショートカットを押しやすいし、ESC にすれば Vim が使いやすくなるし、半角/かなキーにするのも便利かもしれない。\n\nこんな感じで一つずつ置き換えるキーを増やしていき、設定が煩雑になって自作キーボードが欲しくなった。\n\nキー数が60個程度 (いわゆる60%キーボード)\n\n普段使わないキーはいらないので、コンパクトなものがほしい。\nただし40%等のこれ以上キー数が少ないものは不安。\n\n既に60%の中華キーボード (RK Royal RK61) を使っているので、良い落とし所なのではと思った。\n\nちなみにこの RK61 は4月頃に自作キーボード (DZ60) を作ろうか迷った挙げ句「自作キーボード、まだ自分には早いかな」と思い、とりあえず60%の US 配列キーボードを買ったもの。\n普通に使えていたが、結局自作キーボード欲を抑えることができなかった。\n\nkailh ロープロファイルに対応している\n\nLily58 Pro は kailh ロープロファイル (浅いキーストロークのスイッチの規格) に対応している。\n\n私はノートパソコンのキーボードのような、キーストロークの浅いキーボードが割と好きで、キーストロークが深いと打ち間違いやすい気がしていた。\n(RK61を使っていたときの感想。昔はメンブレンのキーボードとか普通に使っていたはずなのだが。)\n\n作ったあとの感想になるが、このキースイッチの選択は正解で浅いキーボードは打ちやすいと感じる。\n\n左右分割型であること\n\n左右分割型だと肩が丸まらないので姿勢が良くなるらしい。\n当初は分割でなく一体型のキーボードに注目していたが、調べるうちにどうせ作るなら金額も変わらないし左右分割型にしてみるかという気分になっていった。\n\n左右分割型にしたことで夢が広がるのだがそれはまた別の記事に書くこととする。\n\ncolumn-straggered であること\n\ncolumn-straggerd とはキー配列の種類で、列ごとに縦方向にずれたもの。\n\n一般的なキーボードは キーが一段ごとに横方向に半分程度ずれている。(row-straggered という。)\nこのずれはタイプライターの機械構造に起因していて、特に打ちやすくするためではないらしい。\n\nこの横方向にずれた配列が打ちづらいのはわりと感じる(右人差し指でYを打鍵するの遠すぎないか？？)ので、完全に格子状の Ortholiner ないしは column-straggerd なキーボードを求めた。\n\nちなみにYを右人差し指でタイプするのは遠すぎるので、左人差し指でタイプする癖がついていたのだが、分割キーボードにしたことでこの癖は矯正することになった。\n\n購入したもの\n\n自作キーボードの部品を買える通販サイトの代表的なものに以下のサイトがある。\n今回は全て遊舎工房で購入した。\n\n遊舎工房\n\nAliexpress\n\nKBDFANS\n\nゆかりキーボードファクトリー\n\nTALP KEYBOARD\n\n購入した商品は以下の通り。\n\n\n\nこの他に Pro Micro と PC をつなぐ USB(A to microB)ケーブルも必要。(家にあるものを使った)\n\nLily58 は、一般にTabやCtrlなどが位置するキーも1U(アルファベットのキーと同じ大きさ)である。\n今回購入したキーキャップセットのキャップは合わないので、別途個別に無刻印のキーキャップをバラで買った。\n(見た目を気にしたければテンキー用の1Uキーなどが余るのでそれを使ってもよさそう。)\n\n金額は合計して消費税を足して、2.5万円しないくらい。\n\n組み立て\n\n組み立てには、上記の購入部品の他にはんだ、はんだごて、ピンセット、プラスドライバーが必要になる。エポキシ接着剤(100均に売ってる)、ハンダ吸い取り線もあるといい。\n\nUSB端子の補強\n\nまずはじめに 'もげmicro' を防ぐためにエポキシ接着剤で補強する。\n\nUSBを刺す基板である Pro Micro はコネクタが折れやすいらしく、抜き差しを繰り返すとコネクタが折れてPro Microが使えなくなることがよくあるらしい。\n(自作キーボード界隈ではこのことを'もげMicro'と呼ぶそう)\n\nこの対策のために今回遊舎工房で買ったキットはコンスルーというピンが入っており、はんだ付けせずにPro Microを接続できて交換がしやすいようになっている。\n\nまた、端子部分を補強するためにエポキシ接着剤をコネクタ周囲に流して固定するのが定番のようだ。\n私もインターネットの記事を参考にエポキシ接着剤を塗り、、、\n\nやってしまった。\nコネクタ内部に接着剤が流れ込み、USBが刺さらなくなってしまった。\n仕方ないので追加でPro Microを一つ注文し、作業をすすめる。\n\nLily58 Pro キットの組み立て\n\n以降の組み立ての過程はキーボード設計者のゆーちさんが書いたビルドガイドに書かれている。\nこれをよく読んで作れば問題ない。\n\n私はキースイッチ受けとダイオードを逆の面につけてしまい一度ハンダを取り除いて再度つけるなどした。\n\nあとはんだ付けに不安があれば、はんだ付け後にテスターで導通を確認するのがよい。\n沢山数があって面倒だが、ここでミスっているのを跡で治すほうが大変なのでチェックしておくことをおすすめする。\n私はキースイッチ受けの導通をチェックしておらず、完成後に2つ半田をつけ直した。\n\n組み立て中の写真を取るのを忘れたが、数時間で組み上がったと思う。\n\nファームウェアの書き込み\n\nデフォルトのファームウェアを書き込む\n\n次の手順でファームウェアを書き込む。\n\n\n\nファームウェアのカスタマイズ\n\n次の手順でファームウェアを書き込む。\n\n\n\n私が現在設定しているキーマップは次の通り。\n\n記事の前半で60%のキーボードが良いと言っておきながら、ホームポジションから離れた上段1列は無効化している(2020/08/05現在)。\nまだ慣れていないので使いやすいかどうかはまだ不明だが、慣れたら便利そうな気がしている。\n\nまとめ\n\n組み立てるのも結構楽しいし、キーボードが左右で割れているのは新鮮だし、作って良かった。\nキーマップについてはまだまだ慣れていないし、使いながら改良していきたい。\n\n\n\n2021/01/06 必要なパッケージのインストール手順を追記\n"},{"id":"http://localhost:3000/posts/ubuntu-m570-scroll","url":"http://localhost:3000/posts/ubuntu-m570-scroll","title":"Ubuntu20.04でトラックボールのボールを転がしてスクロールする","summary":"最近、Logicool のトラックボール M570 を購入した。 このトラックボールはスクロールホイールがついているが、左右にスクロールする機能はない。 そこで、ボールを転がして上下左右にスクロールを可能にする。 今回は Ubuntu 20.04 をターゲットに設定を行う。 (macOS では、Karabiner Elements と Scroll Reverser というソフト (どちらも brew cask にあり) を使い実現した。詳細は省略) デバイス名を調べる 以上より、デバイス名はLogitech M570、デバイスIDは9。 のちの設定ファイルでデバイス名を利用する。 ボタン番号","date_published":"2020-08-14T01:20:09+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Ubuntu20.04%E3%81%A7%E3%83%88%E3%83%A9%E3%83%83%E3%82%AF%E3%83%9C%E3%83%BC%E3%83%AB%E3%81%AE%E3%83%9C%E3%83%BC%E3%83%AB%E3%82%92%E8%BB%A2%E3%81%8C%E3%81%97%E3%81%A6%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Linux","Ubuntu","トラックボール"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c1e30b532ff065640c7979c505ef84eab88f9b3c","comment":"Add ubuntu-m570-scroll.md\n","date_modified":"2020-08-14T01:47:16+09:00"}],"content_html":"<p>最近、Logicool のトラックボール M570 を購入した。\nこのトラックボールはスクロールホイールがついているが、左右にスクロールする機能はない。</p>\n<p>そこで、ボールを転がして上下左右にスクロールを可能にする。</p>\n<p>今回は Ubuntu 20.04 をターゲットに設定を行う。\n(macOS では、Karabiner Elements と Scroll Reverser というソフト (どちらも brew cask にあり) を使い実現した。詳細は省略)</p>\n<h2>デバイス名を調べる</h2>\n<pre><code class=\"hljs language-sh\">$ xinput list\n⎡ Virtual core pointer                    \tid=2\t[master pointer  (3)]\n⎜   ↳ Virtual core XTEST pointer              \tid=4\t[slave  pointer  (2)]\n⎜   ↳ Logitech M570                           \tid=9\t[slave  pointer  (2)]\n⎜   ↳ Lily58 Consumer Control                 \tid=11\t[slave  pointer  (2)]\n⎜   ↳ Lily58 Mouse                            \tid=13\t[slave  pointer  (2)]\n⎣ Virtual core keyboard                   \tid=3\t[master keyboard (2)]\n    ↳ Virtual core XTEST keyboard             \tid=5\t[slave  keyboard (3)]\n    ↳ Power Button                            \tid=6\t[slave  keyboard (3)]\n    ↳ Video Bus                               \tid=7\t[slave  keyboard (3)]\n    ↳ Power Button                            \tid=8\t[slave  keyboard (3)]\n    ↳ Lily58 Keyboard                         \tid=10\t[slave  keyboard (3)]\n    ↳ Lily58 Consumer Control                 \tid=12\t[slave  keyboard (3)]\n    ↳ Lily58 System Control                   \tid=14\t[slave  keyboard (3)]\n    ↳ WI-C300 (AVRCP)                         \tid=15\t[slave  keyboard (3)]</code></pre>\n<p>以上より、デバイス名は<code>Logitech M570</code>、デバイスIDは<code>9</code>。\nのちの設定ファイルでデバイス名を利用する。</p>\n<h2>ボタン番号を調べる</h2>\n<p>以下のコマンドでIDが<code>9</code>のデバイスの状態をみることができる。</p>\n<p>今回はマウスのスクロールホイールを押し込むボタンの番号を知るために、スクロールホイールを押し込みながら以下のコマンドを実行する。</p>\n<pre><code class=\"hljs language-sh\">$ xinput query-state 9</code></pre>\n<p>実行結果より、 M570 のスクロールホイールを押し込むボタンの番号は<code>3</code>であることがわかった。</p>\n<h2>設定を記入する</h2>\n<p>root権限で <code>/usr/share/X11/xorg.conf.d/40-libinput.conf</code> に以下を追記する。</p>\n<div class=\"remark-code-title\">/usr/share/X11/xorg.conf.d/40-libinput.conf</div>\n<pre><code class=\"hljs language-plaintext\"># Logitech M570 Scrolling with pressed the right button and rolled the ball\nSection \"InputClass\"\n  Identifier \"Logitech M570\"\n  MatchProduct \"Logitech M570\"\n  Driver \"libinput\"\n  Option \"ScrollMethod\" \"button\"\n  Option \"ScrollMethod\" \"3\"\nEndSection</code></pre>\n<p>再起動するとスクロールホイール押下時にボールによるスクロールが有効化される。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://yu1.dev/posts/%E5%B8%B8%E7%94%A8ubuntu-18.04-lts%E3%81%AE%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97/\">常用Ubuntu 18.04 LTSのセットアップ - yu1.dev</a></li>\n</ul>\n","content_text":"最近、Logicool のトラックボール M570 を購入した。\nこのトラックボールはスクロールホイールがついているが、左右にスクロールする機能はない。\n\nそこで、ボールを転がして上下左右にスクロールを可能にする。\n\n今回は Ubuntu 20.04 をターゲットに設定を行う。\n(macOS では、Karabiner Elements と Scroll Reverser というソフト (どちらも brew cask にあり) を使い実現した。詳細は省略)\n\nデバイス名を調べる\n\n\n\n以上より、デバイス名はLogitech M570、デバイスIDは9。\nのちの設定ファイルでデバイス名を利用する。\n\nボタン番号を調べる\n\n以下のコマンドでIDが9のデバイスの状態をみることができる。\n\n今回はマウスのスクロールホイールを押し込むボタンの番号を知るために、スクロールホイールを押し込みながら以下のコマンドを実行する。\n\n\n\n実行結果より、 M570 のスクロールホイールを押し込むボタンの番号は3であることがわかった。\n\n設定を記入する\n\nroot権限で /usr/share/X11/xorg.conf.d/40-libinput.conf に以下を追記する。\n\n\n\n再起動するとスクロールホイール押下時にボールによるスクロールが有効化される。\n\n参考\n\n常用Ubuntu 18.04 LTSのセットアップ - yu1.dev\n"},{"id":"http://localhost:3000/posts/willani-for-stmt-bug","url":"http://localhost:3000/posts/willani-for-stmt-bug","title":"自作コンパイラのfor文バグ","summary":"C言語のコンパイラを自作に関する今日の日記。 これまでの記事 「数日前からCコンパイラを書き始めた。」 「自作Cコンパイラの途中経過」 「自作コンパイラのセルフホストに挑戦中」 「C言語の構造体メンバのアライメント (x86\\_64, Linux (System V ABI))」 今日実装したのは次の2つ。 構造体のアライメント for文バグの修正 ちなみに昨日はastをjsonで吐くコード(git反映前に間違えて切り取って飛ばしてしまい頑張って再実装したが、翌日セルフホスト向けにはバグっていることがわかりお蔵入り)、セルフホスト用のシェルスクリプトなどを実装していた。 構造体のアライメント ","date_published":"2020-07-09T02:09:03+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%87%AA%E4%BD%9C%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AEfor%E6%96%87%E3%83%90%E3%82%B0,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","willani","日記","C"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/d89cc2acd93e6b0cf64c0a70bbfc05793c141f31","comment":"Add posts of willani\n","date_modified":"2020-07-09T03:14:33+09:00"}],"content_html":"<p>C言語のコンパイラを自作に関する今日の日記。</p>\n<p>これまでの記事</p>\n<ul>\n<li>「<a href=\"/posts/willani-start/\">数日前からCコンパイラを書き始めた。</a>」</li>\n<li>「<a href=\"/posts/willani-compliperbook-finished/\">自作Cコンパイラの途中経過</a>」</li>\n<li>「<a href=\"/posts/try-selfhost\">自作コンパイラのセルフホストに挑戦中</a>」</li>\n<li>「<a href=\"posts/willani-struct-alignment\">C言語の構造体メンバのアライメント (x86_64, Linux (System V ABI))</a>」</li>\n</ul>\n<hr>\n<p>今日実装したのは次の2つ。</p>\n<ul>\n<li>構造体のアライメント</li>\n<li>for文バグの修正</li>\n</ul>\n<p>ちなみに昨日はastをjsonで吐くコード(git反映前に間違えて切り取って飛ばしてしまい頑張って再実装したが、翌日セルフホスト向けにはバグっていることがわかりお蔵入り)、セルフホスト用のシェルスクリプトなどを実装していた。</p>\n<h2>構造体のアライメント</h2>\n<p><a href=\"https://github.com/yammerjp/willani\">willani</a> での今日行ったアライメントの実装は<a href=\"https://github.com/yammerjp/willani/commit/ae1d68f94211c6c510ea2247abcde7386ffd25c8\">このあたり</a>。実装内容は前回の記事(<a href=\"posts/willani-struct-alignment\">C言語の構造体メンバのアライメント (x86_64, Linux (System V ABI))</a>)で説明している。</p>\n<p>セルフホストをしようとしているがうまくいかないファイルが結構ある。\n構造体のアライメントを実装するきっかけは色々なファイルを第一世代コンパイラに流しているときに出てきた問題からである。</p>\n<p>トークナイズ結果をファイルに出力する <code>src/tokenize_log.c</code> というファイルを willani でビルドしてリンクすると、コンパイラは動くがトークナイズ結果のうち構造体アクセスしている部分だけ出力がなかった。\nここから構造体のアライメントが必要なことと実装していないことに気づいた。</p>\n<p>本当は配列も 16byte 境界でアライメントしなければならなかった気がするが、こちらはまだ未実装。\nUnion もアライメントしなきゃいけないが、こちらはそもそも Union を未実装。\nグローバル変数もアライメントしなきゃいけないが、これもまだ実装していない。</p>\n<h2>for文バグの修正</h2>\n<p>今日はこのアライメントと、いわゆるfor文バグ (と私が呼んでいるもの) の修正をやった。</p>\n<p>ここ最近セルフホストに向けて、gccでコンパイルしたアセンブリに一部 willani でコンパイラしたアセンブリを混ぜてリンクして第1.5世代コンパイラを作っている。\nその中で <code>src/type.c</code> というファイルを willani でビルドしてリンクしたときの話。</p>\n<p>バグの詳細は記事最後に記す。\n時系列に説明しているので長くなってしまった。</p>\n<p>どうもセルフホストに近づいてコンパイラ自身のコードをビルドし始めるとどこで何がバグっているのかわからなくなってくる。</p>\n<p>普通のプログラムでは、入力が誤っているか、入力を受け取るコードが誤っているかを考えればいいが、セルフホストを目指すコンパイラではさらに、入力を受けとるコードを生成するコードが誤っている可能性も考慮しなければならない。</p>\n<p>例えばあとで記す「バグの詳細」に出てくる構造体は、入力文字列で表記されている構造体と、入力文字列を処理するプログラムのデータ構造としての構造体、そしてそのプログラムを生成するときのデータ構造としての構造体があって、いま考えている構造体はなんなんだ？という気持ちになる。</p>\n<p>とにかくバグトラックが大変で、些細なことで1日が溶けた。</p>\n<p>今回の<code>src/type.c</code>ではあまりなかったが、segmentation falut で終了することもよくあるし、デバッグが結構大変。</p>\n<p>パース結果のログは、パースが完全に終わってからASTをたどって出力しているので、パース中に死ぬとどんな状況かつかめないことが多々ある。なのでパース中のデバッグを楽にするためのログ出力などは強化していきたい。</p>\n<p>大変とは書いたが、ゆっくりだが着実にセルフホストに近づいているし、なにより自分の書いたコードで自分の書いたコードをコンパイルする状況はなんともいえないワクワク感があるので楽しい。</p>\n<p>明日以降も楽しみながら進めていきたい。</p>\n<hr>\n<p>補足: タイトルについて</p>\n<p>今日見つけたバグは、私がfor文バグと呼んでいて、実際for文の実装にバグがあったが、内容はささいな話で、結構実装依存な内容である。</p>\n<p>なのでfor文の実装に他の人もハマりがちな落とし穴があるという意味はなく、タイトルはあくまで自分の記憶のためのもの。</p>\n<hr>\n<h2>バグの詳細</h2>\n<p>どうもこの第1.5世代コンパイラは、構造体のメンバを読む処理がバグっていて、定義済みのメンバを呼び出すコードを解釈する際に、同名のメンバが定義されていないとしてエラーを出力していた。</p>\n<p>構造体を含まないコードは問題なくコンパイルできるので、構造体のメンバを読むあたりが明らかに怪しい。\nしかしどうやってバグっているのか全く検討がつかなかった。</p>\n<p>まず疑ったのは、入力のコードの構造体を読み込むときに構造体のアライメントが狂っていて読み込みに失敗しているのではないかということ。\n実は多分ここでもバグっていて、まずは冒頭のような構造体のアライメントを実装した。\nこれにより、構造体の情報を willani 内部で保持する構造体 (Member 構造体) の各メンバに、コンパイラ内で正しくアクセスできるようになった。</p>\n<p>しかしエラーは消えず、ほかにどこがバグっているのかよくわからない。\n(自作コンパイラでは、エラーメッセージは往々にして自分が書いたものが出力されるので、なんともいえない気持ちになる。)</p>\n<p>ひとまず関係のある Member 構造体の生成・格納・検索などのコードに片っ端に fprintf を挿入し、変数の値やポインタの指すメモリ番地などをダンプすることとした。</p>\n<p>ダンプしたことでエラー発生の直前までうまく値がわたっていることはわかった。\n何故か (for 文をつかった) メンバ名の検索だけがうまくいっていない。</p>\n<p>色々試したうえで、たまたま for 文を while 文に書き換えると嘘のように正しく動作して解決した。</p>\n<p>あとで調べると、for 文の初期化処理がうまくいってなかったようだ。\nfor 文を表す node は、初期化文を表す node を init メンバとして持っている。\ninit メンバはふつう1文を表す1つの node で、next メンバに値が入ることはないとして実装されていた。</p>\n<p>しかし、init メンバが変数の宣言と初期化を行う文の node で、かつ初期化子が実行時に定まるとき(例えば <code>int a=p;</code>)バグる。\n<code>int a=1;</code> のような文は、willani では1つの Node 構造体 (<code>Node.kind = ND_STMT_VAR_INIT</code>) で表される。\nこの構造体には初期化の値も含まれており、初期化の値が即値(コンパイル時に定まる値(数字か文字列))なら1つの構造体で完結する。\n一方初期化の値は実行時に定まる場合もある。\nこのときは Node 構造体の next メンバで別の Node 構造体を数珠つなぎに持ち、これらが初期化用の式文をそれぞれあらわすようになっている。</p>\n<p><code>src/codegen.c</code> の実装バグで、for 文の init メンバの next メンバが指すノードを出力していなかったことで、構造体のメンバを表す変数のアドレスを初期価値として渡すコードがコンパイル時に含まれていなかったらしい。</p>\n<p>わかってしまえば数行で解決できるバグだった。\n(<a href=\"https://github.com/yammerjp/willani/commit/7af9e76cadd338e85e41974e257e498819a59756\">コミット</a>)</p>\n","content_text":"C言語のコンパイラを自作に関する今日の日記。\n\nこれまでの記事\n\n「数日前からCコンパイラを書き始めた。」\n\n「自作Cコンパイラの途中経過」\n\n「自作コンパイラのセルフホストに挑戦中」\n\n「C言語の構造体メンバのアライメント (x86\\_64, Linux (System V ABI))」\n\n\n\n今日実装したのは次の2つ。\n\n構造体のアライメント\n\nfor文バグの修正\n\nちなみに昨日はastをjsonで吐くコード(git反映前に間違えて切り取って飛ばしてしまい頑張って再実装したが、翌日セルフホスト向けにはバグっていることがわかりお蔵入り)、セルフホスト用のシェルスクリプトなどを実装していた。\n\n構造体のアライメント\n\nwillani での今日行ったアライメントの実装はこのあたり。実装内容は前回の記事(C言語の構造体メンバのアライメント (x86\\_64, Linux (System V ABI)))で説明している。\n\nセルフホストをしようとしているがうまくいかないファイルが結構ある。\n構造体のアライメントを実装するきっかけは色々なファイルを第一世代コンパイラに流しているときに出てきた問題からである。\n\nトークナイズ結果をファイルに出力する src/tokenize_log.c というファイルを willani でビルドしてリンクすると、コンパイラは動くがトークナイズ結果のうち構造体アクセスしている部分だけ出力がなかった。\nここから構造体のアライメントが必要なことと実装していないことに気づいた。\n\n本当は配列も 16byte 境界でアライメントしなければならなかった気がするが、こちらはまだ未実装。\nUnion もアライメントしなきゃいけないが、こちらはそもそも Union を未実装。\nグローバル変数もアライメントしなきゃいけないが、これもまだ実装していない。\n\nfor文バグの修正\n\n今日はこのアライメントと、いわゆるfor文バグ (と私が呼んでいるもの) の修正をやった。\n\nここ最近セルフホストに向けて、gccでコンパイルしたアセンブリに一部 willani でコンパイラしたアセンブリを混ぜてリンクして第1.5世代コンパイラを作っている。\nその中で src/type.c というファイルを willani でビルドしてリンクしたときの話。\n\nバグの詳細は記事最後に記す。\n時系列に説明しているので長くなってしまった。\n\nどうもセルフホストに近づいてコンパイラ自身のコードをビルドし始めるとどこで何がバグっているのかわからなくなってくる。\n\n普通のプログラムでは、入力が誤っているか、入力を受け取るコードが誤っているかを考えればいいが、セルフホストを目指すコンパイラではさらに、入力を受けとるコードを生成するコードが誤っている可能性も考慮しなければならない。\n\n例えばあとで記す「バグの詳細」に出てくる構造体は、入力文字列で表記されている構造体と、入力文字列を処理するプログラムのデータ構造としての構造体、そしてそのプログラムを生成するときのデータ構造としての構造体があって、いま考えている構造体はなんなんだ？という気持ちになる。\n\nとにかくバグトラックが大変で、些細なことで1日が溶けた。\n\n今回のsrc/type.cではあまりなかったが、segmentation falut で終了することもよくあるし、デバッグが結構大変。\n\nパース結果のログは、パースが完全に終わってからASTをたどって出力しているので、パース中に死ぬとどんな状況かつかめないことが多々ある。なのでパース中のデバッグを楽にするためのログ出力などは強化していきたい。\n\n大変とは書いたが、ゆっくりだが着実にセルフホストに近づいているし、なにより自分の書いたコードで自分の書いたコードをコンパイルする状況はなんともいえないワクワク感があるので楽しい。\n\n明日以降も楽しみながら進めていきたい。\n\n\n\n補足: タイトルについて\n\n今日見つけたバグは、私がfor文バグと呼んでいて、実際for文の実装にバグがあったが、内容はささいな話で、結構実装依存な内容である。\n\nなのでfor文の実装に他の人もハマりがちな落とし穴があるという意味はなく、タイトルはあくまで自分の記憶のためのもの。\n\n\n\nバグの詳細\n\nどうもこの第1.5世代コンパイラは、構造体のメンバを読む処理がバグっていて、定義済みのメンバを呼び出すコードを解釈する際に、同名のメンバが定義されていないとしてエラーを出力していた。\n\n構造体を含まないコードは問題なくコンパイルできるので、構造体のメンバを読むあたりが明らかに怪しい。\nしかしどうやってバグっているのか全く検討がつかなかった。\n\nまず疑ったのは、入力のコードの構造体を読み込むときに構造体のアライメントが狂っていて読み込みに失敗しているのではないかということ。\n実は多分ここでもバグっていて、まずは冒頭のような構造体のアライメントを実装した。\nこれにより、構造体の情報を willani 内部で保持する構造体 (Member 構造体) の各メンバに、コンパイラ内で正しくアクセスできるようになった。\n\nしかしエラーは消えず、ほかにどこがバグっているのかよくわからない。\n(自作コンパイラでは、エラーメッセージは往々にして自分が書いたものが出力されるので、なんともいえない気持ちになる。)\n\nひとまず関係のある Member 構造体の生成・格納・検索などのコードに片っ端に fprintf を挿入し、変数の値やポインタの指すメモリ番地などをダンプすることとした。\n\nダンプしたことでエラー発生の直前までうまく値がわたっていることはわかった。\n何故か (for 文をつかった) メンバ名の検索だけがうまくいっていない。\n\n色々試したうえで、たまたま for 文を while 文に書き換えると嘘のように正しく動作して解決した。\n\nあとで調べると、for 文の初期化処理がうまくいってなかったようだ。\nfor 文を表す node は、初期化文を表す node を init メンバとして持っている。\ninit メンバはふつう1文を表す1つの node で、next メンバに値が入ることはないとして実装されていた。\n\nしかし、init メンバが変数の宣言と初期化を行う文の node で、かつ初期化子が実行時に定まるとき(例えば int a=p;)バグる。\nint a=1; のような文は、willani では1つの Node 構造体 (Node.kind = ND_STMT_VAR_INIT) で表される。\nこの構造体には初期化の値も含まれており、初期化の値が即値(コンパイル時に定まる値(数字か文字列))なら1つの構造体で完結する。\n一方初期化の値は実行時に定まる場合もある。\nこのときは Node 構造体の next メンバで別の Node 構造体を数珠つなぎに持ち、これらが初期化用の式文をそれぞれあらわすようになっている。\n\nsrc/codegen.c の実装バグで、for 文の init メンバの next メンバが指すノードを出力していなかったことで、構造体のメンバを表す変数のアドレスを初期価値として渡すコードがコンパイル時に含まれていなかったらしい。\n\nわかってしまえば数行で解決できるバグだった。\n(コミット)\n"},{"id":"http://localhost:3000/posts/willani-struct-alignment","url":"http://localhost:3000/posts/willani-struct-alignment","title":"C言語の構造体メンバのアライメント (x86_64, Linux (System V ABI))","summary":"System V ABI における構造体メンバのアライメントの方法を記す。 C言語のコンパイラを自作しているときに学んだことの記録で、 これまでの記事 「数日前からCコンパイラを書き始めた。」 「自作Cコンパイラの途中経過」 「自作コンパイラのセルフホストに挑戦中」 に続く記事である。 System V ABI とは？ ABI (Application Binary Interface) とは、バイナリレベルでのコンパイラが満たすべき規約である。 アーキテクチャやOSごとに決まっており、例えば我々が一般的に使うintelのCPUである x86\\_64 でいえば、 Windows は  Micr","date_published":"2020-07-09T00:59:59+09:00","date_modified":"2021-08-09T23:05:35+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:C%E8%A8%80%E8%AA%9E%E3%81%AE%E6%A7%8B%E9%80%A0%E4%BD%93%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E3%82%A2%E3%83%A9%E3%82%A4%E3%83%A1%E3%83%B3%E3%83%88%20(x86_64%2C%20Linux%20(System%20V%20ABI)),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","willani","日記","C"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/447bf52578de17fd36379a8b68f2378124ec8ed8","comment":"Append: メモリアライメントの話が出てくる関連Youtube動画を紹介\n","date_modified":"2021-08-09T23:05:35+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/698524967ae01574a8037c627a8b083e253a04f2","comment":"Fix internal links\n","date_modified":"2020-10-04T22:43:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/fc1f49fea5c87dd342d2e9476f375ebcb013744e","comment":"Delete <br/>\n","date_modified":"2020-10-04T20:49:44+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/d89cc2acd93e6b0cf64c0a70bbfc05793c141f31","comment":"Add posts of willani\n","date_modified":"2020-07-09T03:14:33+09:00"}],"content_html":"<p>System V ABI における構造体メンバのアライメントの方法を記す。</p>\n<p>C言語のコンパイラを自作しているときに学んだことの記録で、\nこれまでの記事\n「<a href=\"/posts/willani-start/\">数日前からCコンパイラを書き始めた。</a>」\n「<a href=\"/posts/willani-compliperbook-finished/\">自作Cコンパイラの途中経過</a>」\n「<a href=\"/posts/try-selfhost\">自作コンパイラのセルフホストに挑戦中</a>」\nに続く記事である。</p>\n<h2>System V ABI とは？</h2>\n<p>ABI (Application Binary Interface) とは、バイナリレベルでのコンパイラが満たすべき規約である。\nアーキテクチャやOSごとに決まっており、例えば我々が一般的に使うintelのCPUである x86_64 でいえば、 Windows は  Microsoft ABI, Linux と macOS は <a href=\"https://www.uclibc.org/docs/psABI-x86_64.pdf\">System V ABI</a>という規約で定められている。</p>\n<p>具体的には次のようなものが決められている。</p>\n<ul>\n<li>int long 等の型のサイズ</li>\n<li>構造体のメモリ上での配置</li>\n<li>関数呼び出し時のスタック, レジスタの扱い</li>\n</ul>\n<p>ABIはなんのためにあるのか？\nそれは異なるコンパイラ間でビルドしたバイナリをリンクできるようにするためである。</p>\n<p>現在、一般に libc などのライブラリはバイナリに含まれず、事前に別にビルドされたものを実行時にダイナミックリンクして呼び出している。\nこのような状況下では、異なるコンパイラでビルドされたバイナリ同士が相互に関数を呼び出すことが考えられる。</p>\n<p>(大きなライブラリは個別のアプリケーション開発時にビルドするのは手間だし、libcなどは様々なバイナリで使われるので、バイナリに含ませないことで共通化して容量を削減させたい。)</p>\n<p>int や long といったデータ型は C言語の仕様ではサイズが定められていない。long のサイズが int 以上である、といったことは決まっているが、別に 4byteでなくてもよい。 (16bit CPU では 2byte だったりする。)\nデータ型はアーキテクチャに依存することが多い？と思われる。</p>\n<p>他にも関数呼び出し時に引数や戻り値をどのように渡せばよいかを考えると ABI の必要性がみえてくる。\n引数はレジスタに入れることも考えられるし、スタックに積むことも考えられる。C言語の仕様では引数や戻り値という概念は存在するが、具体的にどう実装するかは定められていない。そこであるコンパイラではレジスタ渡しをするかもしれないし、あるコンパイラではスタック渡しをするかもしれない。どちらも使うコンパイラもあるかも知れないし、コンパイラの作りようはいくらでもある。</p>\n<p>しかしコンパイラが自由に作ってしまうと、他のバイナリから呼ぶときに困る。他のコンパイラでビルドしたバイナリは引数をレジスタに詰めて渡したつもりになっていたが、受け取る側はスタックを読みだすかもしれない。</p>\n<p>このようなアーキテクチャやOSによって共通なC言語をバイナリレベルでコンパイラがどう実装するか決めておいたほうがよいことがABIで定められている。</p>\n<h2>アライメントとは？</h2>\n<p>スタックに領域を確保するとき、空いている部分にピッタリ詰めるのではなく、ある程度キリの良いメモリ配置になるように、使っていない無駄な領域(パディング)を用意してメモリ番地を揃えることをアライメントという。</p>\n<p>C言語のアライメントはABIによって定められている。</p>\n<p>アライメントは構造体に求められる。\nローカル変数同士はどう配置されていようと関係なく、それを読み出すのは自身のバイナリであるから問題ない。</p>\n<p>System V ABIでは、各データ型のサイズとアライメントすべき単位のサイズがそれぞれ同じバイト数になっている。\n(<a href=\"https://www.uclibc.org/docs/psABI-x86_64.pdf\">仕様書</a> 12ページ Figure 3.1 Scalar Types)</p>\n<h2>本題: System V ABI における構造体メンバのアライメント</h2>\n<h3>仕様書の記述</h3>\n<p>仕様書には構造体メンバのアライメントについて次のような記述がある。\n(<a href=\"https://www.uclibc.org/docs/psABI-x86_64.pdf\">仕様書</a> 13ページ 中段 Aggregates and Unions)</p>\n<blockquote>\n<p>Structures and unions assume the alignment of their most strictly aligned component. Each member is assigned to the lowest available offset with the appropriate alignment. The size of any object is always a multiple of the object‘s alignment.</p>\n</blockquote>\n<p>any object と the object が何を指しているのか最初イマイチわかっていなかったが、他の日本語の解説なども読んだ結果、次を意味するらしい。</p>\n<ul>\n<li>構造体の各メンバは, それぞれの要素ごとに厳密にアライメントされる。( => 利用可能なオフセットの中で最も低いもの(パディングが小さいもの)に配置される。)</li>\n<li>構造体末尾のパディングは, 構造体の要素のアライメント単位の中で最大の値でアライメントされるように付加する。</li>\n</ul>\n<h3>例</h3>\n<p>次のような構造体を考える</p>\n<pre><code class=\"hljs language-C\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">hoge</span> {</span>\n  <span class=\"hljs-keyword\">char</span> a;\n  <span class=\"hljs-keyword\">char</span> b;\n  <span class=\"hljs-keyword\">int</span> c;\n  <span class=\"hljs-keyword\">short</span> d;\n};</code></pre>\n<p>以上の構造体の実体は、次のようにアライメントされる</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">メモリ番地</th>\n<th align=\"left\">内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">0x....00</td>\n<td align=\"left\">char a</td>\n</tr>\n<tr>\n<td align=\"left\">0x....ff</td>\n<td align=\"left\">char b</td>\n</tr>\n<tr>\n<td align=\"left\">0x....fe</td>\n<td align=\"left\">padding</td>\n</tr>\n<tr>\n<td align=\"left\">0x....fd</td>\n<td align=\"left\">padding</td>\n</tr>\n<tr>\n<td align=\"left\">0x....fc</td>\n<td align=\"left\">int c</td>\n</tr>\n<tr>\n<td align=\"left\">0x....fb</td>\n<td align=\"left\">int c</td>\n</tr>\n<tr>\n<td align=\"left\">0x....fa</td>\n<td align=\"left\">int c</td>\n</tr>\n<tr>\n<td align=\"left\">0x....f9</td>\n<td align=\"left\">int c</td>\n</tr>\n<tr>\n<td align=\"left\">0x....f8</td>\n<td align=\"left\">short d</td>\n</tr>\n<tr>\n<td align=\"left\">0x....f7</td>\n<td align=\"left\">short d</td>\n</tr>\n<tr>\n<td align=\"left\">0x....f6</td>\n<td align=\"left\">padding</td>\n</tr>\n<tr>\n<td align=\"left\">0x....f5</td>\n<td align=\"left\">padding</td>\n</tr>\n</tbody>\n</table>\n<p>まず、定義されたメンバと同じ順で配置される。</p>\n<ol>\n<li><code>char a</code> は先頭なので何も考えずに配置する。</li>\n<li><code>char b</code> を配置するために、必要ならパディングをしてメモリをアライメントする。</li>\n</ol>\n<p><code>char</code> のアライメントすべきメモリ境界の単位は 1byte (すなわちどこでも良い) なのでパディングの必要がない (既にアライメントされているともいえる)</p>\n<ol>\n<li><code>char b</code> をアラインされた場所 (今回は <code>char a</code> のすぐ後ろ) に配置する。</li>\n<li><code>int c</code> を配置するために、必要ならパディングをしたメモリをアライメントする。</li>\n</ol>\n<p><code>int</code> のアライメントすべきメモリ境界は4byteであるが、番地 <code>0x...fe</code> はこれを満たしていないので、2byte パディングしてメモリをアライメントする。</p>\n<ol>\n<li><code>int c</code> をアラインされた場所 (今回は 2byte のパディングの後ろ) に配置する。</li>\n<li><code>short d</code> を配置するために、必要ならパディングをしてメモリをアライメントする。</li>\n</ol>\n<p><code>short</code> のアライメントすべきメモリ境界の単位は 2byte で、今回はこれを満たしているのでパディングの必要がない (既にアライメントされているともいえる)</p>\n<ol>\n<li><code>short d</code> をアラインされた場所 (今回は <code>int d</code> のすぐ後ろ) に配置する。</li>\n<li><code>struct hoge</code> 自体の終わりにパディングをする。</li>\n</ol>\n<p>アライメントすべきメモリ境界は、メンバのアライメントすべきメモリ境界 (<code>char</code>...1byte, <code>int</code>...4byte, <code>short</code>...2byte) のうち最も大きい値である <code>int</code>...4byte に合わせるようにパディングする\nよって 2byte のパディングを追加</p>\n<p>以上。</p>\n<p>ちなみに <code>sizeof(struct hoge)</code> の値は <code>12</code> となる。</p>\n<ul>\n<li>参考: <a href=\"https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%82%A2%E3%83%A9%E3%82%A4%E3%83%A1%E3%83%B3%E3%83%88\">データ構造アライメント - Wikipedia</a> ... 日本語のわかりやすい解説。</li>\n</ul>\n<h2>何故アライメントするのか</h2>\n<p>アクセスが速くなるとか？？。。。</p>\n<hr>\n<p>(2021/08/09) アクセスが早くなるかららしい。\nまた、(今回はx86_64に限定しているが) CPUのアーキテクチャによってはアライメントを強制する場合もあるらしい。</p>\n<p>メモリのアライメントに関する面白い動画に出会った: <a href=\"https://youtu.be/V_MSKb6qgk0?t=4442\">自作OSを拡張する作業配信 (2021/07/24 低レイヤガール - Youtube</a>\n動画後半 1:14:02 ごろからメモリのアライメントに関する話がされている。</p>\n","content_text":"System V ABI における構造体メンバのアライメントの方法を記す。\n\nC言語のコンパイラを自作しているときに学んだことの記録で、\nこれまでの記事\n「数日前からCコンパイラを書き始めた。」\n「自作Cコンパイラの途中経過」\n「自作コンパイラのセルフホストに挑戦中」\nに続く記事である。\n\nSystem V ABI とは？\n\nABI (Application Binary Interface) とは、バイナリレベルでのコンパイラが満たすべき規約である。\nアーキテクチャやOSごとに決まっており、例えば我々が一般的に使うintelのCPUである x86\\_64 でいえば、 Windows は  Microsoft ABI, Linux と macOS は System V ABIという規約で定められている。\n\n具体的には次のようなものが決められている。\n\nint long 等の型のサイズ\n\n構造体のメモリ上での配置\n\n関数呼び出し時のスタック, レジスタの扱い\n\nABIはなんのためにあるのか？\nそれは異なるコンパイラ間でビルドしたバイナリをリンクできるようにするためである。\n\n現在、一般に libc などのライブラリはバイナリに含まれず、事前に別にビルドされたものを実行時にダイナミックリンクして呼び出している。\nこのような状況下では、異なるコンパイラでビルドされたバイナリ同士が相互に関数を呼び出すことが考えられる。\n\n(大きなライブラリは個別のアプリケーション開発時にビルドするのは手間だし、libcなどは様々なバイナリで使われるので、バイナリに含ませないことで共通化して容量を削減させたい。)\n\nint や long といったデータ型は C言語の仕様ではサイズが定められていない。long のサイズが int 以上である、といったことは決まっているが、別に 4byteでなくてもよい。 (16bit CPU では 2byte だったりする。)\nデータ型はアーキテクチャに依存することが多い？と思われる。\n\n他にも関数呼び出し時に引数や戻り値をどのように渡せばよいかを考えると ABI の必要性がみえてくる。\n引数はレジスタに入れることも考えられるし、スタックに積むことも考えられる。C言語の仕様では引数や戻り値という概念は存在するが、具体的にどう実装するかは定められていない。そこであるコンパイラではレジスタ渡しをするかもしれないし、あるコンパイラではスタック渡しをするかもしれない。どちらも使うコンパイラもあるかも知れないし、コンパイラの作りようはいくらでもある。\n\nしかしコンパイラが自由に作ってしまうと、他のバイナリから呼ぶときに困る。他のコンパイラでビルドしたバイナリは引数をレジスタに詰めて渡したつもりになっていたが、受け取る側はスタックを読みだすかもしれない。\n\nこのようなアーキテクチャやOSによって共通なC言語をバイナリレベルでコンパイラがどう実装するか決めておいたほうがよいことがABIで定められている。\n\nアライメントとは？\n\nスタックに領域を確保するとき、空いている部分にピッタリ詰めるのではなく、ある程度キリの良いメモリ配置になるように、使っていない無駄な領域(パディング)を用意してメモリ番地を揃えることをアライメントという。\n\nC言語のアライメントはABIによって定められている。\n\nアライメントは構造体に求められる。\nローカル変数同士はどう配置されていようと関係なく、それを読み出すのは自身のバイナリであるから問題ない。\n\nSystem V ABIでは、各データ型のサイズとアライメントすべき単位のサイズがそれぞれ同じバイト数になっている。\n(仕様書 12ページ Figure 3.1 Scalar Types)\n\n本題: System V ABI における構造体メンバのアライメント\n\n仕様書の記述\n\n仕様書には構造体メンバのアライメントについて次のような記述がある。\n(仕様書 13ページ 中段 Aggregates and Unions)\n\nStructures and unions assume the alignment of their most strictly aligned component. Each member is assigned to the lowest available offset with the appropriate alignment. The size of any object is always a multiple of the object‘s alignment.\n\nany object と the object が何を指しているのか最初イマイチわかっていなかったが、他の日本語の解説なども読んだ結果、次を意味するらしい。\n\n構造体の各メンバは, それぞれの要素ごとに厳密にアライメントされる。( => 利用可能なオフセットの中で最も低いもの(パディングが小さいもの)に配置される。)\n\n構造体末尾のパディングは, 構造体の要素のアライメント単位の中で最大の値でアライメントされるように付加する。\n\n例\n\n次のような構造体を考える\n\n\n\n以上の構造体の実体は、次のようにアライメントされる\n\n\n\nまず、定義されたメンバと同じ順で配置される。\n\nchar a は先頭なので何も考えずに配置する。\n\nchar b を配置するために、必要ならパディングをしてメモリをアライメントする。\n\nchar のアライメントすべきメモリ境界の単位は 1byte (すなわちどこでも良い) なのでパディングの必要がない (既にアライメントされているともいえる)\n\nchar b をアラインされた場所 (今回は char a のすぐ後ろ) に配置する。\n\nint c を配置するために、必要ならパディングをしたメモリをアライメントする。\n\nint のアライメントすべきメモリ境界は4byteであるが、番地 0x...fe はこれを満たしていないので、2byte パディングしてメモリをアライメントする。\n\nint c をアラインされた場所 (今回は 2byte のパディングの後ろ) に配置する。\n\nshort d を配置するために、必要ならパディングをしてメモリをアライメントする。\n\nshort のアライメントすべきメモリ境界の単位は 2byte で、今回はこれを満たしているのでパディングの必要がない (既にアライメントされているともいえる)\n\nshort d をアラインされた場所 (今回は int d のすぐ後ろ) に配置する。\n\nstruct hoge 自体の終わりにパディングをする。\n\nアライメントすべきメモリ境界は、メンバのアライメントすべきメモリ境界 (char...1byte, int...4byte, short...2byte) のうち最も大きい値である int...4byte に合わせるようにパディングする\nよって 2byte のパディングを追加\n\n以上。\n\nちなみに sizeof(struct hoge) の値は 12 となる。\n\n参考: データ構造アライメント - Wikipedia ... 日本語のわかりやすい解説。\n\n何故アライメントするのか\n\nアクセスが速くなるとか？？。。。\n\n\n\n(2021/08/09) アクセスが早くなるかららしい。\nまた、(今回はx86\\_64に限定しているが) CPUのアーキテクチャによってはアライメントを強制する場合もあるらしい。\n\nメモリのアライメントに関する面白い動画に出会った: 自作OSを拡張する作業配信 (2021/07/24 低レイヤガール - Youtube\n動画後半 1:14:02 ごろからメモリのアライメントに関する話がされている。\n"},{"id":"http://localhost:3000/posts/willani-try-selfhost","url":"http://localhost:3000/posts/willani-try-selfhost","title":"自作コンパイラのセルフホストに挑戦中","summary":"以前の記事「数日前からCコンパイラを書き始めた。」「自作Cコンパイラの途中経過」に続く記事。 これは日記であって、知見が書かれた文章ではない。 経過報告 気づけば2020年も半分が終わり、梅雨に入って雨が続き、今日もジメジメと蒸し暑い。 大学の研究室は相変わらずリモートで、新型コロナウィルスの東京都の感染者数も100人を超える日が続き、収束の気配がない。 世間は春から夏へ季節が変わろうとしているし、世界的にウィルスとの戦いを繰り広げている昨今だが、私のやっていることは相変わらずCコンパイラ「willani」の制作。もう6週目になるだろうか。 昨日あたりからセルフホストに向けて、やっとコンパイラ","date_published":"2020-07-07T01:54:10+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%87%AA%E4%BD%9C%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E3%82%BB%E3%83%AB%E3%83%95%E3%83%9B%E3%82%B9%E3%83%88%E3%81%AB%E6%8C%91%E6%88%A6%E4%B8%AD,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","willani","日記","C"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/1741da28aa87b809153d2c6799f500b28fc236a8","comment":"注釈内の改行を削除してremark-footnoteで正しく変換されるよう修正\n","date_modified":"2021-05-05T19:47:55+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9470701518a306f61902c24abe1038e60148eb1d","comment":"Add posts/willani-try-selfhost.md\n","date_modified":"2020-07-07T03:01:07+09:00"}],"content_html":"<p>以前の記事「<a href=\"/posts/willani-start/\">数日前からCコンパイラを書き始めた。</a>」「<a href=\"/posts/willani-compliperbook-finished/\">自作Cコンパイラの途中経過</a>」に続く記事。</p>\n<p>これは日記であって、知見が書かれた文章ではない。</p>\n<h2>経過報告</h2>\n<p>気づけば2020年も半分が終わり、梅雨に入って雨が続き、今日もジメジメと蒸し暑い。\n大学の研究室は相変わらずリモートで、新型コロナウィルスの東京都の感染者数も100人を超える日が続き、収束の気配がない。</p>\n<p>世間は春から夏へ季節が変わろうとしているし、世界的にウィルスとの戦いを繰り広げている昨今だが、私のやっていることは相変わらずCコンパイラ「<a href=\"https://github.com/yammerjp/willani\">willani</a>」の制作。もう6週目になるだろうか。</p>\n<p>昨日あたりからセルフホストに向けて、やっとコンパイラ本体のコードを第一世代コンパイラに流し始めた。\nまだ本体のコード全ての機能は実装していないため、そのあたりは置き換えるシェルスクリプトを書いて、一旦スクリプトを挟んでからコンパイルする。\n(#include, 可変長引数定義, 構造体の初期化などが未実装)</p>\n<p>プリプロセスは#defineだけ実装した。プリプロセッサの大枠はできており、他のプリプロセス文も頑張れば実装できそう感はある。\n他にも、ちょっと頑張れば追加できそうな機能がいくつかあるが、一旦機能追加よりもセルフホストに軸をおくことにした。</p>\n<p>20以上のファイルに分割しているので、ファイル単位で置き換えていく。\n一つのオブジェクトファイルをを第一世代コンパイラで出力したものに置き換える。\n問題なければ次のファイルを第一世代コンパイラで出力したものに置き換える。\n問題なければ、、、と繰り返し作業を進める。</p>\n<h2>よくわからなかったこと</h2>\n<p>親コンパイラと第一世代コンパイラでコンパイルしたものを混ぜてgccに投げると、うまく静的リンクできない。\nPIEがどうこう、.textセクションやdataセクションは動的リンクでは使えないぞ、などと怒られる。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-variable\">$gcc</span> -static -o willani *.c *.s <span class=\"hljs-comment\"># *.sはwillaniでコンパイルしたアセンブリ</span></code></pre>\n<p>解決策として、コンパイルと、アセンブル&#x26;リンクを分けて行った。\n親コンパイラの出力も一旦、個々のアセンブリファイルとして出力する。 <code>$gcc hoge.c -S -o hoge.s</code>のように。</p>\n<p>これらを第一世代コンパイラで出力したアセンブリと混ぜてリンクしてもらう。\nリンクはlibcが必要である。\ngccコマンド(<code>$gcc *.s -static -o willani</code>)で行った。\n(<code>$ld</code>を使ってlibcを含んで静的リンクするのってどうやるの?未調査。)</p>\n<p>アセンブルとリンクは分けなくても問題なかった。\n(<code>$as hoge.s -o hoge.o</code>とアセンブルを別途行ってもいいが、gccにアセンブリを投げたらいい感じにリンクまで終わらせてくれる。)</p>\n<h2>第二世代コンパイラのデバッグがつらそう</h2>\n<p>構造体のメモリ配置がABIに従ってなさそうで、今第1.5世代コンパイラ<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>がバグっている。\n第一世代コンパイラはテストに通るのに第二世代コンパイラ(1.5世代含む)はバグっている状況は、どこから手をつけていいかわからずに混乱した。\n今後も前途多難だな。。</p>\n<h2>技術メモ:gccでデバッグ情報のないアセンブリを出力する</h2>\n<p>今さっき知ったtips</p>\n<p><code>$gcc sample.c -S -o sample-s</code>のようにコンパイルすると、デバッグ情報が含まれる。(<code>-g</code>オプションとは違い、最低限。)\n例えば<code>.cfi_startproc</code>などの行が出力に含まれて、人間が読むときには邪魔。</p>\n<p>そこで、***<code>-fno-asynchronous-unwind-tables</code>***オプションが有効。</p>\n<p><code>$gcc sample.c -fno-asynchronous-unwind-tables -S -static -o sample.s</code>のようにオプションを追加すると無駄な行が出力されないので読みやすくなる。</p>\n<p>Cの仕様を調べるとき、gccの出力と見比べたりするのが結構役に立つので、見やすいアセンブリを出せて助かる。(車輪の再発明だからできることだが。)</p>\n<h2>コンパイラをつくっていて良いこと</h2>\n<p>車輪の再発明あるあるではあるが、ブラックボックスを一つ紐解けた。<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></p>\n<p>作る前はコンパイラはよくわからないがよしなにやってくれるもので、アセンブリはとっつきづらいもので、オブジェクトファイルってあるよな程度の理解だった。\n概念としてコンパイル、アセンブル、リンクは知っていたが、実装レベルで知れるのは良い。\nコンパイラは要するに文字列変換プログラムだし、アセンブリはただのテキストデータだし、(リンクはそこそこ大変そうで学ぶべきことがたくさんありそうだけど)、何やってるかは以前より想像がつくようになった。</p>\n<h2>これからやること</h2>\n<ul>\n<li>構造体のメモリ配置を System V ABI に準拠させる</li>\n<li>構造体の初期化文</li>\n<li>セルフホスト</li>\n<li>#include</li>\n<li>#ifndef #ifdef #if #end</li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">第1.5世代コンパイラ ... 親コンパイラ(gcc)の出力と第一世代コンパイラの出力を混ぜてアセンブル、リンクして作ったコンパイラを指す。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">ブラックボックスを紐解く ... 過去にPDFファイルを自分で作ったり、正規表現エンジン(作りかけ)を作ったり、認証認可の仕組みを作ったときも同じ気持ちになった。今後、OS(途中で止まってる)やHTTPサーバ、インタプリタ(やJITコンパイラ)なんかも生きてるうちに取り組みたい。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"以前の記事「数日前からCコンパイラを書き始めた。」「自作Cコンパイラの途中経過」に続く記事。\n\nこれは日記であって、知見が書かれた文章ではない。\n\n経過報告\n\n気づけば2020年も半分が終わり、梅雨に入って雨が続き、今日もジメジメと蒸し暑い。\n大学の研究室は相変わらずリモートで、新型コロナウィルスの東京都の感染者数も100人を超える日が続き、収束の気配がない。\n\n世間は春から夏へ季節が変わろうとしているし、世界的にウィルスとの戦いを繰り広げている昨今だが、私のやっていることは相変わらずCコンパイラ「willani」の制作。もう6週目になるだろうか。\n\n昨日あたりからセルフホストに向けて、やっとコンパイラ本体のコードを第一世代コンパイラに流し始めた。\nまだ本体のコード全ての機能は実装していないため、そのあたりは置き換えるシェルスクリプトを書いて、一旦スクリプトを挟んでからコンパイルする。\n(#include, 可変長引数定義, 構造体の初期化などが未実装)\n\nプリプロセスは#defineだけ実装した。プリプロセッサの大枠はできており、他のプリプロセス文も頑張れば実装できそう感はある。\n他にも、ちょっと頑張れば追加できそうな機能がいくつかあるが、一旦機能追加よりもセルフホストに軸をおくことにした。\n\n20以上のファイルに分割しているので、ファイル単位で置き換えていく。\n一つのオブジェクトファイルをを第一世代コンパイラで出力したものに置き換える。\n問題なければ次のファイルを第一世代コンパイラで出力したものに置き換える。\n問題なければ、、、と繰り返し作業を進める。\n\nよくわからなかったこと\n\n親コンパイラと第一世代コンパイラでコンパイルしたものを混ぜてgccに投げると、うまく静的リンクできない。\nPIEがどうこう、.textセクションやdataセクションは動的リンクでは使えないぞ、などと怒られる。\n\n\n\n解決策として、コンパイルと、アセンブル&リンクを分けて行った。\n親コンパイラの出力も一旦、個々のアセンブリファイルとして出力する。 $gcc hoge.c -S -o hoge.sのように。\n\nこれらを第一世代コンパイラで出力したアセンブリと混ぜてリンクしてもらう。\nリンクはlibcが必要である。\ngccコマンド($gcc \\*.s -static -o willani)で行った。\n($ldを使ってlibcを含んで静的リンクするのってどうやるの?未調査。)\n\nアセンブルとリンクは分けなくても問題なかった。\n($as hoge.s -o hoge.oとアセンブルを別途行ってもいいが、gccにアセンブリを投げたらいい感じにリンクまで終わらせてくれる。)\n\n第二世代コンパイラのデバッグがつらそう\n\n構造体のメモリ配置がABIに従ってなさそうで、今第1.5世代コンパイラ[^1]がバグっている。\n第一世代コンパイラはテストに通るのに第二世代コンパイラ(1.5世代含む)はバグっている状況は、どこから手をつけていいかわからずに混乱した。\n今後も前途多難だな。。\n\n技術メモ:gccでデバッグ情報のないアセンブリを出力する\n\n今さっき知ったtips\n\n$gcc sample.c -S -o sample-sのようにコンパイルすると、デバッグ情報が含まれる。(-gオプションとは違い、最低限。)\n例えば.cfi_startprocなどの行が出力に含まれて、人間が読むときには邪魔。\n\nそこで、\\*\\*\\*-fno-asynchronous-unwind-tables\\*\\*\\*オプションが有効。\n\n$gcc sample.c -fno-asynchronous-unwind-tables -S -static -o sample.sのようにオプションを追加すると無駄な行が出力されないので読みやすくなる。\n\nCの仕様を調べるとき、gccの出力と見比べたりするのが結構役に立つので、見やすいアセンブリを出せて助かる。(車輪の再発明だからできることだが。)\n\nコンパイラをつくっていて良いこと\n\n車輪の再発明あるあるではあるが、ブラックボックスを一つ紐解けた。[^2]\n\n作る前はコンパイラはよくわからないがよしなにやってくれるもので、アセンブリはとっつきづらいもので、オブジェクトファイルってあるよな程度の理解だった。\n概念としてコンパイル、アセンブル、リンクは知っていたが、実装レベルで知れるのは良い。\nコンパイラは要するに文字列変換プログラムだし、アセンブリはただのテキストデータだし、(リンクはそこそこ大変そうで学ぶべきことがたくさんありそうだけど)、何やってるかは以前より想像がつくようになった。\n\nこれからやること\n\n構造体のメモリ配置を System V ABI に準拠させる\n\n構造体の初期化文\n\nセルフホスト\n\n\\#include\n\n\\#ifndef #ifdef #if #end\n\n[^1]: 第1.5世代コンパイラ ... 親コンパイラ(gcc)の出力と第一世代コンパイラの出力を混ぜてアセンブル、リンクして作ったコンパイラを指す。\n\n[^2]: ブラックボックスを紐解く ... 過去にPDFファイルを自分で作ったり、正規表現エンジン(作りかけ)を作ったり、認証認可の仕組みを作ったときも同じ気持ちになった。今後、OS(途中で止まってる)やHTTPサーバ、インタプリタ(やJITコンパイラ)なんかも生きてるうちに取り組みたい。\n"},{"id":"http://localhost:3000/posts/firebase2hatenablog","url":"http://localhost:3000/posts/firebase2hatenablog","title":"はてなブログに乗り換えた","summary":"昨年に作ったブログの公開場所をはてなブログに変え、名前も「やんまーのブログ」と改名した。 以前は Firebase Hosting 上に、 Nuxt.js の Generate モードで生成した HTML ファイルを公開していた。 移行するにあたって次のことを行った。 はてなブログCLI gimonfu による記事管理 Zeit Nowを使った旧ドメインの転送処理 1\\. gimonfu による記事管理 はてなブログは Markdown で記事を作成でき、これが乗り換える後押しになった。 Markdown の記事は、以前のブログでも GitHub 上で記事を管理していたので、今回も同じことを行","date_published":"2020-06-14T21:26:00+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%81%AF%E3%81%A6%E3%81%AA%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AB%E4%B9%97%E3%82%8A%E6%8F%9B%E3%81%88%E3%81%9F,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["はてなブログ"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/698524967ae01574a8037c627a8b083e253a04f2","comment":"Fix internal links\n","date_modified":"2020-10-04T22:43:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9e1ae1db614f211876a379a61235e4e93956f4a5","comment":"Add posts\n","date_modified":"2020-06-14T21:27:45+09:00"}],"content_html":"<p>昨年に作ったブログの公開場所をはてなブログに変え、名前も「やんまーのブログ」と改名した。</p>\n<p>以前は Firebase Hosting 上に、 Nuxt.js の Generate モードで生成した HTML ファイルを公開していた。</p>\n<p>移行するにあたって次のことを行った。</p>\n<ol>\n<li>はてなブログCLI gimonfu による記事管理</li>\n<li>Zeit Nowを使った旧ドメインの転送処理</li>\n</ol>\n<h2>1. <a href=\"https://github.com/yammerjp/gimonfu\">gimonfu</a> による記事管理</h2>\n<p>はてなブログは Markdown で記事を作成でき、これが乗り換える後押しになった。</p>\n<p>Markdown の記事は、以前のブログでも GitHub 上で記事を管理していたので、今回も同じことを行いたいと思っていた。</p>\n<p>そこではてなブログの CLI を作り、GitHub上のリポジトリと同期するようにした。<br>\n<a href=\"http://developer.hatena.ne.jp/ja/documents/blog/apis/atom\">はてなブログはAPIを公開しており</a>、これを使って Markdown ファイルをアップロード、ダウンロードしている。</p>\n<p>はてなブログの CLI には、既に <a href=\"https://github.com/x-motemen/blogsync\">blogsync</a> というソフトウェアがある。<br>\n当初はこのソフトウェアを使おうと思っていたのだが、新規記事投稿の部分が自分の思うように行かず、APIを触っているうちに、全部作ったほうがいいのでは？という気持ちになり CLI が出来上がってしまった。</p>\n<p><a href=\"https://github.com/x-motemen/blogsync\">blogsync</a> と <a href=\"https://github.com/x-motemen/blogsync\">gimonfu</a> はどちらも1記事につき、1ファイルで、ファイル先頭に YAML Front matter といわれる YAML 形式の記事情報を含む。\nまたURLの構造が記事ファイルのディレクトリ構造となる点も同じだ。</p>\n<p>一方で、記事の投稿に関しては異なる点がある。<br>\nblogsync では、記事本文のみを標準入力で CLI に渡すが、 gimonfu では、対象ディレクトリ内にある新しいファイルを新規記事として認識し投稿する。</p>\n<p>こうすると、CIを組み合わせれば、新規投稿時にも CLI を直接触らずに運用できる。</p>\n<p>現にこのブログも、新規投稿時にファイルを追加して GitHub に push すれば、自動的にはてなブログも更新されるようにしてある。 (逆にはてなブログが更新されたらGitHub にも反映されるワークフローも設定している。)</p>\n<p>gimonfu の使い方の詳細は <a href=\"https://github.com/yammerjp/gimonfu\">README</a> に譲るが、<a href=\"https://github.com/yammerjp/basd4g.hatenablog.com/tree/master/.github/workflows\">このブログのワークフロー</a>と同じものを GitHub Actions に指定すれば、記事管理がとても捗ると思うので是非活用して欲しい。</p>\n<h2>2. Zeit now を使った旧ドメインの転送処理</h2>\n<p>旧ドメインの記事を公開していた URL は全て、express.js を使って、今の記事に 301 リダイレクトするように設定した。(<a href=\"/posts/zeit-now/\">設定した内容</a>)</p>\n<p>Now を初めて使ったが、とても簡単にアプリケーションを公開できるので、さくっと作ったときなどに活用していきたい。</p>\n<hr>\n<p>というわけで、これからはてなブログで更新していきます。\nよろしくお願いします。(誰に)</p>\n<hr>\n<p>追記: (2020/10/04) ドメイン転送の記事へのリンクを相対リンクに修正</p>\n","content_text":"昨年に作ったブログの公開場所をはてなブログに変え、名前も「やんまーのブログ」と改名した。\n\n以前は Firebase Hosting 上に、 Nuxt.js の Generate モードで生成した HTML ファイルを公開していた。\n\n移行するにあたって次のことを行った。\n\nはてなブログCLI gimonfu による記事管理\n\nZeit Nowを使った旧ドメインの転送処理\n\n1\\. gimonfu による記事管理\n\nはてなブログは Markdown で記事を作成でき、これが乗り換える後押しになった。\n\nMarkdown の記事は、以前のブログでも GitHub 上で記事を管理していたので、今回も同じことを行いたいと思っていた。\n\nそこではてなブログの CLI を作り、GitHub上のリポジトリと同期するようにした。\nはてなブログはAPIを公開しており、これを使って Markdown ファイルをアップロード、ダウンロードしている。\n\nはてなブログの CLI には、既に blogsync というソフトウェアがある。\n当初はこのソフトウェアを使おうと思っていたのだが、新規記事投稿の部分が自分の思うように行かず、APIを触っているうちに、全部作ったほうがいいのでは？という気持ちになり CLI が出来上がってしまった。\n\nblogsync と gimonfu はどちらも1記事につき、1ファイルで、ファイル先頭に YAML Front matter といわれる YAML 形式の記事情報を含む。\nまたURLの構造が記事ファイルのディレクトリ構造となる点も同じだ。\n\n一方で、記事の投稿に関しては異なる点がある。\nblogsync では、記事本文のみを標準入力で CLI に渡すが、 gimonfu では、対象ディレクトリ内にある新しいファイルを新規記事として認識し投稿する。\n\nこうすると、CIを組み合わせれば、新規投稿時にも CLI を直接触らずに運用できる。\n\n現にこのブログも、新規投稿時にファイルを追加して GitHub に push すれば、自動的にはてなブログも更新されるようにしてある。 (逆にはてなブログが更新されたらGitHub にも反映されるワークフローも設定している。)\n\ngimonfu の使い方の詳細は README に譲るが、このブログのワークフローと同じものを GitHub Actions に指定すれば、記事管理がとても捗ると思うので是非活用して欲しい。\n\n2\\. Zeit now を使った旧ドメインの転送処理\n\n旧ドメインの記事を公開していた URL は全て、express.js を使って、今の記事に 301 リダイレクトするように設定した。(設定した内容)\n\nNow を初めて使ったが、とても簡単にアプリケーションを公開できるので、さくっと作ったときなどに活用していきたい。\n\n\n\nというわけで、これからはてなブログで更新していきます。\nよろしくお願いします。(誰に)\n\n\n\n追記: (2020/10/04) ドメイン転送の記事へのリンクを相対リンクに修正\n"},{"id":"http://localhost:3000/posts/gimonfu","url":"http://localhost:3000/posts/gimonfu","title":"gimonfu で、はてなブログの記事を GitHub と同期する","summary":"ブログをはてなブログに移行するにあたり、記事を管理する CLI 「gimonfu」を作成した。 本記事では、gimonfu と GitHub Actions を使って、GitHub のリポジトリとはてなブログを連携し、記事を git で管理できるように設定を行う。 記事の内容を設定すれば、Markdown ファイルを GitHub のリポジトリにプッシュするとはてなブログに記事を公開できたり、はてなの Web ページで記事を編集すると、GitHub のリポジトリに自動で反映されてバックアップを取ることができる。 最終的な GitHub Actions の設定は、私のブログの記事リポジトリにある","date_published":"2020-06-14T21:23:06+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:gimonfu%20%E3%81%A7%E3%80%81%E3%81%AF%E3%81%A6%E3%81%AA%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AE%E8%A8%98%E4%BA%8B%E3%82%92%20GitHub%20%E3%81%A8%E5%90%8C%E6%9C%9F%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","はてなブログ","CI","GitHub Actions"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>ブログをはてなブログに移行するにあたり、記事を管理する CLI <a href=\"https://github.com/yammerjp/gimonfu\">「gimonfu」</a>を作成した。</p>\n<p>本記事では、gimonfu と GitHub Actions を使って、GitHub のリポジトリとはてなブログを連携し、記事を git で管理できるように設定を行う。</p>\n<p>記事の内容を設定すれば、Markdown ファイルを GitHub のリポジトリにプッシュするとはてなブログに記事を公開できたり、はてなの Web ページで記事を編集すると、GitHub のリポジトリに自動で反映されてバックアップを取ることができる。</p>\n<p>最終的な GitHub Actions の設定は、<a href=\"https://github.com/yammerjp/basd4g.hatenablog.com/tree/master/.github/workflows\">私のブログの記事リポジトリ</a>にある yaml にて確認できる。</p>\n<h2>もくじ</h2>\n<p>次の流れで設定する</p>\n<ol>\n<li>はてなブログの記事執筆設定を Markdown モードにする</li>\n<li>はてなブログの API キーを確認する</li>\n<li>GitHub リポジトリを作り、ワークフローに使う Secrets を登録する</li>\n<li>記事をダウンロードするワークフローを追加する</li>\n<li>記事をダウンロードするワークフローを定期実行させる</li>\n<li>記事をアップロードするワークフローを追加する</li>\n</ol>\n<h2>1. はてなブログの記事執筆設定を Markdown モードにする</h2>\n<p>はじめに、はてなブログの設定を変更し、記事執筆設定を Markdown モードにする。</p>\n<p><a href=\"https://blog.hatena.ne.jp/-/config\">はてなブログの設定ページ</a>から、設定 -> 編集モード を 「Markdownモード」に設定し「変更する」ボタンを押す</p>\n<p>まずはてなブログの基本設定を開く。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-1.png\" alt=\"はてなブログの基本設定を開く\"></p>\n<p>下へスクロールし、編集モードを Markdown モードにする。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-2.png\" alt=\"編集モードを Markdown モードへ\"></p>\n<p>「変更する」ボタンを押して変更を反映する。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-3.png\" alt=\"「変更する」ボタンを押して変更を反映する\"></p>\n<p>(補足: 他のモードでも動作確認はしていないので、もし Markdown 記法以外を利用する場合はご自身で試して欲しい。</p>\n<h2>2. はてなブログの API キーを確認する</h2>\n<p><a href=\"https://blog.hatena.ne.jp/-/config\">はてなブログの設定ページ</a>から、設定 -> 詳細設定 に移動し、ユーザID, ブログID, API キー をメモする</p>\n<p>まずはてなブログの詳細設定を開く。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-4.png\" alt=\"詳細設定へ移動\"></p>\n<p>下へスクロールし、AtomPubの項目から、ユーザID, ブログID, APIキーを確認する。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-5.png\" alt=\"APIキーをメモする\"></p>\n<h2>3. GitHub リポジトリを作り、ワークフローに使う Secrets を登録する</h2>\n<p>ワークフローとは、GitHub Actions で実行する一連の内容を記したものである。\n指定した時間になったときや、GitHub に コミットをプッシュしたとき、事前に作成したワークフローを自動で実行できる。</p>\n<p>この章では、GitHub で新しいリポジトリを作り、ワークフローで使う Secrets を登録する。</p>\n<p>まずは、新しいリポジトリを作った後、Settings -> Secrets を開く</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-6.png\" alt=\"Secrets 登録画面を開く\"></p>\n<p>ワークフローで使う Name と Value の組み合わせを5組登録する</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-7.png\" alt=\"Secrets の Name と Value を登録する\"></p>\n<p>登録する内容は次の通り。\n例を参考に自分の文字列に置き換えてほしいj</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Value</th>\n<th>Value (例)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>HATENA_USER</code></td>\n<td>先程確認したはてなブログのユーザID</td>\n<td>basd4g</td>\n</tr>\n<tr>\n<td><code>HATENA_BLOG_ID</code></td>\n<td>先程確認したはてなブログのブログID</td>\n<td>basd4g.hatenablog.com</td>\n</tr>\n<tr>\n<td><code>HATENA_API_KEY</code></td>\n<td>先程確認したはてなブログのAPIキー</td>\n<td>abcdef0123</td>\n</tr>\n<tr>\n<td><code>GIT_NAME</code></td>\n<td>(ワークフローで自動的に作られるコミットの)自分の名前</td>\n<td>Taro Yamada</td>\n</tr>\n<tr>\n<td><code>GIT_MAIL</code></td>\n<td>(ワークフローで自動的に作られるコミットの)自分のメールアドレス</td>\n<td><a href=\"mailto:basd4g@example.com\">basd4g@example.com</a></td>\n</tr>\n</tbody>\n</table>\n<h2>4. 記事をダウンロードするワークフローを追加する</h2>\n<p>記事をダウンロードする GitHub Actions ワークフローを追加する。</p>\n<p>ワークフローは GitHub リポジトリのWebページ上からも追加できる。</p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-8.png\" alt=\"新しいワークフローを追加する\"></p>\n<p><img src=\"https://blob.yammer.jp/gimonfu-9.png\" alt=\"記事をダウンロードするワークフローを追加する\"></p>\n<p><code>.github/workflows/pull.yaml</code> に次の内容を記述する</p>\n<div class=\"remark-code-title\">pull.yaml</div>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Pull</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">push:</span>\n    <span class=\"hljs-attr\">branches:</span> [ <span class=\"hljs-string\">master</span> ]\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">pull:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n\n    <span class=\"hljs-attr\">steps:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Commit</span>\n      <span class=\"hljs-attr\">env:</span>\n        <span class=\"hljs-attr\">HATENA_USER_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_USER</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">HATENA_BLOG_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_BLOG_ID</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">HATENA_API_KEY:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_API_KEY</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">GIT_NAME:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.GIT_NAME</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">GIT_MAIL:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.GIT_MAIL</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">REPO_OWNER:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">github.repository_owner</span> <span class=\"hljs-string\">}}</span>\n      <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n        cd ${GITHUB_WORKSPACE}\n</span>\n        <span class=\"hljs-comment\"># コミットのためのgitの設定</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'git initialize'</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.name</span> <span class=\"hljs-string\">\"${GIT_NAME}\"</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.email</span> <span class=\"hljs-string\">\"${GIT_MAIL}\"</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">\"https://${REPO_OWNER}:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git\"</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'gimonfu initialize'</span>\n\n        <span class=\"hljs-comment\"># gimonfuの初期設定</span>\n        <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">init</span> <span class=\"hljs-string\">-y</span> <span class=\"hljs-string\">></span> <span class=\"hljs-string\">/dev/null</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">>&#x26;1</span>\n        <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">gimonfu</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">\"{\\\"user_id\\\":\\\"${HATENA_USER_ID}\\\",\\\"blog_id\\\":\\\"${HATENA_BLOG_ID}\\\",\\\"api_key\\\":\\\"${HATENA_API_KEY}\\\"}\"</span> <span class=\"hljs-string\">></span> <span class=\"hljs-string\">.gimonfu.json</span>\n\n        <span class=\"hljs-comment\"># 新しい/更新された記事をダウンロード</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'gimonfu pull'</span>\n        <span class=\"hljs-string\">npx</span> <span class=\"hljs-string\">gimonfu</span> <span class=\"hljs-string\">--git-commit-date</span> <span class=\"hljs-string\">pull</span>\n\n        <span class=\"hljs-comment\"># コミットを作成する</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">add</span> <span class=\"hljs-string\">entry</span>\n        <span class=\"hljs-comment\"># This script will not make a commit if there are no changes.</span>\n        <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">!</span> <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">diff</span> <span class=\"hljs-string\">--staged</span> <span class=\"hljs-string\">--exit-code</span> <span class=\"hljs-string\">--quiet;</span> <span class=\"hljs-string\">then</span> <span class=\"hljs-string\">\\</span>\n          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">commit</span> <span class=\"hljs-string\">-m</span> <span class=\"hljs-string\">\"Pull articles (automatic commit)\"</span> <span class=\"hljs-string\">;\\</span>\n        <span class=\"hljs-string\">fi</span>\n\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">push</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">HEAD:master</span></code></pre>\n<p>コミットが GitHub 上にプッシュされると、ワークフローが走ってリポジトリに記事が反映される。</p>\n<h2>5. 記事をダウンロードするワークフローを定期実行させる</h2>\n<p>先程は初回だったので「master ブランチにプッシュしたときにワークフローを実行する」(=>はてなブログの内容を GitHub リポジトリに反映させる)設定にした。</p>\n<p>ここではワークフローの一部を書き換えて、1時間に一回ワークフローを実行させる。</p>\n<p><code>.github/workflows/pull.yaml</code> の内容を一部書き換える。</p>\n<pre><code class=\"hljs language-diff\"><span class=\"hljs-comment\">--- a/.github/workflows/pull.yaml</span>\n<span class=\"hljs-comment\">+++ b/.github/workflows/pull.yaml</span>\n<span class=\"hljs-meta\">@@ -1,8 +1,8 @@</span>\n name: Pull\n \n on:\n<span class=\"hljs-deletion\">-  push:</span>\n<span class=\"hljs-deletion\">-    branches: [ master ]</span>\n<span class=\"hljs-addition\">+  schedule:</span>\n<span class=\"hljs-addition\">+    - cron: '0 * * * *'</span>\n \n jobs:\n   pull:</code></pre>\n<h2>6. 記事をアップロードするワークフローを追加する</h2>\n<p><code>.github/workflows/push.yaml</code>に次の内容を記述してコミット、プッシュする。</p>\n<div class=\"remark-code-title\">.github/workflows/push.yaml</div>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Push</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">push:</span>\n    <span class=\"hljs-attr\">branches:</span> [ <span class=\"hljs-string\">master</span> ]\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">push:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n\n    <span class=\"hljs-attr\">steps:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">Commit</span>\n      <span class=\"hljs-attr\">env:</span>\n        <span class=\"hljs-attr\">HATENA_USER_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_USER</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">HATENA_BLOG_ID:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_BLOG_ID</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">HATENA_API_KEY:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.HATENA_API_KEY</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">GIT_NAME:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.GIT_NAME</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">GIT_MAIL:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.GIT_MAIL</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">REPO_OWNER:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">github.repository_owner</span> <span class=\"hljs-string\">}}</span>\n      <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n        cd ${GITHUB_WORKSPACE}\n</span>\n        <span class=\"hljs-comment\"># コミットのためのgitの設定</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'git initialize'</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.name</span> <span class=\"hljs-string\">\"${GIT_NAME}\"</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.email</span> <span class=\"hljs-string\">\"${GIT_MAIL}\"</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">\"https://${REPO_OWNER}:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git\"</span>\n\n        <span class=\"hljs-comment\"># gimonfuの初期設定</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'gimonfu initialize'</span>\n        <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">init</span> <span class=\"hljs-string\">-y</span> <span class=\"hljs-string\">></span> <span class=\"hljs-string\">/dev/null</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">>&#x26;1</span>\n        <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">gimonfu</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">\"{\\\"user_id\\\":\\\"${HATENA_USER_ID}\\\",\\\"blog_id\\\":\\\"${HATENA_BLOG_ID}\\\",\\\"api_key\\\":\\\"${HATENA_API_KEY}\\\"}\"</span> <span class=\"hljs-string\">></span> <span class=\"hljs-string\">.gimonfu.json</span>\n\n        <span class=\"hljs-comment\"># 新しい/更新された記事をアップロード</span>\n        <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">'gimonfu push'</span>\n        <span class=\"hljs-string\">npx</span> <span class=\"hljs-string\">gimonfu</span> <span class=\"hljs-string\">--git-commit-date</span> <span class=\"hljs-string\">push</span>\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">add</span> <span class=\"hljs-string\">entry</span>\n\n        <span class=\"hljs-comment\"># コミットを作成する</span>\n        <span class=\"hljs-comment\"># This script will not make a commit if there are no changes.</span>\n        <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">!</span> <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">diff</span> <span class=\"hljs-string\">--staged</span> <span class=\"hljs-string\">--exit-code</span> <span class=\"hljs-string\">--quiet;</span> <span class=\"hljs-string\">then</span> <span class=\"hljs-string\">\\</span>\n          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">commit</span> <span class=\"hljs-string\">-m</span> <span class=\"hljs-string\">\"Pull articles (automatic commit)\"</span> <span class=\"hljs-string\">;\\</span>\n        <span class=\"hljs-string\">fi</span>\n\n        <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">push</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">HEAD:master</span></code></pre>\n<h2>6. 記事の投稿と更新</h2>\n<p>以上の設定を行うと、GitHub のリポジトリとはてなブログの記事が同期できる。</p>\n<p>GitHub 上の Markdown ファイルを上書きすると記事が更新されるし、新しい Markdown ファイルを追加すると記事が投稿される。</p>\n<p>Markdownファイルは次のような記述で始まる。</p>\n<pre><code class=\"hljs language-md\">---\ntitle: タイトル\ndate: 2019-09-18T12:50:00.000Z\n<span class=\"hljs-section\">id: \"26006613576772424\"\n---</span>\n\n記事本文が以降続く。</code></pre>\n<p>記事の冒頭に <code>---</code> で挟んだYAML形式のメタ情報を付加する。\n<code>id: </code>の行は新規投稿時には記述しない。投稿されると自動で付加される。</p>\n<h2>おわりに</h2>\n<p>ブログ記事を Git で管理したいというモチベーションから CLI を作るまでに至った。</p>\n<p>GitHub Actions のワークフローを登録しておけば、ローカルに gimonfu をインストールせずに使えるが、インストールして使うこともできる。\n<code>$ npm install -g gimonfu</code>でインストールでき、使い方は <a href=\"https://github.com/yammerjp/gimonfu\">README</a> で説明している。</p>\n<hr>\n<p>ここまで読んでいただいてありがとうございました。\nあなたのはてなブログ生活が捗ることを願っています。</p>\n","content_text":"ブログをはてなブログに移行するにあたり、記事を管理する CLI 「gimonfu」を作成した。\n\n本記事では、gimonfu と GitHub Actions を使って、GitHub のリポジトリとはてなブログを連携し、記事を git で管理できるように設定を行う。\n\n記事の内容を設定すれば、Markdown ファイルを GitHub のリポジトリにプッシュするとはてなブログに記事を公開できたり、はてなの Web ページで記事を編集すると、GitHub のリポジトリに自動で反映されてバックアップを取ることができる。\n\n最終的な GitHub Actions の設定は、私のブログの記事リポジトリにある yaml にて確認できる。\n\nもくじ\n\n次の流れで設定する\n\nはてなブログの記事執筆設定を Markdown モードにする\n\nはてなブログの API キーを確認する\n\nGitHub リポジトリを作り、ワークフローに使う Secrets を登録する\n\n記事をダウンロードするワークフローを追加する\n\n記事をダウンロードするワークフローを定期実行させる\n\n記事をアップロードするワークフローを追加する\n\n1\\. はてなブログの記事執筆設定を Markdown モードにする\n\nはじめに、はてなブログの設定を変更し、記事執筆設定を Markdown モードにする。\n\nはてなブログの設定ページから、設定 -> 編集モード を 「Markdownモード」に設定し「変更する」ボタンを押す\n\nまずはてなブログの基本設定を開く。\n\nはてなブログの基本設定を開く\n\n下へスクロールし、編集モードを Markdown モードにする。\n\n編集モードを Markdown モードへ\n\n「変更する」ボタンを押して変更を反映する。\n\n「変更する」ボタンを押して変更を反映する\n\n(補足: 他のモードでも動作確認はしていないので、もし Markdown 記法以外を利用する場合はご自身で試して欲しい。\n\n2\\. はてなブログの API キーを確認する\n\nはてなブログの設定ページから、設定 -> 詳細設定 に移動し、ユーザID, ブログID, API キー をメモする\n\nまずはてなブログの詳細設定を開く。\n\n詳細設定へ移動\n\n下へスクロールし、AtomPubの項目から、ユーザID, ブログID, APIキーを確認する。\n\nAPIキーをメモする\n\n3\\. GitHub リポジトリを作り、ワークフローに使う Secrets を登録する\n\nワークフローとは、GitHub Actions で実行する一連の内容を記したものである。\n指定した時間になったときや、GitHub に コミットをプッシュしたとき、事前に作成したワークフローを自動で実行できる。\n\nこの章では、GitHub で新しいリポジトリを作り、ワークフローで使う Secrets を登録する。\n\nまずは、新しいリポジトリを作った後、Settings -> Secrets を開く\n\nSecrets 登録画面を開く\n\nワークフローで使う Name と Value の組み合わせを5組登録する\n\nSecrets の Name と Value を登録する\n\n登録する内容は次の通り。\n例を参考に自分の文字列に置き換えてほしいj\n\n\n\n4\\. 記事をダウンロードするワークフローを追加する\n\n記事をダウンロードする GitHub Actions ワークフローを追加する。\n\nワークフローは GitHub リポジトリのWebページ上からも追加できる。\n\n新しいワークフローを追加する\n\n記事をダウンロードするワークフローを追加する\n\n.github/workflows/pull.yaml に次の内容を記述する\n\n\n\nコミットが GitHub 上にプッシュされると、ワークフローが走ってリポジトリに記事が反映される。\n\n5\\. 記事をダウンロードするワークフローを定期実行させる\n\n先程は初回だったので「master ブランチにプッシュしたときにワークフローを実行する」(=>はてなブログの内容を GitHub リポジトリに反映させる)設定にした。\n\nここではワークフローの一部を書き換えて、1時間に一回ワークフローを実行させる。\n\n.github/workflows/pull.yaml の内容を一部書き換える。\n\n\n\n6\\. 記事をアップロードするワークフローを追加する\n\n.github/workflows/push.yamlに次の内容を記述してコミット、プッシュする。\n\n\n\n6\\. 記事の投稿と更新\n\n以上の設定を行うと、GitHub のリポジトリとはてなブログの記事が同期できる。\n\nGitHub 上の Markdown ファイルを上書きすると記事が更新されるし、新しい Markdown ファイルを追加すると記事が投稿される。\n\nMarkdownファイルは次のような記述で始まる。\n\n\n\n記事の冒頭に --- で挟んだYAML形式のメタ情報を付加する。\nid: の行は新規投稿時には記述しない。投稿されると自動で付加される。\n\nおわりに\n\nブログ記事を Git で管理したいというモチベーションから CLI を作るまでに至った。\n\nGitHub Actions のワークフローを登録しておけば、ローカルに gimonfu をインストールせずに使えるが、インストールして使うこともできる。\n$ npm install -g gimonfuでインストールでき、使い方は README で説明している。\n\n\n\nここまで読んでいただいてありがとうございました。\nあなたのはてなブログ生活が捗ることを願っています。\n"},{"id":"http://localhost:3000/posts/willani-compliperbook-finished","url":"http://localhost:3000/posts/willani-compliperbook-finished","title":"自作Cコンパイラの途中経過","summary":"Cコンパイラ自作の進捗 以前の記事に書いたとおり、C言語のコンパイラを自作している。 セルフホストには至ってないが、教科書であるオンラインブック「低レイヤを知りたい人のためのCコンパイラ作成入門」の内容が一通り実装し終わったので経過報告をする。 裏で最初は毎日記録をつけていたのだが、だんだん面倒くさくなってやめたので、コミット履歴を見ながら振り返る。 最初のコミットは19日前(5/21)なので、そろそろ三週間経ったところだ。 5/28-30の三日間以外は何かしらコミットしているので、継続的に開発できている。もっともバイトや授業に遮られることがなく、時間がたくさんあるのでできることであるが。 こ","date_published":"2020-06-09T17:00:06+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E8%87%AA%E4%BD%9CC%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E9%80%94%E4%B8%AD%E7%B5%8C%E9%81%8E,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","willani","日記","C"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/698524967ae01574a8037c627a8b083e253a04f2","comment":"Fix internal links\n","date_modified":"2020-10-04T22:43:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c6dbd6f67b55ff052997d1f8d4e9860e9f5f1778","comment":"Add a post of willani\n","date_modified":"2020-06-09T17:59:12+09:00"}],"content_html":"<h2>Cコンパイラ自作の進捗</h2>\n<p><a href=\"/posts/willani-start/\">以前の記事</a>に書いたとおり、C言語のコンパイラを自作している。</p>\n<p>セルフホストには至ってないが、教科書であるオンラインブック<a href=\"https://www.sigbus.info/compilerbook\">「低レイヤを知りたい人のためのCコンパイラ作成入門」</a>の内容が一通り実装し終わったので経過報告をする。</p>\n<p>裏で最初は毎日記録をつけていたのだが、だんだん面倒くさくなってやめたので、コミット履歴を見ながら振り返る。</p>\n<p>最初のコミットは19日前(5/21)なので、そろそろ三週間経ったところだ。\n5/28-30の三日間以外は何かしらコミットしているので、継続的に開発できている。もっともバイトや授業に遮られることがなく、時間がたくさんあるのでできることであるが。</p>\n<p>ここまでのマイルストーンとしては、次の機能開発があった。</p>\n<ul>\n<li>分岐,繰り返し処理ができる</li>\n<li>関数定義ができる</li>\n<li>型情報が付加される(完全なサブセットをコンパイルできるようになる)</li>\n<li>テストをCで書き直す</li>\n</ul>\n<p>テストをCで書き直す(<a href=\"https://www.sigbus.info/compilerbook#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9728-%E3%83%86%E3%82%B9%E3%83%88%E3%82%92c%E3%81%A7%E6%9B%B8%E3%81%8D%E7%9B%B4%E3%81%99\">オンラインブックStep28</a>)\nところでバグが結構見つかって一つ一つ潰すのに時間がかかった。<br>\nでもこの頃はGDBの基本的な使い方に慣れてきて、更に当たりをつけてアセンブリを読むことができたので、最初の頃より全然楽だった。</p>\n<p>テストファイルをCで書き直し、これを自作コンパイラでコンパイルすると10000万行(デバッグ情報含む)くらいのアセンブリになった。\nこれくらいの規模のプログラムがうまく実行できると、人間を超えていく感じがして楽しい。</p>\n<h2>狭いスコープのローカル変数</h2>\n<p>ブロックスコープ内の変数の実装方法は自分で考えたものなのだが、結構うまくできたと思っている。</p>\n<p><a href=\"https://github.com/yammerjp/willani\">willani</a>には変数一つを表す構造体があり、これをつなげた2つの単方向リストがそれぞれ、グローバル変数とローカル変数を表している。</p>\n<p>スコープのある変数を実装するには次の2つのことを考慮する必要がある。</p>\n<ol>\n<li>変数を定義するときは、同じスコープの重複した変数名を許さない。</li>\n<li>変数を呼び出すときは、同じ名前の変数のなかで、その式が属するスコープのうちもっとも狭いスコープの変数を指す。</li>\n</ol>\n<p>トークン列をパースするときに次のような方法で 1. 2. を実現した。<br>\nなお、私の実装ではブロックスコープの変数はローカル変数の単方向リストに含む。</p>\n<ol>\n<li>新しいスコープに入るときに、その前最後に定義されたローカル変数をのポインタを<code>out_of_scope</code>として記録する。</li>\n</ol>\n<p>変数定義するときは、単方向リストを先頭(最新)から<code>out_of_scope</code>の前までみて、同じ名前のものがないか調べる。</p>\n<ol start=\"2\">\n<li>変数を定義するとき、<code>Var.referable = true</code>というフラグを立てる。</li>\n</ol>\n<p>スコープを出るときに、そのスコープで定義した全ての変数 (<code>out_of_scope</code>より新しい定義の変数) のフラグを下げる。(<code>false</code>をセットする。)<br>\n以後呼び出す変数を探すときにフラグが<code>false</code>なものをスキップさせる。</p>\n<p>こうすることで、最新に定義した変数から順番に調べていけば、「1. その変数を定義してよいか」「2. 同名の異なる変数のうちどの変数を指しているか」がわかる。</p>\n<p>リストには全てのローカル変数が残っているので、コード生成時に変数の領域を確保するのが簡単だし、パース時にどの変数を指し示すか解釈しておけばコード生成時は変数名の重複を考える必要がない。</p>\n<h2>今後の展望</h2>\n<p>植山類さんのコンパイラ実装である <a href=\"https://github.com/rui314/9cc\">9cc</a> や <a href=\"https://github.com/rui314/chibicc\">chibicc</a> 等のコミットログをみて、セルフホストをするためにはあと1倍くらい、完成まではさらに1倍くらいの手間がかかるのではないかと予想している。</p>\n<p>セルフホストに必要そうな機能は次の通り。</p>\n<ul>\n<li>構造体</li>\n<li>'->'</li>\n<li>typedef</li>\n<li>プリプロセス</li>\n<li>bool型</li>\n<li>void型</li>\n<li>enum</li>\n<li>char literal</li>\n<li>(file scope function)</li>\n<li>switch</li>\n<li>'++', '--'</li>\n<li>'+='</li>\n<li>'!'</li>\n<li>'&#x26;&#x26;', '||'</li>\n<li>'break'</li>\n<li>'continue'</li>\n<li>'extern'</li>\n<li>'NULL'</li>\n<li>(3項演算子)</li>\n<li>(可変長引数関数の定義)</li>\n</ul>\n<p>(括弧がついてるのはサボろうか迷っているもの。\n特定の文法を自分のコードから削除して書き換えてしまえば、その文法に対応しなくてもセルフホストできてしまう)</p>\n<p>構造体とプリプロセスが時間かかりそうだなと見ている。</p>\n<p>Cの仕様書をどこまで実装するかは考えものだが、セルフホストはやっぱり楽しみ。</p>\n<p>Webのフロントエンドをはじめとする物々にも手を付けねばと思っているし、研究室の論文も読まねばと思っているので、今後はバランスも考えてやっていきたい。</p>\n<hr>\n<p>追記: (2020/10/04) 以前の記事へのリンクを相対リンクに修正</p>\n","content_text":"Cコンパイラ自作の進捗\n\n以前の記事に書いたとおり、C言語のコンパイラを自作している。\n\nセルフホストには至ってないが、教科書であるオンラインブック「低レイヤを知りたい人のためのCコンパイラ作成入門」の内容が一通り実装し終わったので経過報告をする。\n\n裏で最初は毎日記録をつけていたのだが、だんだん面倒くさくなってやめたので、コミット履歴を見ながら振り返る。\n\n最初のコミットは19日前(5/21)なので、そろそろ三週間経ったところだ。\n5/28-30の三日間以外は何かしらコミットしているので、継続的に開発できている。もっともバイトや授業に遮られることがなく、時間がたくさんあるのでできることであるが。\n\nここまでのマイルストーンとしては、次の機能開発があった。\n\n分岐,繰り返し処理ができる\n\n関数定義ができる\n\n型情報が付加される(完全なサブセットをコンパイルできるようになる)\n\nテストをCで書き直す\n\nテストをCで書き直す(オンラインブックStep28)\nところでバグが結構見つかって一つ一つ潰すのに時間がかかった。\nでもこの頃はGDBの基本的な使い方に慣れてきて、更に当たりをつけてアセンブリを読むことができたので、最初の頃より全然楽だった。\n\nテストファイルをCで書き直し、これを自作コンパイラでコンパイルすると10000万行(デバッグ情報含む)くらいのアセンブリになった。\nこれくらいの規模のプログラムがうまく実行できると、人間を超えていく感じがして楽しい。\n\n狭いスコープのローカル変数\n\nブロックスコープ内の変数の実装方法は自分で考えたものなのだが、結構うまくできたと思っている。\n\nwillaniには変数一つを表す構造体があり、これをつなげた2つの単方向リストがそれぞれ、グローバル変数とローカル変数を表している。\n\nスコープのある変数を実装するには次の2つのことを考慮する必要がある。\n\n変数を定義するときは、同じスコープの重複した変数名を許さない。\n\n変数を呼び出すときは、同じ名前の変数のなかで、その式が属するスコープのうちもっとも狭いスコープの変数を指す。\n\nトークン列をパースするときに次のような方法で 1. 2. を実現した。\nなお、私の実装ではブロックスコープの変数はローカル変数の単方向リストに含む。\n\n新しいスコープに入るときに、その前最後に定義されたローカル変数をのポインタをout_of_scopeとして記録する。\n\n変数定義するときは、単方向リストを先頭(最新)からout_of_scopeの前までみて、同じ名前のものがないか調べる。\n\n変数を定義するとき、Var.referable = trueというフラグを立てる。\n\nスコープを出るときに、そのスコープで定義した全ての変数 (out_of_scopeより新しい定義の変数) のフラグを下げる。(falseをセットする。)\n以後呼び出す変数を探すときにフラグがfalseなものをスキップさせる。\n\nこうすることで、最新に定義した変数から順番に調べていけば、「1. その変数を定義してよいか」「2. 同名の異なる変数のうちどの変数を指しているか」がわかる。\n\nリストには全てのローカル変数が残っているので、コード生成時に変数の領域を確保するのが簡単だし、パース時にどの変数を指し示すか解釈しておけばコード生成時は変数名の重複を考える必要がない。\n\n今後の展望\n\n植山類さんのコンパイラ実装である 9cc や chibicc 等のコミットログをみて、セルフホストをするためにはあと1倍くらい、完成まではさらに1倍くらいの手間がかかるのではないかと予想している。\n\nセルフホストに必要そうな機能は次の通り。\n\n構造体\n\n'->'\n\ntypedef\n\nプリプロセス\n\nbool型\n\nvoid型\n\nenum\n\nchar literal\n\n(file scope function)\n\nswitch\n\n'++', '--'\n\n'+='\n\n'!'\n\n'&&', '||'\n\n'break'\n\n'continue'\n\n'extern'\n\n'NULL'\n\n(3項演算子)\n\n(可変長引数関数の定義)\n\n(括弧がついてるのはサボろうか迷っているもの。\n特定の文法を自分のコードから削除して書き換えてしまえば、その文法に対応しなくてもセルフホストできてしまう)\n\n構造体とプリプロセスが時間かかりそうだなと見ている。\n\nCの仕様書をどこまで実装するかは考えものだが、セルフホストはやっぱり楽しみ。\n\nWebのフロントエンドをはじめとする物々にも手を付けねばと思っているし、研究室の論文も読まねばと思っているので、今後はバランスも考えてやっていきたい。\n\n\n\n追記: (2020/10/04) 以前の記事へのリンクを相対リンクに修正\n"},{"id":"http://localhost:3000/posts/zeit-now","url":"http://localhost:3000/posts/zeit-now","title":"Zeit Now を使って、express.jsで書かれたアプリケーションを独自ドメインで公開する","summary":"now という PaaS がある。 Node.js で書かれたアプリケーションを、無料で3つまでホスティングできるらしい。 heroku を無料プランで使うと、dyno の立ち上げに30秒くらいかかるので、Web サーバとしては致命的に遅い。 一方 zeit はそのような待ち時間は発生しない。(どこかに、AWS Lambda を中で使っていると書いてあった気がする) 今回はシンプルな express.js のアプリケーションを now でホスティングする手順。 インストール アプリケーションを作る index.js に次のように記入 now の設定 事前に、node.js のアプリケーションで","date_published":"2020-05-31T16:44:33+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Zeit%20Now%20%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%80%81express.js%E3%81%A7%E6%9B%B8%E3%81%8B%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E7%8B%AC%E8%87%AA%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","ドメイン"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/36edeaa370c8c63ac19dc3172219a0ed7bdb79e7","comment":"Add a post of zeit now\n","date_modified":"2020-05-31T16:56:01+09:00"}],"content_html":"<p>now という PaaS がある。</p>\n<p>Node.js で書かれたアプリケーションを、無料で3つまでホスティングできるらしい。</p>\n<p>heroku を無料プランで使うと、dyno の立ち上げに30秒くらいかかるので、Web サーバとしては致命的に遅い。\n一方 zeit はそのような待ち時間は発生しない。(どこかに、AWS Lambda を中で使っていると書いてあった気がする)</p>\n<p>今回はシンプルな express.js のアプリケーションを now でホスティングする手順。</p>\n<h2>インストール</h2>\n<pre><code class=\"hljs language-sh\">$ mkdir now-app\n$ <span class=\"hljs-built_in\">cd</span> now-app\n$ yarn init\n$ yarn global add now\n$ yarn add express\n$ touch index.js\n$ touch now.json</code></pre>\n<h2>アプリケーションを作る</h2>\n<p>index.js に次のように記入</p>\n<div class=\"remark-code-title\">index.js</div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">`use strict`</span>\n\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\n<span class=\"hljs-keyword\">const</span> app = express();\n\napp.get(<span class=\"hljs-string\">'/*'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req,res</span>) =></span> {\n  res.send(<span class=\"hljs-string\">'hello, world!'</span>);\n  res.end();\n})\n\n<span class=\"hljs-keyword\">const</span> port = process.env.PORT || <span class=\"hljs-number\">3000</span>;\n<span class=\"hljs-comment\">// ポート番号は上記のように環境変数から読み込むこと</span>\napp.listen(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\">() =></span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`listening on port <span class=\"hljs-subst\">${port}</span>`</span>));</code></pre>\n<h2>now の設定</h2>\n<p>事前に、node.js のアプリケーションであることを指定しなければならない。</p>\n<p>何もしないと静的ホスティングと判断され、アプリケーションのソースコードを写した Web ページがデプロイされる。</p>\n<p>now.json に次のように記入</p>\n<div class=\"remark-code-title\">now.json</div>\n<pre><code class=\"hljs language-json\">{\n    <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">\"builds\"</span>: [{ <span class=\"hljs-attr\">\"src\"</span>: <span class=\"hljs-string\">\"index.js\"</span>, <span class=\"hljs-attr\">\"use\"</span>: <span class=\"hljs-string\">\"@now/node\"</span> }],\n    <span class=\"hljs-attr\">\"routes\"</span>: [{ <span class=\"hljs-attr\">\"src\"</span>: <span class=\"hljs-string\">\"(.*)\"</span>, <span class=\"hljs-attr\">\"dest\"</span>: <span class=\"hljs-string\">\"index.js\"</span> }]\n}</code></pre>\n<h2>npm scriptの設定</h2>\n<p>now が実行時に index.js を実行してくれるように、package.json に次の項目を追加</p>\n<div class=\"remark-code-title\">package.json</div>\n<pre><code class=\"hljs language-json\">{\n <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-string\">\"node index.js\"</span>\n  }\n}</code></pre>\n<h2>デプロイ</h2>\n<pre><code class=\"hljs language-sh\">$ now\n<span class=\"hljs-comment\"># 対話にしたがってメールを入れると、ログインリンクのついたメールが届くので、クリックして認証。</span></code></pre>\n<h2>独自ドメイン(サブドメイン)を登録</h2>\n<p>以下、現在<code>hogehoge-hogehoge.now.sh</code>で公開されていて、<code>hogehoge.example.com</code>でアクセスできるようにするときの設定。</p>\n<p>まずは親のドメインをzeitに登録する</p>\n<pre><code class=\"hljs language-sh\">$ now domains add example.com</code></pre>\n<p>ドメインの所有者認証を行う</p>\n<pre><code class=\"hljs language-sh\">$ now domains verify example.com</code></pre>\n<p>すると、DNSに何も設定していないので失敗する。\nどう設定すべきか表示されるので 画面に表示される通り、DNSに登録する。\nついでに先にお目当てのサブドメインの CNAME も登録しておく。</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>type</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_now</td>\n<td>TXT</td>\n<td>表示されたキー</td>\n</tr>\n<tr>\n<td>hogehoge</td>\n<td>CNAME</td>\n<td>alias.zeit.co</td>\n</tr>\n</tbody>\n</table>\n<p>再度ドメインの所有者認証を行う</p>\n<pre><code class=\"hljs language-sh\">$ now domains verify example.com</code></pre>\n<p>サブドメインのエイリアスを設定する</p>\n<pre><code class=\"hljs language-sh\">$ now <span class=\"hljs-built_in\">alias</span> https://hogehoge-hogehoge.now.sh hogehoge.example.com</code></pre>\n<h2>おわりに</h2>\n<p>以上の手順と同様の作業で公開したリポジトリ: <a href=\"https://github.com/yammerjp/blog.yammer.fun\">blog.yammer.fun - GitHub yammerjp</a></p>\n<p>古いブログのURLをリダイレクトさせるために使った。</p>\n","content_text":"now という PaaS がある。\n\nNode.js で書かれたアプリケーションを、無料で3つまでホスティングできるらしい。\n\nheroku を無料プランで使うと、dyno の立ち上げに30秒くらいかかるので、Web サーバとしては致命的に遅い。\n一方 zeit はそのような待ち時間は発生しない。(どこかに、AWS Lambda を中で使っていると書いてあった気がする)\n\n今回はシンプルな express.js のアプリケーションを now でホスティングする手順。\n\nインストール\n\n\n\nアプリケーションを作る\n\nindex.js に次のように記入\n\n\n\nnow の設定\n\n事前に、node.js のアプリケーションであることを指定しなければならない。\n\n何もしないと静的ホスティングと判断され、アプリケーションのソースコードを写した Web ページがデプロイされる。\n\nnow\\.json に次のように記入\n\n\n\nnpm scriptの設定\n\nnow が実行時に index.js を実行してくれるように、package.json に次の項目を追加\n\n\n\nデプロイ\n\n\n\n独自ドメイン(サブドメイン)を登録\n\n以下、現在hogehoge-hogehoge.now\\.shで公開されていて、hogehoge.example.comでアクセスできるようにするときの設定。\n\nまずは親のドメインをzeitに登録する\n\n\n\nドメインの所有者認証を行う\n\n\n\nすると、DNSに何も設定していないので失敗する。\nどう設定すべきか表示されるので 画面に表示される通り、DNSに登録する。\nついでに先にお目当てのサブドメインの CNAME も登録しておく。\n\n\n\n再度ドメインの所有者認証を行う\n\n\n\nサブドメインのエイリアスを設定する\n\n\n\nおわりに\n\n以上の手順と同様の作業で公開したリポジトリ: blog.yammer.fun - GitHub yammerjp\n\n古いブログのURLをリダイレクトさせるために使った。\n"},{"id":"http://localhost:3000/posts/tcp-udp","url":"http://localhost:3000/posts/tcp-udp","title":"TCP と UDP","summary":"今日のインターネットの根幹をなすTCP/IPプロトコルスタックのうち、トランスポート層のプロトコルであるTCPとUDPについての基本的な知識を説明する。 本記事は研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけの第2回。 前回はTCP/IPプロトコルスタック全体についての概要を書いた。 参考文献: マスタリングTCP/IP入門編 第6章 pp219-246 もくじ トランスポートプロトコルの役割 ポート番号 TCP と UDP TCP の様々な制御 トランスポートプロトコルの役割 トランスポート層の役割は主に3つある。 End-to-End の通信を実現すること。 アプ","date_published":"2020-05-30T14:05:53+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:TCP%20%E3%81%A8%20UDP,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ec5c34483884aa723d1da20ac0029cf4a2c61468","comment":"注釈表記をMarkdown記法に修正\n","date_modified":"2021-04-29T20:08:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>今日のインターネットの根幹をなすTCP/IPプロトコルスタックのうち、トランスポート層のプロトコルであるTCPとUDPについての基本的な知識を説明する。</p>\n<p>本記事は研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけの第2回。\n<a href=\"/posts/internet-tcpip/\">前回</a>はTCP/IPプロトコルスタック全体についての概要を書いた。</p>\n<ul>\n<li>参考文献: マスタリングTCP/IP入門編 第6章 pp219-246</li>\n</ul>\n<h2>もくじ</h2>\n<ul>\n<li>トランスポートプロトコルの役割</li>\n<li>ポート番号</li>\n<li>TCP と UDP</li>\n<li>TCP の様々な制御</li>\n</ul>\n<h2>トランスポートプロトコルの役割</h2>\n<p>トランスポート層の役割は主に3つある。</p>\n<ol>\n<li>End-to-End の通信を実現すること。</li>\n<li>アプリケーションプログラム間での通信を可能にすること</li>\n<li>(TCP では) 信頼性のある通信を実現すること</li>\n</ol>\n<p>これらの役割を、他層との関係とともに説明する。\n参考として、TCP/IPプロトコルの階層モデルを示す。</p>\n<p><img src=\"https://blob.yammer.jp/tcp-udp-tcpip-protocol-stack.png\" alt=\"OSI参照モデルとTCP/IP階層モデル\"></p>\n<h3>1. End-to-End の通信を実現すること。</h3>\n<p>トランスポート層は、End-to-End の通信を実現する。</p>\n<p>トランスポート層の下位に位置するインターネット層では、IP を中心に hop-by-hopでパケットをバケツリレーのように渡し続けながら通信する。</p>\n<p>トランスポート層はこれを隠して、ユーザが中継のルータなどを意識せず済むよう、 End-to-End で通信しているようにみせる。</p>\n<h3>2. アプリケーションプログラム間での通信を可能にすること</h3>\n<p>通信ホストは、複数のアプリケーションを用いて同時に異なる通信する。</p>\n<p>トランスポート層ではポート番号という識別子を用いて、アプリケーション (実際にはプロセス) ごとに通信を識別し、各アプリケーションが他のアプリケーションの通信を意識せずに使えるようにする。</p>\n<h3>3. (TCP では) 信頼性のある通信を実現すること</h3>\n<p>TCP を用いると、パケットを再送することをはじめとして様々な制御を行ってくれる。\nこれによって上位のアプリケーション層からは、特に意識せずとも信頼性のある通信を行える。</p>\n<h2>ポート番号</h2>\n<p>端末内で通信するプロセスを指定するために用いられる識別子。\nIP アドレスと合わせて使われる。</p>\n<p>ポート番号を含む次の5つが全て揃うことで通信を識別する。</p>\n<ul>\n<li>宛先 IP アドレス</li>\n<li>送信元 IP アドレス</li>\n<li>宛先ポート番号</li>\n<li>送信元ポート番号</li>\n<li>トランスポートプロトコルの種類 (IP ヘッダのプロトコル番号フィールド)</li>\n</ul>\n<h3>ポート番号の通信例</h3>\n<p>例えば、私の PC で、次の2つのWebページを同時に閲覧することを考える。</p>\n<ul>\n<li>埼玉大学の受験生向け Web ページ (<a href=\"http://www.saitama-u.ac.jp/entrance\">http://www.saitama-u.ac.jp/entrance</a>)</li>\n<li>埼玉大学の在校生向け Web ページ (<a href=\"http://www.saitama-u.ac.jp/student\">http://www.saitama-u.ac.jp/student</a>)</li>\n</ul>\n<p>このとき、私の PC から、埼玉大学の Web サーバへ通信が発生する。つまり同じ送信元から同じ宛先へ別々の通信が発生する。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">ページ</th>\n<th align=\"center\">宛先IPアドレス</th>\n<th align=\"center\">宛先ポート番号</th>\n<th align=\"center\">送信元IPアドレス</th>\n<th align=\"center\">送信元ポート番号</th>\n<th align=\"center\">プロトコル</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">A</td>\n<td align=\"center\">153.127.197.67</td>\n<td align=\"center\">80</td>\n<td align=\"center\">203.0.113.1</td>\n<td align=\"center\">49152</td>\n<td align=\"center\">TCP</td>\n</tr>\n<tr>\n<td align=\"center\">B</td>\n<td align=\"center\">153.127.197.67</td>\n<td align=\"center\">80</td>\n<td align=\"center\">203.0.113.1</td>\n<td align=\"center\">49153</td>\n<td align=\"center\">TCP</td>\n</tr>\n</tbody>\n</table>\n<p>ページを開く要求をしたときに、ブラウザのタブごとに(=プロセスごとに)違うポート番号を使えば、別々の通信を識別できるというわけだ。\n(実際には、送信元に帰ってきたパケットがどのプロセス宛のものであるかを、OS がポート番号で識別し、プロセスに処理が渡る。)</p>\n<h3>ポート番号の割当</h3>\n<h3>(0-1023) Well-known Port Number</h3>\n<p>ポート番号には事前に予約された Well-known Port Number というものがある。</p>\n<p>上位レイヤーのプロトコルのうち一般的なものが使うポート番号を 0-1023 番に定めている。\n例えば HTTP は 80 番, HTTPS は 443 番, SSH は 22 番, 等。</p>\n<p>Well-known Port Number を他の用途に用いることもできるが、混乱を避けるために避けるのが無難。</p>\n<p>参考: <a href=\"https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml\">Well-known Port Number の割当 - IANA</a></p>\n<h3>(1024-49151) その他の登録済みポート番号</h3>\n<p>Well-known Port Number 以外にも登録されたポート番号がある。\nただしこちらは他の用途に使ってもそれほど問題が起きにくい。</p>\n<h3>(49152-65535) 動的割当のポート番号</h3>\n<p>前節では用途が決まったポート番号であった。\nこれらは一般に、サーバ側のポート番号として使われる。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>\n何故なら、クライアント側からどのポートに繋げば良いのか事前に知っている必要があるからだ。\n例えば Web ページを見るときはふつう、Web サーバは 80 番 (HTTP) か 443 番 (HTTPS) で待ち受けていることを前提に通信を開始する。</p>\n<p>一方クライアントは特にポート番号が定まっている必要はない。\n特に値が重要でない場合は、ポート番号の管理を OS に委ねることができる。\nこのような動的な割当は 49152-65535 の範囲で割り当てられるのが一般的だ。</p>\n<h2>TCP と UDP</h2>\n<p>トランスポートプロトコルの代表的な２つのプロトコル、TCP と UDP の違いについて説明する。</p>\n<h3>TCP (Transmission Control Protocol)</h3>\n<p>TCPは次のような特徴を持つ</p>\n<ul>\n<li>伝送、送信、通信を制御する</li>\n<li>コネクション型<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></li>\n<li>信頼性のある通信をするために様々な制御を含む含む</li>\n</ul>\n<p>TCPを使うと、アプリケーションは様々な制御から開放される。\nただしコネクションの確立/切断にコストがかかる。\nよって、信頼性を要求し大容量のデータを交換する多くの通信に向くが、全ての通信に適しているわけではない。</p>\n<h3>UDP (User Datagram Protocol)</h3>\n<p>UDP は次のような特徴を持つ</p>\n<ul>\n<li>複雑な制御をしない</li>\n<li>コネクションレス型</li>\n<li>いつでもデータを送信可能</li>\n<li>高速に動作する</li>\n</ul>\n<p>同報性が要求されたり、アプリケーションが細かい制御を行う通信はUDPで行うのが好ましい。\n次のような用途に用いられている。</p>\n<ul>\n<li>総パケット数の少ない通信。 (DNS, SNMP)</li>\n<li>動画や音声などのマルチメディア通信 (即時性を求める通信)</li>\n<li>ブロードキャストやマルチキャストの通信。 (1対Nの通信)</li>\n</ul>\n<h2>TCP の様々な機能</h2>\n<p>TCP には信頼性を保証するために次のような機能を持つ。</p>\n<ul>\n<li>コネクションの管理 ... (通信相手がいるかどうかの確認)</li>\n<li>再送制御 ... (パケットが喪失した際に必要)</li>\n<li>重複制御 ... (パケットが2十二届いた際に必要)</li>\n<li>順序制御 ... (パケットの順序が入れ替わった際に必要)</li>\n<li>フロー制御 ... (受信能力に合わせた送信を行う)</li>\n<li>輻輳 (ふくそう) 制御 ... (ネットワークの混雑を避ける)</li>\n</ul>\n<p>これらの実現のために必要な仕組みとして、次のような技術を説明する</p>\n<ul>\n<li>コネクションの確立/切断</li>\n<li>確認応答</li>\n<li>シーケンス番号 (再送制御, 重複制御, 順序制御に用いられる)</li>\n<li>ウィンドウ (ネットワークの効率を高め, フロー制御や輻輳制御にも用いられる概念)</li>\n</ul>\n<h3>コネクションの確立/切断</h3>\n<h3>確認応答</h3>\n<h3>シーケンス番号</h3>\n<h3>ウィンドウ</h3>\n<h2>まとめ</h2>\n<p>トランスポートプロトコルの役割は次の3つであった。</p>\n<ol>\n<li>End-to-End の通信を実現すること。</li>\n<li>アプリケーションプログラム間での通信を可能にすること</li>\n<li>(TCP では) 信頼性のある通信を実現すること</li>\n</ol>\n<p>2を実現するためにポート番号があり、3を実現するために様々な制御があることを紹介した。</p>\n<p>以上。</p>\n<hr>\n<p>追記: (2020/10/04) 前回記事へのリンクを相対リンクへ修正</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">TCP/IP ではクライアント-サーバモデルの通信が多い。<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">コネクションとは、二者間で専用して使用できる仮想的な回線のこと。<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n","content_text":"今日のインターネットの根幹をなすTCP/IPプロトコルスタックのうち、トランスポート層のプロトコルであるTCPとUDPについての基本的な知識を説明する。\n\n本記事は研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけの第2回。\n前回はTCP/IPプロトコルスタック全体についての概要を書いた。\n\n参考文献: マスタリングTCP/IP入門編 第6章 pp219-246\n\nもくじ\n\nトランスポートプロトコルの役割\n\nポート番号\n\nTCP と UDP\n\nTCP の様々な制御\n\nトランスポートプロトコルの役割\n\nトランスポート層の役割は主に3つある。\n\nEnd-to-End の通信を実現すること。\n\nアプリケーションプログラム間での通信を可能にすること\n\n(TCP では) 信頼性のある通信を実現すること\n\nこれらの役割を、他層との関係とともに説明する。\n参考として、TCP/IPプロトコルの階層モデルを示す。\n\nOSI参照モデルとTCP/IP階層モデル\n\n1\\. End-to-End の通信を実現すること。\n\nトランスポート層は、End-to-End の通信を実現する。\n\nトランスポート層の下位に位置するインターネット層では、IP を中心に hop-by-hopでパケットをバケツリレーのように渡し続けながら通信する。\n\nトランスポート層はこれを隠して、ユーザが中継のルータなどを意識せず済むよう、 End-to-End で通信しているようにみせる。\n\n2\\. アプリケーションプログラム間での通信を可能にすること\n\n通信ホストは、複数のアプリケーションを用いて同時に異なる通信する。\n\nトランスポート層ではポート番号という識別子を用いて、アプリケーション (実際にはプロセス) ごとに通信を識別し、各アプリケーションが他のアプリケーションの通信を意識せずに使えるようにする。\n\n3\\. (TCP では) 信頼性のある通信を実現すること\n\nTCP を用いると、パケットを再送することをはじめとして様々な制御を行ってくれる。\nこれによって上位のアプリケーション層からは、特に意識せずとも信頼性のある通信を行える。\n\nポート番号\n\n端末内で通信するプロセスを指定するために用いられる識別子。\nIP アドレスと合わせて使われる。\n\nポート番号を含む次の5つが全て揃うことで通信を識別する。\n\n宛先 IP アドレス\n\n送信元 IP アドレス\n\n宛先ポート番号\n\n送信元ポート番号\n\nトランスポートプロトコルの種類 (IP ヘッダのプロトコル番号フィールド)\n\nポート番号の通信例\n\n例えば、私の PC で、次の2つのWebページを同時に閲覧することを考える。\n\n埼玉大学の受験生向け Web ページ (http\\://www\\.saitama-u.ac.jp/entrance)\n\n埼玉大学の在校生向け Web ページ (http\\://www\\.saitama-u.ac.jp/student)\n\nこのとき、私の PC から、埼玉大学の Web サーバへ通信が発生する。つまり同じ送信元から同じ宛先へ別々の通信が発生する。\n\n\n\nページを開く要求をしたときに、ブラウザのタブごとに(=プロセスごとに)違うポート番号を使えば、別々の通信を識別できるというわけだ。\n(実際には、送信元に帰ってきたパケットがどのプロセス宛のものであるかを、OS がポート番号で識別し、プロセスに処理が渡る。)\n\nポート番号の割当\n\n(0-1023) Well-known Port Number\n\nポート番号には事前に予約された Well-known Port Number というものがある。\n\n上位レイヤーのプロトコルのうち一般的なものが使うポート番号を 0-1023 番に定めている。\n例えば HTTP は 80 番, HTTPS は 443 番, SSH は 22 番, 等。\n\nWell-known Port Number を他の用途に用いることもできるが、混乱を避けるために避けるのが無難。\n\n参考: Well-known Port Number の割当 - IANA\n\n(1024-49151) その他の登録済みポート番号\n\nWell-known Port Number 以外にも登録されたポート番号がある。\nただしこちらは他の用途に使ってもそれほど問題が起きにくい。\n\n(49152-65535) 動的割当のポート番号\n\n前節では用途が決まったポート番号であった。\nこれらは一般に、サーバ側のポート番号として使われる。[^1]\n何故なら、クライアント側からどのポートに繋げば良いのか事前に知っている必要があるからだ。\n例えば Web ページを見るときはふつう、Web サーバは 80 番 (HTTP) か 443 番 (HTTPS) で待ち受けていることを前提に通信を開始する。\n\n一方クライアントは特にポート番号が定まっている必要はない。\n特に値が重要でない場合は、ポート番号の管理を OS に委ねることができる。\nこのような動的な割当は 49152-65535 の範囲で割り当てられるのが一般的だ。\n\nTCP と UDP\n\nトランスポートプロトコルの代表的な２つのプロトコル、TCP と UDP の違いについて説明する。\n\nTCP (Transmission Control Protocol)\n\nTCPは次のような特徴を持つ\n\n伝送、送信、通信を制御する\n\nコネクション型[^2]\n\n信頼性のある通信をするために様々な制御を含む含む\n\nTCPを使うと、アプリケーションは様々な制御から開放される。\nただしコネクションの確立/切断にコストがかかる。\nよって、信頼性を要求し大容量のデータを交換する多くの通信に向くが、全ての通信に適しているわけではない。\n\nUDP (User Datagram Protocol)\n\nUDP は次のような特徴を持つ\n\n複雑な制御をしない\n\nコネクションレス型\n\nいつでもデータを送信可能\n\n高速に動作する\n\n同報性が要求されたり、アプリケーションが細かい制御を行う通信はUDPで行うのが好ましい。\n次のような用途に用いられている。\n\n総パケット数の少ない通信。 (DNS, SNMP)\n\n動画や音声などのマルチメディア通信 (即時性を求める通信)\n\nブロードキャストやマルチキャストの通信。 (1対Nの通信)\n\nTCP の様々な機能\n\nTCP には信頼性を保証するために次のような機能を持つ。\n\nコネクションの管理 ... (通信相手がいるかどうかの確認)\n\n再送制御 ... (パケットが喪失した際に必要)\n\n重複制御 ... (パケットが2十二届いた際に必要)\n\n順序制御 ... (パケットの順序が入れ替わった際に必要)\n\nフロー制御 ... (受信能力に合わせた送信を行う)\n\n輻輳 (ふくそう) 制御 ... (ネットワークの混雑を避ける)\n\nこれらの実現のために必要な仕組みとして、次のような技術を説明する\n\nコネクションの確立/切断\n\n確認応答\n\nシーケンス番号 (再送制御, 重複制御, 順序制御に用いられる)\n\nウィンドウ (ネットワークの効率を高め, フロー制御や輻輳制御にも用いられる概念)\n\nコネクションの確立/切断\n\n確認応答\n\nシーケンス番号\n\nウィンドウ\n\nまとめ\n\nトランスポートプロトコルの役割は次の3つであった。\n\nEnd-to-End の通信を実現すること。\n\nアプリケーションプログラム間での通信を可能にすること\n\n(TCP では) 信頼性のある通信を実現すること\n\n2を実現するためにポート番号があり、3を実現するために様々な制御があることを紹介した。\n\n以上。\n\n\n\n追記: (2020/10/04) 前回記事へのリンクを相対リンクへ修正\n\n[^1]: TCP/IP ではクライアント-サーバモデルの通信が多い。\n\n[^2]: コネクションとは、二者間で専用して使用できる仮想的な回線のこと。\n"},{"id":"http://localhost:3000/posts/linux-cpu","url":"http://localhost:3000/posts/linux-cpu","title":"デスクトップLinuxでCPUの状況を確認する","summary":" 参考: CPU and Linux -  Youtube Satoru Takeuchi ","date_published":"2020-05-30T11:46:49+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%87%E3%82%B9%E3%82%AF%E3%83%88%E3%83%83%E3%83%97Linux%E3%81%A7CPU%E3%81%AE%E7%8A%B6%E6%B3%81%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":[],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/69660f2f624b84347d6101b0e88324e028de9b57","comment":"Add a post\n","date_modified":"2020-05-30T11:55:30+09:00"}],"content_html":"<pre><code class=\"hljs language-sh\">$ cat /proc/cpuinfo\n<span class=\"hljs-comment\"># CPUの各スレッドごとの情報を含んだファイルを表示する</span>\n\n$ nproc\n<span class=\"hljs-comment\"># CPUのスレッド数(プロセッサの数)を表示する</span>\n\n$ top\n<span class=\"hljs-comment\"># CPU使用率の高い順にプロセスを表示する。定期的に内容は再描画される。</span></code></pre>\n<p>参考: <a href=\"https://youtu.be/etZrDmrD5Q0\">CPU and Linux -  Youtube Satoru Takeuchi</a></p>\n","content_text":"\n\n参考: CPU and Linux -  Youtube Satoru Takeuchi\n"},{"id":"http://localhost:3000/posts/willani-start","url":"http://localhost:3000/posts/willani-start","title":"数日前からCコンパイラを書き始めた。","summary":"数日前からCコンパイラを書き始めた。(GitHub) 植山類さんのオンラインブック、低レイヤを知りたい人のためのCコンパイラ作成入門を読みながら、概ね本の内容に沿って進めている。 自分の書いたコンパイラで自身をコンパイルするセルフホストを目指している。 コンパイラというのはある言語で書かれたプログラムを別の言語に変換するプログラムだ。 ここではC言語をアセンブリに変換するものを指している。 いきなりC言語をコンパイルするのは無理なので、徐々に複雑な入力を受け付けるように改良し、最終的にC言語を受け付けるようにする(したい)。 最初は入力をそのまま出力することから始まり、四則演算ができるようにな","date_published":"2020-05-25T01:02:52+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E6%95%B0%E6%97%A5%E5%89%8D%E3%81%8B%E3%82%89C%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%82%92%E6%9B%B8%E3%81%8D%E5%A7%8B%E3%82%81%E3%81%9F%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["コンパイラ","willani","日記","C"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/f679d95e0a14c5bb1160f7b87d809798b8b9fc07","comment":"Add a post of willani\n","date_modified":"2020-05-25T01:17:32+09:00"}],"content_html":"<p>数日前からCコンパイラを書き始めた。(<a href=\"https://github.com/yammerjp/willani\">GitHub</a>)</p>\n<p>植山類さんのオンラインブック、<a href=\"https://www.sigbus.info/compilerbook\">低レイヤを知りたい人のためのCコンパイラ作成入門</a>を読みながら、概ね本の内容に沿って進めている。\n自分の書いたコンパイラで自身をコンパイルするセルフホストを目指している。</p>\n<p>コンパイラというのはある言語で書かれたプログラムを別の言語に変換するプログラムだ。\nここではC言語をアセンブリに変換するものを指している。<br>\nいきなりC言語をコンパイルするのは無理なので、徐々に複雑な入力を受け付けるように改良し、最終的にC言語を受け付けるようにする(したい)。\n最初は入力をそのまま出力することから始まり、四則演算ができるようになり、いまは関数呼び出しができるようになった。</p>\n<p>本はとても丁寧に書かれていて、参考として実装も2種類ほど存在する。\nさらにSlackやYoutube Liveで質問ができるというとても恵まれた環境が揃っている。</p>\n<p>実は昨年コンパイラの授業をとっていてコンパイラを少し触っていた。\ncmmというCを一部切り取ったような言語と、PL0iという仮想マシン(とそのアセンブリ)に対して言語拡張をする、というようなことだった。\nそのときはあまり真面目に実装に凝っていなくて、課題はパスして成績がそこそこもらえるくらいはやったが、実のところコンパイラってよくわからないなという気持ちのまま終わっていた。</p>\n<p>このままではよくないという気持ちと、あとは単純な興味(プログラムをデータとして扱うことを体験できる)もあって始めてみた。</p>\n<br/>\n<p>はじめてまだ3日ほどだが、パーサについてがちょっと意外だった。\n手書きでパーサを書くというのは事前に聞いていたが、LL(1)でいけるらしい。</p>\n<p>LL(1)とは構文解析法のこと、つまり、文法がどんな構造になっているかを調べる手法の一つだ。\n構文解析は事前にBNF記法などで規則が与えられており、その規則のどれが適用できるかを探す。\n授業でLR(0), LR(1), LALR(1)などを扱ったが、LL(1)はそれらよりも単純で手書きでパーサを書くのに向いているらしい。</p>\n<p>どうも最近のコンパイラ(gccやclang)はLL1らしい。\n大学の授業では、「LALR1じゃないとまともにパースできない(世の中的には主流)(最近は違う場合もある)」といっていた気がして、それにしたがってLALR1の文法解析などをやった記憶があるのだが。(違ったらごめんなさい先生。)</p>\n<p>なんだったんだあの勉強はという気持ちに少しなったが、教科書的にはああいうものなのだろう。\n授業ではLL1をばっさり飛ばしたのでそんなに深追いしてなかったが、やってみればなるほどという感じ。</p>\n<p>LALR1パーサジェネレータを書くなら当時の記憶を掘り返して結構頑張らないときつそうだけど、LL1で書くのは意外といけるものだ。</p>\n<br/>\n<p>そんなわけでトークナイザ(レキシカルアナライザと同義?)とパーサは結構スイスイ進む。\nやることが見えているしデバッグ用にログを出せば何が起きているか目に見えてわかる。</p>\n<p>そこまではいいのだけど、肝心のコード生成がちょっと大変。</p>\n<p>アセンブリへの理解が浅い私である。\nアセンブリを読むのは少しつらいなぁ、この量でこんなこと言ってたらこの先どうなることやらと思いながらデバッグしている。\n今後アセンブリがすらすら読めるようになることを夢見て続けていきたい。</p>\n<br/>\n<p>C言語でそれなりのものを書くというのも実はいままであまりやってこなかったので、今回は絶好の機会だ。\nいつまで飽きずにやれるかな。</p>\n","content_text":"数日前からCコンパイラを書き始めた。(GitHub)\n\n植山類さんのオンラインブック、低レイヤを知りたい人のためのCコンパイラ作成入門を読みながら、概ね本の内容に沿って進めている。\n自分の書いたコンパイラで自身をコンパイルするセルフホストを目指している。\n\nコンパイラというのはある言語で書かれたプログラムを別の言語に変換するプログラムだ。\nここではC言語をアセンブリに変換するものを指している。\nいきなりC言語をコンパイルするのは無理なので、徐々に複雑な入力を受け付けるように改良し、最終的にC言語を受け付けるようにする(したい)。\n最初は入力をそのまま出力することから始まり、四則演算ができるようになり、いまは関数呼び出しができるようになった。\n\n本はとても丁寧に書かれていて、参考として実装も2種類ほど存在する。\nさらにSlackやYoutube Liveで質問ができるというとても恵まれた環境が揃っている。\n\n実は昨年コンパイラの授業をとっていてコンパイラを少し触っていた。\ncmmというCを一部切り取ったような言語と、PL0iという仮想マシン(とそのアセンブリ)に対して言語拡張をする、というようなことだった。\nそのときはあまり真面目に実装に凝っていなくて、課題はパスして成績がそこそこもらえるくらいはやったが、実のところコンパイラってよくわからないなという気持ちのまま終わっていた。\n\nこのままではよくないという気持ちと、あとは単純な興味(プログラムをデータとして扱うことを体験できる)もあって始めてみた。\n\n\n\nはじめてまだ3日ほどだが、パーサについてがちょっと意外だった。\n手書きでパーサを書くというのは事前に聞いていたが、LL(1)でいけるらしい。\n\nLL(1)とは構文解析法のこと、つまり、文法がどんな構造になっているかを調べる手法の一つだ。\n構文解析は事前にBNF記法などで規則が与えられており、その規則のどれが適用できるかを探す。\n授業でLR(0), LR(1), LALR(1)などを扱ったが、LL(1)はそれらよりも単純で手書きでパーサを書くのに向いているらしい。\n\nどうも最近のコンパイラ(gccやclang)はLL1らしい。\n大学の授業では、「LALR1じゃないとまともにパースできない(世の中的には主流)(最近は違う場合もある)」といっていた気がして、それにしたがってLALR1の文法解析などをやった記憶があるのだが。(違ったらごめんなさい先生。)\n\nなんだったんだあの勉強はという気持ちに少しなったが、教科書的にはああいうものなのだろう。\n授業ではLL1をばっさり飛ばしたのでそんなに深追いしてなかったが、やってみればなるほどという感じ。\n\nLALR1パーサジェネレータを書くなら当時の記憶を掘り返して結構頑張らないときつそうだけど、LL1で書くのは意外といけるものだ。\n\n\n\nそんなわけでトークナイザ(レキシカルアナライザと同義?)とパーサは結構スイスイ進む。\nやることが見えているしデバッグ用にログを出せば何が起きているか目に見えてわかる。\n\nそこまではいいのだけど、肝心のコード生成がちょっと大変。\n\nアセンブリへの理解が浅い私である。\nアセンブリを読むのは少しつらいなぁ、この量でこんなこと言ってたらこの先どうなることやらと思いながらデバッグしている。\n今後アセンブリがすらすら読めるようになることを夢見て続けていきたい。\n\n\n\nC言語でそれなりのものを書くというのも実はいままであまりやってこなかったので、今回は絶好の機会だ。\nいつまで飽きずにやれるかな。\n"},{"id":"http://localhost:3000/posts/npm-publish","url":"http://localhost:3000/posts/npm-publish","title":"npm publishの手順","summary":"npm (Node Package Manager) とは、Node.js におけるパッケージ管理ツールである。 npm が GitHub に買収されたり、deno が正式リリースされたりしているこのご時世であるが、初めて npm にパッケージを公開したので手順と注意点を振り返る。 ちなみ公開したのは、はてなブログ記事管理ツールの gimonfu。 全体の流れ $ npm publishする作業をよしなにしてくれる CLI ツール np などもあるようだ。 今回は必要な作業を知る意味を込めて手動で行った。 私がやったのは以下の通り。細かくはこれから述べる。 npm に登録する 内容を確認する ","date_published":"2020-05-21T15:40:14+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:npm%20publish%E3%81%AE%E6%89%8B%E9%A0%86,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","npm"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/698524967ae01574a8037c627a8b083e253a04f2","comment":"Fix internal links\n","date_modified":"2020-10-04T22:43:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/fc1f49fea5c87dd342d2e9476f375ebcb013744e","comment":"Delete <br/>\n","date_modified":"2020-10-04T20:49:44+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c98a8021a6c4a742909019a4bdd11c9c218ac368","comment":"Fix format\n","date_modified":"2020-05-21T16:45:32+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/59fe26840e3c05e09dc2d8e6998116059dbb2ee4","comment":"Add a post npm-publish.md\n","date_modified":"2020-05-21T16:05:40+09:00"}],"content_html":"<p>npm (Node Package Manager) とは、Node.js におけるパッケージ管理ツールである。</p>\n<p>npm が GitHub に買収されたり、deno が正式リリースされたりしているこのご時世であるが、初めて npm にパッケージを公開したので手順と注意点を振り返る。</p>\n<p>ちなみ公開したのは、はてなブログ記事管理ツールの <a href=\"https://www.npmjs.com/package/gimonfu\">gimonfu</a>。</p>\n<h2>全体の流れ</h2>\n<p><code>$ npm publish</code>する作業をよしなにしてくれる CLI ツール <a href=\"https://www.npmjs.com/package/np\">np</a> などもあるようだ。\n今回は必要な作業を知る意味を込めて手動で行った。</p>\n<p>私がやったのは以下の通り。細かくはこれから述べる。</p>\n<ol>\n<li>npm に登録する</li>\n<li>内容を確認する</li>\n<li>package.json の version を上げる</li>\n<li><code>$ npm publish</code></li>\n<li>GitHub の Web ページ上で Release を書く</li>\n</ol>\n<h2>npmに登録する</h2>\n<ol>\n<li>npm に登録する (<a href=\"https://www.npmjs.com/signup\">https://www.npmjs.com/signup</a>)</li>\n<li>npm にログインする(<code>$ npm login</code>)</li>\n<li>npm にログインしたことを確認する(<code>$ npm whoami</code>)</li>\n</ol>\n<h2>package.json を振り返る</h2>\n<p>package.json の内容に不備がないか、各項目を確認していく。</p>\n<p>一通り確認し終えたら <a href=\"https://www.npmjs.com/package/fixpack\">fixpack</a> を使って、抜けがないかチェックする。</p>\n<p>version については <a href=\"https://docs.npmjs.com/about-semantic-versioning\">semantic versioning</a> に従う。\n要するに <code>0.0.1</code> や <code>1.0.2</code> といった形式だ。\n<code>$ npm version</code>でも上げることができるらしい。</p>\n<p>( files キーについては次に述べる。)</p>\n<h2>配布するファイルを確認する</h2>\n<p>配布するファイルは次の項目で決まる。</p>\n<h3>package.json 内の files キー</h3>\n<p>文字列の配列を渡すと、ファイルやディレクトリを配布ファイルに含める。\nホワイトリスト形式。</p>\n<p>今回は次のように指定した。\nTypeScriptでCLIツールを作るなら同じように指定できるのではないだろうか。</p>\n<p>なお <a href=\"https://docs.npmjs.com/files/package.json#files\">package.json などは自動で含めてくれる</a>ようなので指定しなくてよい。</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"files\"</span>: [\n    <span class=\"hljs-string\">\"dist\"</span>,\n    <span class=\"hljs-string\">\"bin\"</span>\n  ],\n}</code></pre>\n<h3>.npmignore</h3>\n<p>.gitignore と同じフォーマットで、ファイルやディレクトリを配布ファイルから除外する。\nブラックリスト形式。</p>\n<p><a href=\"http://npm.github.io/publishing-pkgs-docs/publishing/the-npmignore-file.html\">npmのドキュメント</a>を読むと、.npmignore だけではなく .gitignore も読み込んで除外してくれそうな感じだ。</p>\n<p>今回は package.json#files で指定したので使わなかった。</p>\n<br/>\n<p>配布するファイルは、特にTypeScriptのとき注意する必要がある。dist ディレクトリだ。</p>\n<p>npm での配布コンパイル結果を含む必要がある。\nしかし git ではコンパイル結果をリポジトリに含めないのが普通だ。\n何も設定しないと .gitignore を解釈して dist ディレクトリは配布対象外となってしまう。</p>\n<p>これを避けるためには、package.json#files で指定してあげる必要がある。</p>\n<br/>\n<p>ところで、<code>$npm link</code>を使うと手元のPCでグローバルインストールしたのと同様にpathを通してくれるらしい。</p>\n<p>ただ、シンボリックリンクを貼るだけなので配布するファイルの確認には使えないことに注意。\n配布対象外のファイルもローカルに存在するので動いてしまう。</p>\n<h2>ビルドとテストが通る</h2>\n<p>動かないファイルを公開するわけにはいかない。</p>\n<p>間違えて公開してしまっても<a href=\"https://docs.npmjs.com/cli/unpublish\">72時間以内なら<code>$npm unpublish</code>で取り消せる</a>。</p>\n<p>それ以降はnpmのサポートにメールする必要がある。\nパッケージが簡単に消せてしまうと依存関係に問題が生じるので、削除には慎重なようだ。</p>\n<h2>README.mdを読み直す</h2>\n<p>README.md は npm のページにも表示されるので、改めて間違いがないかを確認する。</p>\n<p>自分は Installation のところを間違えたまま公開してしまった。(現在は修正済み)</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 間違い</span>\n$ npm install --global yammerjp/gimonfu\n\n<span class=\"hljs-comment\"># 正しい</span>\n<span class=\"hljs-comment\"># npm install --global gimonfu</span></code></pre>\n<p>実は npm にパッケージを公開せずとも、install 時に [githubユーザ名]/[githubレポジトリ名] とすると、パッケージをインストールできる。\nもともと README.md にこの方法が記述していた。</p>\n<p>しかし今回はこの記述は間違い。\nGithub リポジトリには TypeScript のコンパイル結果が含まれていないので、インストールできても動かない。</p>\n<p>ちなみに英語の README.md は、DeepL と grammaly の力を借りて適当な GitHub リポジトリの README.md を参考にすることで作っている。\n先人と文明は偉大。</p>\n<h2><code>$ npm publish</code></h2>\n<p>問題ないことが確認できたらいよいよ公開する。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-variable\">$npm</span> publish</code></pre>\n<p>たった一行打つだけ。</p>\n<p>公開したら、GitHub 上でも Release をつくる。</p>\n<h2>おわりに</h2>\n<p>はじめての<code>$ npm publish</code>はなんだか気分が良い。</p>\n<p>npm のパッケージのページでは Download 数が見れるのだが、公開された瞬間に40くらいになっていた。\n謎。\nミラーだったりで自動取得されてるのかな。</p>\n<p>そもそも Download 数ってそんなに正確である必要はないので、40など誤差の範囲内だが。</p>\n<hr>\n<p>追記: (2020/10/04) 不要な改行タグを削除</p>\n","content_text":"npm (Node Package Manager) とは、Node.js におけるパッケージ管理ツールである。\n\nnpm が GitHub に買収されたり、deno が正式リリースされたりしているこのご時世であるが、初めて npm にパッケージを公開したので手順と注意点を振り返る。\n\nちなみ公開したのは、はてなブログ記事管理ツールの gimonfu。\n\n全体の流れ\n\n$ npm publishする作業をよしなにしてくれる CLI ツール np などもあるようだ。\n今回は必要な作業を知る意味を込めて手動で行った。\n\n私がやったのは以下の通り。細かくはこれから述べる。\n\nnpm に登録する\n\n内容を確認する\n\npackage.json の version を上げる\n\n$ npm publish\n\nGitHub の Web ページ上で Release を書く\n\nnpmに登録する\n\nnpm に登録する (https\\://www\\.npmjs.com/signup)\n\nnpm にログインする($ npm login)\n\nnpm にログインしたことを確認する($ npm whoami)\n\npackage.json を振り返る\n\npackage.json の内容に不備がないか、各項目を確認していく。\n\n一通り確認し終えたら fixpack を使って、抜けがないかチェックする。\n\nversion については semantic versioning に従う。\n要するに 0.0.1 や 1.0.2 といった形式だ。\n$ npm versionでも上げることができるらしい。\n\n( files キーについては次に述べる。)\n\n配布するファイルを確認する\n\n配布するファイルは次の項目で決まる。\n\npackage.json 内の files キー\n\n文字列の配列を渡すと、ファイルやディレクトリを配布ファイルに含める。\nホワイトリスト形式。\n\n今回は次のように指定した。\nTypeScriptでCLIツールを作るなら同じように指定できるのではないだろうか。\n\nなお package.json などは自動で含めてくれるようなので指定しなくてよい。\n\n\n\n.npmignore\n\n.gitignore と同じフォーマットで、ファイルやディレクトリを配布ファイルから除外する。\nブラックリスト形式。\n\nnpmのドキュメントを読むと、.npmignore だけではなく .gitignore も読み込んで除外してくれそうな感じだ。\n\n今回は package.json#files で指定したので使わなかった。\n\n\n\n配布するファイルは、特にTypeScriptのとき注意する必要がある。dist ディレクトリだ。\n\nnpm での配布コンパイル結果を含む必要がある。\nしかし git ではコンパイル結果をリポジトリに含めないのが普通だ。\n何も設定しないと .gitignore を解釈して dist ディレクトリは配布対象外となってしまう。\n\nこれを避けるためには、package.json#files で指定してあげる必要がある。\n\n\n\nところで、$npm linkを使うと手元のPCでグローバルインストールしたのと同様にpathを通してくれるらしい。\n\nただ、シンボリックリンクを貼るだけなので配布するファイルの確認には使えないことに注意。\n配布対象外のファイルもローカルに存在するので動いてしまう。\n\nビルドとテストが通る\n\n動かないファイルを公開するわけにはいかない。\n\n間違えて公開してしまっても72時間以内なら$npm unpublishで取り消せる。\n\nそれ以降はnpmのサポートにメールする必要がある。\nパッケージが簡単に消せてしまうと依存関係に問題が生じるので、削除には慎重なようだ。\n\nREADME.mdを読み直す\n\nREADME.md は npm のページにも表示されるので、改めて間違いがないかを確認する。\n\n自分は Installation のところを間違えたまま公開してしまった。(現在は修正済み)\n\n\n\n実は npm にパッケージを公開せずとも、install 時に \\[githubユーザ名]/\\[githubレポジトリ名] とすると、パッケージをインストールできる。\nもともと README.md にこの方法が記述していた。\n\nしかし今回はこの記述は間違い。\nGithub リポジトリには TypeScript のコンパイル結果が含まれていないので、インストールできても動かない。\n\nちなみに英語の README.md は、DeepL と grammaly の力を借りて適当な GitHub リポジトリの README.md を参考にすることで作っている。\n先人と文明は偉大。\n\n$ npm publish\n\n問題ないことが確認できたらいよいよ公開する。\n\n\n\nたった一行打つだけ。\n\n公開したら、GitHub 上でも Release をつくる。\n\nおわりに\n\nはじめての$ npm publishはなんだか気分が良い。\n\nnpm のパッケージのページでは Download 数が見れるのだが、公開された瞬間に40くらいになっていた。\n謎。\nミラーだったりで自動取得されてるのかな。\n\nそもそも Download 数ってそんなに正確である必要はないので、40など誤差の範囲内だが。\n\n\n\n追記: (2020/10/04) 不要な改行タグを削除\n"},{"id":"http://localhost:3000/posts/computer-essay","url":"http://localhost:3000/posts/computer-essay","title":"コンピュータの有名なエッセイ","summary":"コンピュータの専門家を志すものとして、近いうちに読んでおきたい(読み直したい)エッセイ。 インターネット上に公開されているものも多く、日本語訳のリンクをつけている。 著者、訳者に感謝。 自分の今後の人生など知る由もないが、仕事になろうとそうでなかろうと、コンピューテーションが楽しいものだということを忘れずに、いや今よりもそう思えるような人間でありたい。 ハッカーと画家(Hackers & Painters) ポール・グレアム著。 エッセイ集。 いくつかの章は読んだ。強い表現のところもあったりしてクセのある、他方魅力的な文章。 どうしてオタクはモテないか ハッカーと画家 口にできないこと もうひ","date_published":"2020-05-20T14:23:23+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%AE%E6%9C%89%E5%90%8D%E3%81%AA%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b89c8ac0cfc14f29d6fc346ffb0f74a1d4c64fa7","comment":"Add a post of computer-essay.md\n","date_modified":"2020-05-20T16:01:43+09:00"}],"content_html":"<p>コンピュータの専門家を志すものとして、近いうちに読んでおきたい(読み直したい)エッセイ。\nインターネット上に公開されているものも多く、日本語訳のリンクをつけている。</p>\n<p>著者、訳者に感謝。</p>\n<p>自分の今後の人生など知る由もないが、仕事になろうとそうでなかろうと、コンピューテーションが楽しいものだということを忘れずに、いや今よりもそう思えるような人間でありたい。</p>\n<h2>ハッカーと画家(Hackers &#x26; Painters)</h2>\n<p>ポール・グレアム著。</p>\n<p>エッセイ集。</p>\n<p>いくつかの章は読んだ。強い表現のところもあったりしてクセのある、他方魅力的な文章。</p>\n<ol>\n<li><a href=\"http://www.blog.net/nerds-jp.htm\">どうしてオタクはモテないか</a></li>\n<li><a href=\"http://practical-scheme.net/trans/hp-j.html\">ハッカーと画家</a></li>\n<li><a href=\"http://practical-scheme.net/trans/say-j.html\">口にできないこと</a></li>\n<li><a href=\"http://practical-scheme.net/trans/road-j.html\">もうひとつの未来への道</a></li>\n<li><a href=\"http://practical-scheme.net/trans/spam-j.html\">スパムへの対策</a></li>\n<li><a href=\"http://practical-scheme.net/trans/taste-j.html\">ものつくりのセンス</a></li>\n<li><a href=\"http://practical-scheme.net/trans/hundred-j.html\">百年の言語</a></li>\n<li><a href=\"http://practical-scheme.net/trans/beating-the-averages-j.html\">普通のやつらの上を行け</a></li>\n<li><a href=\"http://practical-scheme.net/trans/icad-j.html\">オタク野郎の復讐</a></li>\n<li><a href=\"http://practical-scheme.net/trans/being-popular-j.html\">夢の言語</a></li>\n<li><a href=\"http://practical-scheme.net/trans/desres-j.html\">デザインとリサーチ</a></li>\n<li><a href=\"http://practical-scheme.net/trans/gh-j.html\">素晴らしきハッカー</a></li>\n</ol>\n<ul>\n<li><a href=\"http://practical-scheme.net/wiliki/wiliki.cgi?naoya_t%3A%E3%83%9D%E3%83%BC%E3%83%AB%E3%83%BB%E3%82%B0%E3%83%AC%E3%82%A2%E3%83%A0%E3%81%AE%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4%E3%81%A8%E5%92%8C%E8%A8%B3%E4%B8%80%E8%A6%A7\">他を含む エッセイと和訳の一覧</a></li>\n</ul>\n<h2><a href=\"https://cruel.org/freeware/cathedral.html\">伽藍とバザール(The Cathedral and the Bazaar)</a></h2>\n<p>エリック・レイモンド著。</p>\n<p>先日、TCP/IPに関する説明を大学の先生から受けたときに聞いた本。\nオープンソースソフトウェアの発展に関する考察がされているようだ。</p>\n<p>まだ読んでいない。</p>\n<h2><a href=\"https://cruel.org/freeware/hacker.html#basic_skills\">ハッカーになろう(How To Become A Hacker)</a></h2>\n<p>こちらもエリック・レイモンド著。</p>\n<p>ハッカーとしての志、考え方が書かれている。</p>\n<p>一度読んだ。\n私は全然ハッカーに近づけてはいないなと実感しながら。</p>\n<h2><a href=\"https://ja.wikisource.org/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%8C%E7%9F%A5%E3%82%8B%E3%81%B9%E3%81%8D97%E3%81%AE%E3%81%93%E3%81%A8\">プログラマが知るべき97のこと</a></h2>\n<p>多数のプログラマが語るエッセイ集のようだ。</p>\n<p>まだ一部しか読めていない。</p>\n<h2><a href=\"https://tatsu-zine.com/books/passionate-programmer-ja\">情熱プログラマー</a></h2>\n<p>Chad Fowler著のプログラマがキャリアを築くための方法を述べた書籍のようだ。</p>\n<p>まだ読んでいない(買っていない)。</p>\n<p><a href=\"https://yuru28.com\">ゆるふわポッドキャスト</a>の<a href=\"https://twitter.com/mktakuya\">@mktakuya</a>さんがTwitterでつぶやいて知った。</p>\n<hr/>\n<br/>\n<p>エッセイではないが、<a href=\"https://www.amazon.co.jp/UNIX%E3%81%A8%E3%81%84%E3%81%86%E8%80%83%E3%81%88%E6%96%B9%E2%80%95%E3%81%9D%E3%81%AE%E8%A8%AD%E8%A8%88%E6%80%9D%E6%83%B3%E3%81%A8%E5%93%B2%E5%AD%A6-Mike-Gancarz/dp/4274064069\">Unixという考え方 - その設計思想と哲学</a>も改めて読み直したい。</p>\n","content_text":"コンピュータの専門家を志すものとして、近いうちに読んでおきたい(読み直したい)エッセイ。\nインターネット上に公開されているものも多く、日本語訳のリンクをつけている。\n\n著者、訳者に感謝。\n\n自分の今後の人生など知る由もないが、仕事になろうとそうでなかろうと、コンピューテーションが楽しいものだということを忘れずに、いや今よりもそう思えるような人間でありたい。\n\nハッカーと画家(Hackers & Painters)\n\nポール・グレアム著。\n\nエッセイ集。\n\nいくつかの章は読んだ。強い表現のところもあったりしてクセのある、他方魅力的な文章。\n\nどうしてオタクはモテないか\n\nハッカーと画家\n\n口にできないこと\n\nもうひとつの未来への道\n\nスパムへの対策\n\nものつくりのセンス\n\n百年の言語\n\n普通のやつらの上を行け\n\nオタク野郎の復讐\n\n夢の言語\n\nデザインとリサーチ\n\n素晴らしきハッカー\n\n他を含む エッセイと和訳の一覧\n\n伽藍とバザール(The Cathedral and the Bazaar)\n\nエリック・レイモンド著。\n\n先日、TCP/IPに関する説明を大学の先生から受けたときに聞いた本。\nオープンソースソフトウェアの発展に関する考察がされているようだ。\n\nまだ読んでいない。\n\nハッカーになろう(How To Become A Hacker)\n\nこちらもエリック・レイモンド著。\n\nハッカーとしての志、考え方が書かれている。\n\n一度読んだ。\n私は全然ハッカーに近づけてはいないなと実感しながら。\n\nプログラマが知るべき97のこと\n\n多数のプログラマが語るエッセイ集のようだ。\n\nまだ一部しか読めていない。\n\n情熱プログラマー\n\nChad Fowler著のプログラマがキャリアを築くための方法を述べた書籍のようだ。\n\nまだ読んでいない(買っていない)。\n\nゆるふわポッドキャストの@mktakuyaさんがTwitterでつぶやいて知った。\n\n\n\nエッセイではないが、Unixという考え方 - その設計思想と哲学も改めて読み直したい。\n"},{"id":"http://localhost:3000/posts/2019-github-repositories","url":"http://localhost:3000/posts/2019-github-repositories","title":"リポジトリで振り返る2019年","summary":"2020年も中頃だが、2019年末〜2020年正月に書きかけた記事が出てきた。 捨てるのも何なのでここに放出。 以下。年末に1年を振り返るという記事の趣旨から各リポジトリにリンクをつけた以外は原文のまま。 リンク以外の追記部分はその旨を記述している。 なにをするか あけましておめでとうございます。 年越ししてしまいましたが、まだ正月なので昨年を振り返って今年に向けて身を引き締めたい。 今回はGitHubのリポジトリを総ざらいして自分がどんな開発をしたか振り返る。 準備:GitHubのリポジトリ一覧を取得する githubのAPIを用いて、curlでリポジトリ情報を取得する。 参考: GitHu","date_published":"2020-05-19T21:44:57+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%81%A7%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8B2019%E5%B9%B4,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/04f4516f39f3f381ad27b0fc2c5bb924f4e0ef64","comment":"Add a post '2020-github-repositories'\n","date_modified":"2020-12-31T18:34:47+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b3a177dcc9d72e1af2661b27b895b52e2c240ca9","comment":"Fix link position\n","date_modified":"2020-05-20T14:22:49+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/6f4ae8435298f362b5cabd5e2f0380d8fc1798ff","comment":"Add a post of 2019-github-repositories\n","date_modified":"2020-05-19T21:50:48+09:00"}],"content_html":"<p>2020年も中頃だが、2019年末〜2020年正月に書きかけた記事が出てきた。\n捨てるのも何なのでここに放出。</p>\n<p>以下。年末に1年を振り返るという記事の趣旨から各リポジトリにリンクをつけた以外は原文のまま。\nリンク以外の追記部分はその旨を記述している。</p>\n<hr/>\n<h2>なにをするか</h2>\n<p>あけましておめでとうございます。\n年越ししてしまいましたが、まだ正月なので昨年を振り返って今年に向けて身を引き締めたい。</p>\n<p>今回はGitHubのリポジトリを総ざらいして自分がどんな開発をしたか振り返る。</p>\n<h2>準備:GitHubのリポジトリ一覧を取得する</h2>\n<p>githubのAPIを用いて、curlでリポジトリ情報を取得する。</p>\n<pre><code class=\"hljs language-sh\">$ curl -u yammerjp <span class=\"hljs-string\">\"https://api.github.com/users/yammerjp/repos?per_page=100&#x26;page=1\"</span> | grep <span class=\"hljs-string\">'\"name\": \"'</span> | awk -F <span class=\"hljs-string\">'\"'</span> <span class=\"hljs-string\">'{print $4}'</span> > repos.txt</code></pre>\n<p>参考: <a href=\"https://qiita.com/emergent/items/a557246a0c0bf9d50a11\">GitHubのリポジトリを一覧化する（public/private両対応）- Qiita</a></p>\n<h2>リポジトリ一覧 (2019/12/31現在)</h2>\n<p>私(<a href=\"https://github.com/yammerjp\">yammerjp</a>)のgithub上にあるpublicリポジトリは31個。\nまともにGitHubを使い始めてから1年ほどというのもあり、すべて2019年に1コミット以上しているので、これらを振り返る。</p>\n<h3>純粋な個人趣味開発</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/c-sharp-socket\">c-sharp-socket</a></li>\n</ul>\n<p>友人からの質問をきっかけにC#でソケット通信をしてみた、サンプルコード的なリポジトリ。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/text2pdf\">text2pdf</a></li>\n</ul>\n<p>textデータをPDFファイルに出力できるアプリケーション。\n2019年1月に、3日間で勢いで作った。実用で使うというより、プロモーションが中心だったので、表示自体は非常に簡素。\nただし、node.js上で外部のライブラリやアプリケーションを用いず、PDFのファイル形式に従ってファイルへの文字列出力部分を自分で実装している。3日間にしては頑張ったな、という感じ。</p>\n<p>日本語出力した際のフォントまわりが貧弱で、文字列が描画される位置が微妙である。\n開発後半に、日本語出力をとってつけで開発したので、このあたりをしっかりすれば、もうすこし見た目が良くなるのではないかな。\nPDFを開く環境による見た目の差異を検証したりすることが必要である。</p>\n<p>もし文字データを手っ取り早くPDFにしたいのであれば、<a href=\"https://dev.classmethod.jp/tool/md-to-pdf/\">md-to-pdf</a>がおすすめ。<a href=\"https://dev.classmethod.jp/tool/md-to-pdf\">GitHub風CSSを当てる</a>と結構いい感じになる。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/playqueue\">PlayQueue</a></li>\n</ul>\n<p>Youtubeを連続再生するWebアプリケーション。\n2018年末から断続的に開発している。\n個人開発のアプリケーションとしては自分の代表作で、就活でも自分を紹介する際に話す機会が多い。</p>\n<h3>大学の授業に関係した開発</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/turingmachineonweb\">TuringMachineOnWeb</a></li>\n</ul>\n<p>2019年1月制作。\nチューリング機械の状態遷移表を作成するエディタと、作成した状態遷移表を検証するシュミレータを作った。</p>\n<p>レポートに書く状態遷移表をつくったときに、つくった状態遷移表が正しいのかを検証するために作った。</p>\n<p>UIは簡素だけれど、当時やりたかったことは達成させられたので満足。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/clustering.ai.2019.su\">clustering.AI.2019.SU</a></li>\n</ul>\n<p>ウォード法による階層的クラスタリングを扱ったレポートを書くために使ったスクリプト。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/pl0i\">pl0i</a></li>\n<li><a href=\"https://github.com/yammerjp/pl0i.js\">pl0i.js</a></li>\n</ul>\n<p>pl0 interpreterという仮想マシンと、TypeScriptによる再実装(未完)</p>\n<p>簡易なアセンブリと、より高級な言語との対応を学ぶために、アセンブリを実行する仮想マシンをつくることで理解を深める試みであった。</p>\n<p>TypeScriptで書いていたときは、最終的にブラウザでメモリの状態や実行している命令の位置なども表示しながらプログラムを実行できるようなWebアプリケーションをつくるつもりだったが、大学の課題と就活を優先した結果開発が進まぬまま課題の方を先に終わらせて提出した。以後開発が停止し未完。</p>\n<h3>夏インターン</h3>\n<h4>夏インターン準備</h4>\n<p>夏インターンでNuxt.jsとTypeScriptを扱うと聞いたので、その準備としてそれらの勉強のために書籍やWebサイトを参考にサンプルアプリを作って動かしてみたリポジトリ群</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/ts-nuxt-tutorial\">ts-nuxt-tutorial</a></li>\n<li><a href=\"https://github.com/yammerjp/green-turtle-org\">green-turtle-org</a></li>\n<li><a href=\"https://github.com/yammerjp/typescript-tutorial1\">Typescript-tutorial1</a></li>\n<li><a href=\"https://github.com/yammerjp/typescript-tutorial2\">Typescript-tutorial2</a></li>\n<li><a href=\"https://github.com/yammerjp/chapter02-qiita-post.nuxt-tutorial\">chapter02-qiita-post.nuxt-tutorial</a></li>\n<li><a href=\"https://github.com/yammerjp/chapter03-01-layout.nuxt-tutorial\">chapter03-01-layout.nuxt-tutorial</a></li>\n<li><a href=\"https://github.com/yammerjp/chapter03-02-middleware.nuxt-tutorial\">chapter03-02-middleware.nuxt-tutorial</a></li>\n</ul>\n<h4>夏インターン</h4>\n<p>夏インターンのハッカソンで制作したWebアプリケーション。PHP製。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/oshushume.20190807\">oshushume.20190807</a></li>\n</ul>\n<h4>夏インターン後</h4>\n<p>夏インターンで扱ったNuxt.jsを生かして何かをしようと作っていたアプリケーションとその残骸。</p>\n<ul>\n<li><a href=\"https://github.com/yammerjp/green-turtle\">green-turtle (ブログのソースコード)</a></li>\n<li><a href=\"https://github.com/yammerjp/nuxt.ts-blog\">nuxt.ts-blog</a></li>\n<li><a href=\"https://github.com/yammerjp/nuxt.ts-blog.org\">nuxt.ts-blog.org</a></li>\n<li><a href=\"https://github.com/yammerjp/nuxt.ts-template\">nuxt.ts-template</a></li>\n<li><a href=\"https://github.com/yammerjp/nuxt.ts-template.org\">nuxt.ts-template.org</a></li>\n</ul>\n<p>最終的にこのブログとして形にして動いている。\n(2020/05/19補足: <a href=\"https://memo.yammer.jp\">memo.yammer.jp</a>ではなく<a href=\"https://blog.yammer.fun\">Green Turtle</a>)</p>\n<p>このブログ(<a href=\"https://blog.yammer.fun\">Green Turtle</a>)のしくみは以下のようになっている。</p>\n<p>mdファイルをgitリポジトリ(アプリケーションソースコードとは別のprivateリポジトリ)で管理している。\nmasterにmergeすることで記事公開。</p>\n<p>アプリケーションリポジトリも、記事リポジトリも、masterにmergeしたときにCircle CIが走ってデプロイするようになっている。</p>\n<p>デプロイは次のような工程で行われる</p>\n<ol>\n<li>2つのリポジトリからソース、記事をclone</li>\n<li>ソースコードのサンプル記事を破棄し、cloneした公開記事に置き換え</li>\n<li>記事markdownをスクリプトでJSONに変換</li>\n<li>Nuxt.jsをGenerateモードで動作させる</li>\n<li>Nuxt.jsが記事ページを描画する際に、記事データが含まれるjsonファイルを読み込み、描画する。</li>\n<li>Nuxt.jsにより静的なHTML,CSSファイルが生成される</li>\n<li>Google Firebase Hostingに静的なHTML,CSSファイルをアップロード</li>\n</ol>\n<p>今後の展望</p>\n<ul>\n<li>トップページとaboutページが簡素なので、もう少しリッチなUIにしたい</li>\n<li>過去記事へのリンクの経路が限られているので、記事下に「最近投稿した記事」などのリンクを置きたい。</li>\n<li>(勉強も兼ねて)バックエンドも用意して、静的ファイルでの公開ではなく、SSRないしSPAで動作させたい。(表示速度は退化するので、完全に勉強目的)</li>\n</ul>\n<p>現在はブログというには簡素な状態だが、今後の拡張性はたくさん用意しているつもりである。\nデプロイの手順も少々手間が混んでいるが、将来APIサーバを用意した際でも描画部分を使い回せるようにするためだったりする。\nやりたいことはたくさんある。</p>\n<h3>Swift ( チーム開発でのiphoneアプリ製作 )</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/ios-animals.enpit.2019.SU\">ios-animals.enpit.2019.SU</a></li>\n<li><a href=\"https://github.com/yammerjp/ios-mymap.enpit.2019.SU\">ios-mymap.enpit.2019.SU</a></li>\n<li><a href=\"https://github.com/yammerjp/ios-photo-viewer.enpit.2019.SU\">ios-photo-viewer.enpit.2019.SU</a></li>\n<li><a href=\"https://github.com/yammerjp/ios-sample-calcurator.enpit.2019.SU\">ios-sample-calcurator.enpit.2019.SU</a></li>\n<li><a href=\"https://github.com/yammerjp/ios-timer.enpit.2019.SU\">ios-timer.enpit.2019.SU</a></li>\n<li><a href=\"https://github.com/yammerjp/PinsOfMap\">PinsOfMap</a></li>\n<li><strike><a href=\"https://github.com/yammerjp/lovelab.heroku\">lovelab.heroku</a></strike>(2020/05/19追記: 現在の名前は<a href=\"https://github.com/yammerjp/lovelab-api\">lovelab-api</a>)</li>\n<li><a href=\"https://github.com/yammerjp/lovelab.vue\">lovelab.vue</a></li>\n</ul>\n<p>9月から、学生どうしでチームを組むiPhoneアプリケーションの開発に関わっている。</p>\n<p>上の5つはサンプルアプリケーションの実装。6つめはそれを生かした簡単な応用の位置情報保存アプリ。</p>\n<p>7つめは10月より開発中のメインのアプリケーションのAPIサーバ。</p>\n<p>8つめは10月より開発中のメインのアプリケーションのプロトタイプ。フロントエンドのWebアプリケーション</p>\n<p>(2020/05/19追記: メインのiphoneアプリケーションのリポジトリはプライベートなのでここにリンクを貼っていない。)</p>\n<h3>rails (冬インターン)</h3>\n<ul>\n<li><a href=\"https://github.com/yammerjp/bbs.rb\">bbs.rb</a></li>\n<li><a href=\"https://github.com/yammerjp/rails-tutorial\">rails-tutorial</a></li>\n<li><a href=\"https://github.com/yammerjp/rails-tutorial-toy_app\">rails-tutorial-toy_app</a></li>\n</ul>\n<p>冬インターンで</p>\n<hr/>\n<p>以上。 ここで止まっていた。\nここからは2020年5月に書いている。</p>\n<p>ちなみに冬インターンでRailsを使うものに参加したのでRailsを軽く触っていたのが最後の書きかけの項目。</p>\n<p>今年度末は同じ内容の記事を書ききって公開したい。</p>\n","content_text":"2020年も中頃だが、2019年末〜2020年正月に書きかけた記事が出てきた。\n捨てるのも何なのでここに放出。\n\n以下。年末に1年を振り返るという記事の趣旨から各リポジトリにリンクをつけた以外は原文のまま。\nリンク以外の追記部分はその旨を記述している。\n\n\n\nなにをするか\n\nあけましておめでとうございます。\n年越ししてしまいましたが、まだ正月なので昨年を振り返って今年に向けて身を引き締めたい。\n\n今回はGitHubのリポジトリを総ざらいして自分がどんな開発をしたか振り返る。\n\n準備:GitHubのリポジトリ一覧を取得する\n\ngithubのAPIを用いて、curlでリポジトリ情報を取得する。\n\n\n\n参考: GitHubのリポジトリを一覧化する（public/private両対応）- Qiita\n\nリポジトリ一覧 (2019/12/31現在)\n\n私(yammerjp)のgithub上にあるpublicリポジトリは31個。\nまともにGitHubを使い始めてから1年ほどというのもあり、すべて2019年に1コミット以上しているので、これらを振り返る。\n\n純粋な個人趣味開発\n\nc-sharp-socket\n\n友人からの質問をきっかけにC#でソケット通信をしてみた、サンプルコード的なリポジトリ。\n\ntext2pdf\n\ntextデータをPDFファイルに出力できるアプリケーション。\n2019年1月に、3日間で勢いで作った。実用で使うというより、プロモーションが中心だったので、表示自体は非常に簡素。\nただし、node.js上で外部のライブラリやアプリケーションを用いず、PDFのファイル形式に従ってファイルへの文字列出力部分を自分で実装している。3日間にしては頑張ったな、という感じ。\n\n日本語出力した際のフォントまわりが貧弱で、文字列が描画される位置が微妙である。\n開発後半に、日本語出力をとってつけで開発したので、このあたりをしっかりすれば、もうすこし見た目が良くなるのではないかな。\nPDFを開く環境による見た目の差異を検証したりすることが必要である。\n\nもし文字データを手っ取り早くPDFにしたいのであれば、md-to-pdfがおすすめ。GitHub風CSSを当てると結構いい感じになる。\n\nPlayQueue\n\nYoutubeを連続再生するWebアプリケーション。\n2018年末から断続的に開発している。\n個人開発のアプリケーションとしては自分の代表作で、就活でも自分を紹介する際に話す機会が多い。\n\n大学の授業に関係した開発\n\nTuringMachineOnWeb\n\n2019年1月制作。\nチューリング機械の状態遷移表を作成するエディタと、作成した状態遷移表を検証するシュミレータを作った。\n\nレポートに書く状態遷移表をつくったときに、つくった状態遷移表が正しいのかを検証するために作った。\n\nUIは簡素だけれど、当時やりたかったことは達成させられたので満足。\n\nclustering.AI.2019.SU\n\nウォード法による階層的クラスタリングを扱ったレポートを書くために使ったスクリプト。\n\npl0i\n\npl0i.js\n\npl0 interpreterという仮想マシンと、TypeScriptによる再実装(未完)\n\n簡易なアセンブリと、より高級な言語との対応を学ぶために、アセンブリを実行する仮想マシンをつくることで理解を深める試みであった。\n\nTypeScriptで書いていたときは、最終的にブラウザでメモリの状態や実行している命令の位置なども表示しながらプログラムを実行できるようなWebアプリケーションをつくるつもりだったが、大学の課題と就活を優先した結果開発が進まぬまま課題の方を先に終わらせて提出した。以後開発が停止し未完。\n\n夏インターン\n\n夏インターン準備\n\n夏インターンでNuxt.jsとTypeScriptを扱うと聞いたので、その準備としてそれらの勉強のために書籍やWebサイトを参考にサンプルアプリを作って動かしてみたリポジトリ群\n\nts-nuxt-tutorial\n\ngreen-turtle-org\n\nTypescript-tutorial1\n\nTypescript-tutorial2\n\nchapter02-qiita-post.nuxt-tutorial\n\nchapter03-01-layout.nuxt-tutorial\n\nchapter03-02-middleware.nuxt-tutorial\n\n夏インターン\n\n夏インターンのハッカソンで制作したWebアプリケーション。PHP製。\n\noshushume.20190807\n\n夏インターン後\n\n夏インターンで扱ったNuxt.jsを生かして何かをしようと作っていたアプリケーションとその残骸。\n\ngreen-turtle (ブログのソースコード)\n\nnuxt.ts-blog\n\nnuxt.ts-blog.org\n\nnuxt.ts-template\n\nnuxt.ts-template.org\n\n最終的にこのブログとして形にして動いている。\n(2020/05/19補足: memo.yammer.jpではなくGreen Turtle)\n\nこのブログ(Green Turtle)のしくみは以下のようになっている。\n\nmdファイルをgitリポジトリ(アプリケーションソースコードとは別のprivateリポジトリ)で管理している。\nmasterにmergeすることで記事公開。\n\nアプリケーションリポジトリも、記事リポジトリも、masterにmergeしたときにCircle CIが走ってデプロイするようになっている。\n\nデプロイは次のような工程で行われる\n\n2つのリポジトリからソース、記事をclone\n\nソースコードのサンプル記事を破棄し、cloneした公開記事に置き換え\n\n記事markdownをスクリプトでJSONに変換\n\nNuxt.jsをGenerateモードで動作させる\n\nNuxt.jsが記事ページを描画する際に、記事データが含まれるjsonファイルを読み込み、描画する。\n\nNuxt.jsにより静的なHTML,CSSファイルが生成される\n\nGoogle Firebase Hostingに静的なHTML,CSSファイルをアップロード\n\n今後の展望\n\nトップページとaboutページが簡素なので、もう少しリッチなUIにしたい\n\n過去記事へのリンクの経路が限られているので、記事下に「最近投稿した記事」などのリンクを置きたい。\n\n(勉強も兼ねて)バックエンドも用意して、静的ファイルでの公開ではなく、SSRないしSPAで動作させたい。(表示速度は退化するので、完全に勉強目的)\n\n現在はブログというには簡素な状態だが、今後の拡張性はたくさん用意しているつもりである。\nデプロイの手順も少々手間が混んでいるが、将来APIサーバを用意した際でも描画部分を使い回せるようにするためだったりする。\nやりたいことはたくさんある。\n\nSwift ( チーム開発でのiphoneアプリ製作 )\n\nios-animals.enpit.2019.SU\n\nios-mymap.enpit.2019.SU\n\nios-photo-viewer.enpit.2019.SU\n\nios-sample-calcurator.enpit.2019.SU\n\nios-timer.enpit.2019.SU\n\nPinsOfMap\n\nlovelab.heroku(2020/05/19追記: 現在の名前はlovelab-api)\n\nlovelab.vue\n\n9月から、学生どうしでチームを組むiPhoneアプリケーションの開発に関わっている。\n\n上の5つはサンプルアプリケーションの実装。6つめはそれを生かした簡単な応用の位置情報保存アプリ。\n\n7つめは10月より開発中のメインのアプリケーションのAPIサーバ。\n\n8つめは10月より開発中のメインのアプリケーションのプロトタイプ。フロントエンドのWebアプリケーション\n\n(2020/05/19追記: メインのiphoneアプリケーションのリポジトリはプライベートなのでここにリンクを貼っていない。)\n\nrails (冬インターン)\n\nbbs.rb\n\nrails-tutorial\n\nrails-tutorial-toy_app\n\n冬インターンで\n\n\n\n以上。 ここで止まっていた。\nここからは2020年5月に書いている。\n\nちなみに冬インターンでRailsを使うものに参加したのでRailsを軽く触っていたのが最後の書きかけの項目。\n\n今年度末は同じ内容の記事を書ききって公開したい。\n"},{"id":"http://localhost:3000/posts/promise","url":"http://localhost:3000/posts/promise","title":"非同期のまえに同期処理を通してPromiseとasync/awaitを理解する","summary":"JavaScript といえば非同期処理はつきものだが、非同期や Promise に苦手意識を持つ人も多いのではないだろうか。 これらの最初の理解のハードルは結構高いと思う。私も理解できずに悶絶した。C言語のポインタよりむずくないか？。。。 この記事の前半では一旦非同期のことは忘れる。 まず記事前半は、同期処理をテーマに、コールバック, Promise, async/await について説明する。 記事の後半は、これらを非同期処理を交えて説明する。 Promise はよくわからないという方や、一度挫折した方などにぜひ読んでもらいたい。 (2020/05/30補足: Qiita投稿に合わせて全体","date_published":"2020-05-19T16:50:47+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%81%AE%E3%81%BE%E3%81%88%E3%81%AB%E5%90%8C%E6%9C%9F%E5%87%A6%E7%90%86%E3%82%92%E9%80%9A%E3%81%97%E3%81%A6Promise%E3%81%A8async%2Fawait%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","非同期"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/39ff8b31b50f0ae27f379c0c5a8486bafeb80132","comment":"Update for Qiita\n","date_modified":"2020-05-30T13:55:02+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/83221c3c8c3707986024d192c851120e1a75cba6","comment":"Publish a post of promise\n","date_modified":"2020-05-19T19:42:52+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/9a7f5fa4566b6a765643b4cf6480947b7931eba0","comment":"Add a post of Promise\n","date_modified":"2020-05-19T19:41:49+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/94fe7d6f1f83dc15496bd17dcfdffc01e04fc474","comment":"[WIP] writing about JavaScript Promise ...\n","date_modified":"2020-05-19T12:20:51+09:00"}],"content_html":"<p>JavaScript といえば非同期処理はつきものだが、非同期や Promise に苦手意識を持つ人も多いのではないだろうか。</p>\n<p>これらの最初の理解のハードルは結構高いと思う。私も理解できずに悶絶した。C言語のポインタよりむずくないか？。。。</p>\n<p>この記事の前半では一旦非同期のことは忘れる。\nまず記事前半は、同期処理をテーマに、コールバック, Promise, async/await について説明する。\n記事の後半は、これらを非同期処理を交えて説明する。</p>\n<p>Promise はよくわからないという方や、一度挫折した方などにぜひ読んでもらいたい。</p>\n<p>(2020/05/30補足: <a href=\"https://qiita.com/yammerjp/items/b1c96de727a53c4b4698\">Qiita投稿</a>に合わせて全体を修正済み。(<a href=\"https://github.com/yammerjp/memo.yammer.jp/blob/979b5576e05cb97e453b5cd3731e3802a0dc6fca/content/posts/promise.md\">旧版</a>))</p>\n<h2>対象読者</h2>\n<ul>\n<li>JavaScript の基本的文法を知っている。(調べればわかる)</li>\n<li>非同期処理, コールバック, Promise, async/awaitに苦手意識がある、よくわからない。</li>\n</ul>\n<p>JavaScriptを1行も読んだことも書いたこともない人、プログラミングをしたことのない人は対象としない。\n逆に少しでも読み書きできればオーケー、のつもり。</p>\n<h2>目指すところ</h2>\n<ul>\n<li>同期処理と非同期処理の違いがわかる</li>\n<li>(非同期処理を対象とした)他のPromise,async/awaitの解説記事を読んで理解が進む</li>\n</ul>\n<h2>Step0 準備</h2>\n<h3>Step0-1 MDN</h3>\n<p>非同期処理もコールバックもPromiseもasync/awaitも関係ないが、まずMDNについて説明しておきたい。</p>\n<p>JavaScriptでわからないことがあれば、まずは都度<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript\">MDN web docs</a>をみるとよい。</p>\n<p>適当に検索して出てくる記事よりも、とりあえずここで確認しよう\n(本記事も適当に検索して出てくる記事に該当するという矛盾がはらむ)。\n一度理解して忘れていた記法などを確認するのにもとてもよい。</p>\n<h3>Step0-2 Chrome Developper Tool</h3>\n<p>以下JavaScirptの説明をするので、実際に動かしたくなる人もいるだろう。</p>\n<p>PCにnode.jsが既にインストールされている人はそちらを使うのもよい。</p>\n<p>しかし、インストールされていない人は、いちいちHTMLファイルを書いて、JavaScriptを読み込んで、、、とするのは面倒だろう。</p>\n<p>もっと気軽にJavaScriptを試せる方法がある。\nChrome developper Toolである。</p>\n<p>ブラウザにGoogle Chromeを使っている人はウィンドウ右上の︙ > その他のツール > デベロッパーツール を開いてみよう。\n画面上方の「Console」タブを開いて、文字を入力すると、JavaScriptがエンターキーを押すごとに実行されるはずだ。</p>\n<h3>Step0-3 アロー関数</h3>\n<p>ES6 (ES2015)以降の最近のJavaScriptでは、アロー関数という記法がある。\nアロー関数がわからない人も、この記事出てくるので簡単に抑えておきたい。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 従来の書き方</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span> (<span class=\"hljs-params\"> a, b </span>) </span>{\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n\n<span class=\"hljs-comment\">// アロー関数</span>\n<span class=\"hljs-keyword\">const</span> sum2 = <span class=\"hljs-function\">(<span class=\"hljs-params\"> a, b </span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> a + b;\n};\n\n<span class=\"hljs-comment\">// アロー関数 関数の中がreturn文だけのときは、{return}を省略できる</span>\n<span class=\"hljs-keyword\">const</span> sum3 = <span class=\"hljs-function\">(<span class=\"hljs-params\"> a, b </span>) =></span> a + b;\n\n<span class=\"hljs-comment\">// アロー関数 引数が1つのときだけ()が省略できる (0つ、2つ以上はダメ)</span>\n<span class=\"hljs-keyword\">const</span> twice = <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =></span> a*<span class=\"hljs-number\">2</span>;</code></pre>\n<p>thisがbindされるかだとか他の違いは一旦忘れる。\n上のように書けるということだけわかればよい。</p>\n<p>さて、前置きが長くなったが準備が整った。</p>\n<h2>Step1 同期処理</h2>\n<p>まずは非同期のことはわすれて、とりあえず読み進めて欲しい。</p>\n<h3>Step1-1 コールバック (同期関数)</h3>\n<p>コールバックとは、関数自体を引数として与え、別の関数に実行してもらうしくみだ。\n電話を折り返すことに由来して名付けられた。\n由来の通り、関数自体を伝えて「あとで都合が良くなったら実行しておいて」と実行を押し付ける方式。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callbackFunc</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'callback'</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callFunc</span> (<span class=\"hljs-params\"> func </span>) </span>{\n  func();\n}\n\ncallFunc( callbackFunc );</code></pre>\n<p>ふつう、関数callbackFuncを実行するなら<code>callbackFunc()</code>のようにするだろう。\nしかし上記では括弧をつけず<code>callbackFunc</code> を引数として渡している。</p>\n<p>括弧をつけないことで、引数として関数自体を渡すだけでその場では実行されない。\n後に callFunc 関数の中で、渡された関数 (<code>callbackFunc</code>)を実行してもらっている。</p>\n<p>この「関数自体を渡す」というのがコールバックの肝である。\nコールバックとは(戻り値の)値渡しではなく、関数自体の参照を渡しているという表現もできる。</p>\n<p>次のような書き方では全く意味が変わってしまうので注意。</p>\n<pre><code class=\"hljs language-js\">callFunc( callbackFunc() );</code></pre>\n<p>これでは、callbackFunc 関数を実行し、その戻り値を callFunc 関数に引数として渡すという意味になってしまう。</p>\n<p>繰り返しになるが、コールバックは「関数自体を渡して」「あとで実行してもらう」しくみである。</p>\n<p>参考: <a href=\"https://developer.mozilla.org/ja/docs/Glossary/Callback_function\">Callback function(コールバック関数) MDN web docs</a></p>\n<h4>(補足) コールバックとアロー関数</h4>\n<p>ちなみに上述のコードはアロー関数を使って次のようにも書ける。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> callbackFunc = <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'callback'</span>);\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callFunc</span>(<span class=\"hljs-params\"> func </span>) </span>{\n  func();\n}\n\ncallFunc( callbackFunc );</code></pre>\n<p>さらに、一度変数に入れるのをやめると</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callFunc</span>(<span class=\"hljs-params\"> func </span>) </span>{\n  func();\n}\n\ncallFunc( <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'callback'</span>);\n})</code></pre>\n<p>引数を指定する中で関数を定義してしまうのだ。\nこのように関数自体を引数で渡すとき(即ちコールバック関数を渡すとき)、アロー関数でシンプルにかける。</p>\n<h3>Step1-2 Promise (同期関数)</h3>\n<p>Promise は英語で「約束する」という意味だ。\n名前の通り、あとで値を返すことを約束するような動作をする。(約束を破ることもある。)</p>\n<h4>Promise の状態</h4>\n<p>Promise には3つの状態がある。</p>\n<ul>\n<li>pending ... 約束している状態(初期状態)</li>\n<li>fulfilled ... 約束を守って値を返した状態</li>\n<li>rejected ... 約束を破った状態</li>\n</ul>\n<p>Promise オブジェクトはまず pending で始まり、あとで fulfilled や rejected に状態が変化する。</p>\n<h5>状態: pending</h5>\n<p>とりあえず約束してみる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n});\n<span class=\"hljs-comment\">// 何もしない関数を、new Promise() に渡している。</span>\n<span class=\"hljs-built_in\">console</span>.log( promise );</code></pre>\n<p>pendingと表示されただろう。</p>\n<p><em>ここでの変数<code>promise</code>は、Promise の状態 pending といえる。</em></p>\n<h5>状態: fulfilled</h5>\n<p>次は fulfilled の状態を作ってみる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve();\n})\n<span class=\"hljs-built_in\">console</span>.log( promise );\n<span class=\"hljs-comment\">// 実はresolve,rejectはそれぞれ、渡された(コールバック)関数を引数として受け取っている。</span></code></pre>\n<p>Promise resoleved と表示されただろう。これが fulfilled である。</p>\n<p>実は状態 fulfilled は値を持つ。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>);\n})\n<span class=\"hljs-built_in\">console</span>.log( promise );</code></pre>\n<p><em>ここでの変数<code>promise</code>は、Promiseの状態 fulfilled であり、値<code>'hello'</code>を持つといえる。</em></p>\n<h5>状態: rejected</h5>\n<p>rejected も fulfilled と同様に値を持つ。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  reject(<span class=\"hljs-string\">'hello'</span>);\n})\n<span class=\"hljs-built_in\">console</span>.log( promise );</code></pre>\n<p><em>ここでの変数<code>promise</code>は、Promise の状態 rejected であり、値<code>'hello'</code>を持つといえる。</em></p>\n<p>rejected で渡される値(オブジェクト)は Error オブジェクトだったりする。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'error message'</span>));\n})\n<span class=\"hljs-built_in\">console</span>.log( promise );</code></pre>\n<p><em>ここでの変数<code>promise</code>は、Promise の状態 rejected であり、値に Error オブジェクトを持つといえる。</em></p>\n<h4>状態の変化</h4>\n<p>Promiseでは状態が変化する。\n初期状態では pending であるが、のちに fulfilled や rejected になる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-comment\">//この行が実行されるタイミングでは、変数promiseは状態pending</span>\n  <span class=\"hljs-keyword\">if</span>( <span class=\"hljs-literal\">true</span> ){\n    <span class=\"hljs-comment\">//この行が実行されるタイミングでも、まだ変数promiseは状態pending</span>\n    resolve(<span class=\"hljs-string\">'resolveされた!'</span>);\n    <span class=\"hljs-comment\">//この行が実行されるタイミングでは、変数promiseは状態fulfilledで値'resolveされた!'を持つ</span>\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-comment\">// ここから先は実行されない</span>\n  reject(<span class=\"hljs-string\">'rejectされた'</span>);\n})</code></pre>\n<p>現在は同期処理を行っているので、fulfill または reject された状態に一瞬で変化してしまい、 pending の状態をみることはできない。</p>\n<p>しかし厳密にはもともとは pending で、 <code>resolve()</code>を実行すると fulfilled に、 <code>reject()</code> を実行すると rejected に、それぞれ状態が移行する。</p>\n<h4>then/catch による Promise チェーン</h4>\n<p>さて、Promise には3状態あり、変化することがわかった。\n変化すると何ができるのか？ それをこの節で説明する。</p>\n<p>Promise オブジェクトのメソッドに、then と catch がある。</p>\n<p>これらはそれぞれ第一引数に関数をとり、Promise が fulfilled や rejected の状態になると引数関数を実行する。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>);\n})\n\npromise.then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(arg); <span class=\"hljs-comment\">// ここではhelloが表示される</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>);\n})</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  reject(<span class=\"hljs-string\">'hello'</span>);\n})\n\npromise.catch( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(arg); <span class=\"hljs-comment\">// ここではhelloが表示される</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'catch is called'</span>);\n})</code></pre>\n<p>このように<code>.</code>でつないで then/catch メソッドを呼べば、それらを発火できる。</p>\n<p>さらに、then/catch メソッドの戻り値に promise を与えてやれば、更に繋げられる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>);\n})\n\npromise\n  .then( <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'resolve!'</span>);\n  })\n  .then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.resolve( arg + <span class=\"hljs-string\">'!'</span> );\n  })\n  .then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(arg); <span class=\"hljs-comment\">// resolve!! と表示される。</span>\n  })\n\n<span class=\"hljs-comment\">// Promise.resolve('resolve!'); は、</span>\n<span class=\"hljs-comment\">// new Promise( resolve => { resolve('resolve!') }); と同じ。</span></code></pre>\n<p>上述の通り、then メソッドの戻り値に Promise を渡すと、更に後ろに<code>.then()</code>を繋げられる。\n(<code>.catch()</code>も繋げられる。)</p>\n<p>このように、Promise が解決 (fulfill/reject) されたら<code>.then()</code>メソッドが発火し、\n<code>.then()</code>メソッドがPromiseを返すと、解決されたらさらに後ろの<code>.then()</code>メソッドが発火し、、、</p>\n<p>このように数珠つなぎに徐々に Promise が渡ることを Promise チェーンと呼ぶ。</p>\n<hr/>\n<p>ここまでで Promise を学んだ。\nコールバックや Promise を使う理由は非同期関数にあるので、読者の皆様にはややこしいことをしているようにしか見えないかもしれない。</p>\n<p>本当はこのあたりで非同期関数について説明し Promise のありがたみを理解していただくのもよいのだが、この記事はあくまで「まず同期関数で理解する。」ことが目的であり、非同期関数はもう少し後回しにする。</p>\n<hr/>\n<h3>Step1-3 async/await (同期関数)</h3>\n<p>次は sync/await だ。</p>\n<p>そのまえに説明すべきことが2つほどあるので補足。</p>\n<h4>補足: 即時関数</h4>\n<p>即時関数は定義と同時に実行する関数だ。\n関数定義を括弧でくくると即時実行される。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> Hello = <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>) };\nHello();\n\n<span class=\"hljs-comment\">// 上2行のコードは、次の行のコードと同じ。</span>\n( <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>) });\n\n<span class=\"hljs-comment\">// アロー関数でなくても良い</span>\n( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>) });</code></pre>\n<h4>補足: Async 関数 (asnyc function)</h4>\n<p>関数定義の前に<code>async</code>とつけて定義する。\nAsnyc 関数の中でのみ await が使える。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 例</span>\n<span class=\"hljs-keyword\">const</span> arrowFunc = <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">await</span> promise;\n}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">await</span> promise;\n}</code></pre>\n<hr/>\n<h4>改めて async/await (同期関数)</h4>\n<p>閑話休題。</p>\n<p>async/await は Promise を生成する構文と言っていい。\n先程の then を書かずともよくなる構文である。</p>\n<p>前節の Promise のコードを再掲する。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>);\n})\n\npromise.then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(arg) <span class=\"hljs-comment\">// ここではhelloが表示される</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>);\n})</code></pre>\n<p>これを async/await に書き直すと</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>);\n})\n\n(<span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">const</span> arg = <span class=\"hljs-keyword\">await</span> promise;\n  <span class=\"hljs-built_in\">console</span>.log(arg); <span class=\"hljs-comment\">// ここではhelloが表示される</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>);\n})</code></pre>\n<p>このようになる。\nthen が消えたことがわかる。</p>\n<p>(即時実行のasync関数を使っている。)</p>\n<br/>\n<p>もう一つ前節のコードを再掲し async/await に書き換えてみる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>)\n})\n\npromise\n  .then( <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'resolve!'</span>)\n  })\n  .then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.resolve( arg + <span class=\"hljs-string\">'!'</span> )\n  })\n  .then( <span class=\"hljs-function\"><span class=\"hljs-params\">arg</span> =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(arg) <span class=\"hljs-comment\">// resolve!! と表示される。</span>\n  })</code></pre>\n<p>async/await に書き換えると</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(<span class=\"hljs-string\">'hello'</span>)\n})\n\n( <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">let</span> arg = <span class=\"hljs-keyword\">await</span> promise\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'then is called'</span>)\n  <span class=\"hljs-keyword\">let</span> arg = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'resolve!'</span>)\n  <span class=\"hljs-keyword\">let</span> arg = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.resolve( arg + <span class=\"hljs-string\">'!'</span> )\n  <span class=\"hljs-built_in\">console</span>.log(arg) <span class=\"hljs-comment\">// resolve!! と表示される。</span>\n})</code></pre>\n<p>今度は then がなくなったことで短く書けたことが伝わるのではないか。</p>\n<p><code>await</code>が現れると、Async 関数内の<code>await</code>より後ろの部分が全て<code>then()</code>の引数として包まれる、といった見方もできる。</p>\n<p>以上のように、async/await は Promise を簡潔に書く構文である。</p>\n<br/>\n<h4>余談: Promiseは必要か?</h4>\n<p>async/awaitで簡潔にかけるなら、Promiseなんて理解しなくて良いのでは？と思う方もいるだろう。\nしかし今の所そうも行かないのだ。</p>\n<p>複数のPromiseを同時に待つ処理をasync/awaitで書いてみる。</p>\n<pre><code class=\"hljs language-js\">( <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all( [ promise1, promise2 ])\n})</code></pre>\n<p>うお、Promise出てきた。。。</p>\n<p>コードの内容はおいておいて、Promise という単語が出てきたことに注目。\n解説は省くが、async/await は Promise を完全には隠しきれていないのだ。</p>\n<p>(気になる方はこの記事を読み終えてから<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\"><code>Promise.all</code></a>をみると良いだろう。</p>\n<br/>\n<h2>Step2 非同期処理</h2>\n<p>さてさて、ここまで来ればゴールは近い。\nこの節では今まで苦労して覚えた謎構文 Promise と asnyc/await のありがたみがわかるようになる。</p>\n<h3>Step2-1 同期関数と非同期関数</h3>\n<p>同期関数と非同期関数について説明する。</p>\n<ul>\n<li>同期関数とは、中の処理が完了するまで待ってから戻り値を返す関数のこと</li>\n<li>非同期関数とは、中の処理にかかわらず、すぐに戻り値を返してしまう関数のこと</li>\n</ul>\n<p>JavaScript の代表的な非同期関数に<code>setTimeOut()</code>がある。</p>\n<p>次のようなコードで考えてみよう。</p>\n<pre><code class=\"hljs language-js\">setTimeOut( <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>);\n}, <span class=\"hljs-number\">1000</span>);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world'</span>);</code></pre>\n<p>JavaScript は、普通は(同期関数は)、上から順番に1行ずつ実行される。</p>\n<p>しかし上記のコードを実行すると<code>world</code>が表示された後に<code>hello</code>が表示される。\nこれは<code>setTimeOut()</code>関数が非同期関数だからだ。</p>\n<p>書き方を少し変えてみる。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Hello</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-comment\">// 1</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>); <span class=\"hljs-comment\">// 4</span>\n}\nsetTimeOut( Hello, <span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world'</span>) <span class=\"hljs-comment\">// 3</span></code></pre>\n<p>さっきと同じ動作をするコードだ。</p>\n<p>コンピュータの気持ちになってみると</p>\n<ol>\n<li>Hello 関数を定義するよ。Hello 関数は実行されたら<code>'hello'</code>と表示するよ。まだ定義だけで実行しないよ。</li>\n<li>setTimeOut 関数を実行するよ。Hello 関数を 1000ms 後に実行するとを登録するよ。<strong>登録するだけで、すぐに戻り値を返すよ。</strong></li>\n<li><code>'world'</code>と表示するよ。</li>\n</ol>\n<p>... しばらく (1000ms) 経って ...</p>\n<ol start=\"4\">\n<li>Hello 関数を実行するよ、<code>'hello'</code>と表示するよ。</li>\n</ol>\n<p>このような順で動作する。\n同期関数はその行で処理が停止するのに対し、非同期関数はすぐに次の行が実行される。</p>\n<h2>Step2-2 コールバック (非同期関数)</h2>\n<p>先程の例で非同期関数を実現してるのがコールバックだ。</p>\n<p>あとで実行して欲しい関数を引数で伝えておいて、ときが来たら実行する。</p>\n<p>やりたいことはコールバックで実現できるものの、何重にも重なると次のようなコードにになってしまう。</p>\n<pre><code class=\"hljs language-js\">setTimeOut( <span class=\"hljs-function\">() =></span> {\n  setTimeOut( <span class=\"hljs-function\">() =></span> {\n    setTimeOut( <span class=\"hljs-function\">() =></span> {\n      setTimeOut( <span class=\"hljs-function\">() =></span> {\n        setTimeOut( <span class=\"hljs-function\">() =></span> {\n          setTimeOut( <span class=\"hljs-function\">() =></span> {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'6s later'</span>);\n          }, <span class=\"hljs-number\">1000</span>);\n        }, <span class=\"hljs-number\">1000</span>);\n      }, <span class=\"hljs-number\">1000</span>);\n    }, <span class=\"hljs-number\">1000</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n}, <span class=\"hljs-number\">1000</span>);\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'これはすぐに実行される'</span>);</code></pre>\n<p>コールバック関数を呼ぶたびにネストが深くなってしまい読みづらい。</p>\n<p>俗に言うコールバック地獄である。\nたとえばこの例だと、どの秒数がどの setTimeOut に対応するのかわかりづらい。</p>\n<p>(上記の例は全て一つの setTimeOut にまとめられるが)\n実際には次のような状況が考えられる。</p>\n<ol>\n<li>サーバと通信して、記事のリストをとってくる。</li>\n<li>記事のリストから該当の記事を探して、再度サーバと通信して本文をとってくる。</li>\n</ol>\n<p>このように、複数の非同期処理が数珠つなぎになることもあるだろう。</p>\n<p>数珠つなぎ、、、</p>\n<h2>Step2-3 Promise (非同期関数)</h2>\n<p>そう、数珠つなぎならさっきの Promise チェーンと相性が良い。</p>\n<p>さっきの6秒待つ処理も</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 事前に Promise 関数を作っておく。</span>\n<span class=\"hljs-comment\">// ライブラリなどで用意されていたりするので、Promise を使う側は作る必要はない。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setTimeOutPromise</span>(<span class=\"hljs-params\">time</span>)</span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n    setTimeOut( resolve, <span class=\"hljs-number\">1000</span>);\n  });\n}\n\nsetTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n.then( <span class=\"hljs-function\">() =></span> \n  setTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n).then( <span class=\"hljs-function\">() =></span>\n  setTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n).then( <span class=\"hljs-function\">() =></span>\n  setTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n).then( <span class=\"hljs-function\">() =></span>\n  setTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n).then( <span class=\"hljs-function\">() =></span>\n  setTimeOutPromise(<span class=\"hljs-number\">1000</span>)\n).then( <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'6s later'</span>);\n})\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'これはすぐに実行される'</span>);</code></pre>\n<p>ネストが解消されて、引数もコンパクトになって見やすくなった。</p>\n<h2>Step2-4 asnyc/await (非同期関数)</h2>\n<p>さらに async/awaitで書き直すと</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 事前に Promise 関数を作っておく。</span>\n<span class=\"hljs-comment\">// さっきと同じ。</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setTimeOutPromise</span>(<span class=\"hljs-params\">time</span>)</span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n    setTimeOut( resolve, <span class=\"hljs-number\">1000</span>)\n  })\n}\n\n( <span class=\"hljs-keyword\">async</span> () => {\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">await</span> setTimeOutPromise(<span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'6s later'</span>);\n})\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'これはすぐに実行される'</span>);</code></pre>\n<p>これは見やすい！\n非同期関数を同期的に書けるようになった。</p>\n<p>await の行で停止しているかのように動作する。</p>\n<h2>さいごに</h2>\n<p>本記事を読み次の2つを知れば、他の記事が格段に読みやすくなるだろう。</p>\n<ul>\n<li>同期処理と非同期処理の違い</li>\n<li>同期処理でPromiseがどういう動作をするか</li>\n</ul>\n<p>これからは「コールバック地獄を解決するために Promise チェーンがある」「 async/await は Promise の生成だ」などと書かれた他の記事も読めるのではないだろうか。</p>\n<p>この記事を完全に理解できなくても、 読者の皆様はこれから JavaScript の非同期処理を深める土台ができているのではないかと思う。</p>\n<p>ここまでの長文に付き合いいただきありがたい。</p>\n<p>以上。</p>\n","content_text":"JavaScript といえば非同期処理はつきものだが、非同期や Promise に苦手意識を持つ人も多いのではないだろうか。\n\nこれらの最初の理解のハードルは結構高いと思う。私も理解できずに悶絶した。C言語のポインタよりむずくないか？。。。\n\nこの記事の前半では一旦非同期のことは忘れる。\nまず記事前半は、同期処理をテーマに、コールバック, Promise, async/await について説明する。\n記事の後半は、これらを非同期処理を交えて説明する。\n\nPromise はよくわからないという方や、一度挫折した方などにぜひ読んでもらいたい。\n\n(2020/05/30補足: Qiita投稿に合わせて全体を修正済み。(旧版))\n\n対象読者\n\nJavaScript の基本的文法を知っている。(調べればわかる)\n\n非同期処理, コールバック, Promise, async/awaitに苦手意識がある、よくわからない。\n\nJavaScriptを1行も読んだことも書いたこともない人、プログラミングをしたことのない人は対象としない。\n逆に少しでも読み書きできればオーケー、のつもり。\n\n目指すところ\n\n同期処理と非同期処理の違いがわかる\n\n(非同期処理を対象とした)他のPromise,async/awaitの解説記事を読んで理解が進む\n\nStep0 準備\n\nStep0-1 MDN\n\n非同期処理もコールバックもPromiseもasync/awaitも関係ないが、まずMDNについて説明しておきたい。\n\nJavaScriptでわからないことがあれば、まずは都度MDN web docsをみるとよい。\n\n適当に検索して出てくる記事よりも、とりあえずここで確認しよう\n(本記事も適当に検索して出てくる記事に該当するという矛盾がはらむ)。\n一度理解して忘れていた記法などを確認するのにもとてもよい。\n\nStep0-2 Chrome Developper Tool\n\n以下JavaScirptの説明をするので、実際に動かしたくなる人もいるだろう。\n\nPCにnode.jsが既にインストールされている人はそちらを使うのもよい。\n\nしかし、インストールされていない人は、いちいちHTMLファイルを書いて、JavaScriptを読み込んで、、、とするのは面倒だろう。\n\nもっと気軽にJavaScriptを試せる方法がある。\nChrome developper Toolである。\n\nブラウザにGoogle Chromeを使っている人はウィンドウ右上の︙ > その他のツール > デベロッパーツール を開いてみよう。\n画面上方の「Console」タブを開いて、文字を入力すると、JavaScriptがエンターキーを押すごとに実行されるはずだ。\n\nStep0-3 アロー関数\n\nES6 (ES2015)以降の最近のJavaScriptでは、アロー関数という記法がある。\nアロー関数がわからない人も、この記事出てくるので簡単に抑えておきたい。\n\n\n\nthisがbindされるかだとか他の違いは一旦忘れる。\n上のように書けるということだけわかればよい。\n\nさて、前置きが長くなったが準備が整った。\n\nStep1 同期処理\n\nまずは非同期のことはわすれて、とりあえず読み進めて欲しい。\n\nStep1-1 コールバック (同期関数)\n\nコールバックとは、関数自体を引数として与え、別の関数に実行してもらうしくみだ。\n電話を折り返すことに由来して名付けられた。\n由来の通り、関数自体を伝えて「あとで都合が良くなったら実行しておいて」と実行を押し付ける方式。\n\n\n\nふつう、関数callbackFuncを実行するならcallbackFunc()のようにするだろう。\nしかし上記では括弧をつけずcallbackFunc を引数として渡している。\n\n括弧をつけないことで、引数として関数自体を渡すだけでその場では実行されない。\n後に callFunc 関数の中で、渡された関数 (callbackFunc)を実行してもらっている。\n\nこの「関数自体を渡す」というのがコールバックの肝である。\nコールバックとは(戻り値の)値渡しではなく、関数自体の参照を渡しているという表現もできる。\n\n次のような書き方では全く意味が変わってしまうので注意。\n\n\n\nこれでは、callbackFunc 関数を実行し、その戻り値を callFunc 関数に引数として渡すという意味になってしまう。\n\n繰り返しになるが、コールバックは「関数自体を渡して」「あとで実行してもらう」しくみである。\n\n参考: Callback function(コールバック関数) MDN web docs\n\n(補足) コールバックとアロー関数\n\nちなみに上述のコードはアロー関数を使って次のようにも書ける。\n\n\n\nさらに、一度変数に入れるのをやめると\n\n\n\n引数を指定する中で関数を定義してしまうのだ。\nこのように関数自体を引数で渡すとき(即ちコールバック関数を渡すとき)、アロー関数でシンプルにかける。\n\nStep1-2 Promise (同期関数)\n\nPromise は英語で「約束する」という意味だ。\n名前の通り、あとで値を返すことを約束するような動作をする。(約束を破ることもある。)\n\nPromise の状態\n\nPromise には3つの状態がある。\n\npending ... 約束している状態(初期状態)\n\nfulfilled ... 約束を守って値を返した状態\n\nrejected ... 約束を破った状態\n\nPromise オブジェクトはまず pending で始まり、あとで fulfilled や rejected に状態が変化する。\n\n状態: pending\n\nとりあえず約束してみる。\n\n\n\npendingと表示されただろう。\n\nここでの変数promiseは、Promise の状態 pending といえる。\n\n状態: fulfilled\n\n次は fulfilled の状態を作ってみる。\n\n\n\nPromise resoleved と表示されただろう。これが fulfilled である。\n\n実は状態 fulfilled は値を持つ。\n\n\n\nここでの変数promiseは、Promiseの状態 fulfilled であり、値'hello'を持つといえる。\n\n状態: rejected\n\nrejected も fulfilled と同様に値を持つ。\n\n\n\nここでの変数promiseは、Promise の状態 rejected であり、値'hello'を持つといえる。\n\nrejected で渡される値(オブジェクト)は Error オブジェクトだったりする。\n\n\n\nここでの変数promiseは、Promise の状態 rejected であり、値に Error オブジェクトを持つといえる。\n\n状態の変化\n\nPromiseでは状態が変化する。\n初期状態では pending であるが、のちに fulfilled や rejected になる。\n\n\n\n現在は同期処理を行っているので、fulfill または reject された状態に一瞬で変化してしまい、 pending の状態をみることはできない。\n\nしかし厳密にはもともとは pending で、 resolve()を実行すると fulfilled に、 reject() を実行すると rejected に、それぞれ状態が移行する。\n\nthen/catch による Promise チェーン\n\nさて、Promise には3状態あり、変化することがわかった。\n変化すると何ができるのか？ それをこの節で説明する。\n\nPromise オブジェクトのメソッドに、then と catch がある。\n\nこれらはそれぞれ第一引数に関数をとり、Promise が fulfilled や rejected の状態になると引数関数を実行する。\n\n\n\nこのように.でつないで then/catch メソッドを呼べば、それらを発火できる。\n\nさらに、then/catch メソッドの戻り値に promise を与えてやれば、更に繋げられる。\n\n\n\n上述の通り、then メソッドの戻り値に Promise を渡すと、更に後ろに.then()を繋げられる。\n(.catch()も繋げられる。)\n\nこのように、Promise が解決 (fulfill/reject) されたら.then()メソッドが発火し、\n.then()メソッドがPromiseを返すと、解決されたらさらに後ろの.then()メソッドが発火し、、、\n\nこのように数珠つなぎに徐々に Promise が渡ることを Promise チェーンと呼ぶ。\n\n\n\nここまでで Promise を学んだ。\nコールバックや Promise を使う理由は非同期関数にあるので、読者の皆様にはややこしいことをしているようにしか見えないかもしれない。\n\n本当はこのあたりで非同期関数について説明し Promise のありがたみを理解していただくのもよいのだが、この記事はあくまで「まず同期関数で理解する。」ことが目的であり、非同期関数はもう少し後回しにする。\n\n\n\nStep1-3 async/await (同期関数)\n\n次は sync/await だ。\n\nそのまえに説明すべきことが2つほどあるので補足。\n\n補足: 即時関数\n\n即時関数は定義と同時に実行する関数だ。\n関数定義を括弧でくくると即時実行される。\n\n\n\n補足: Async 関数 (asnyc function)\n\n関数定義の前にasyncとつけて定義する。\nAsnyc 関数の中でのみ await が使える。\n\n\n\n改めて async/await (同期関数)\n\n閑話休題。\n\nasync/await は Promise を生成する構文と言っていい。\n先程の then を書かずともよくなる構文である。\n\n前節の Promise のコードを再掲する。\n\n\n\nこれを async/await に書き直すと\n\n\n\nこのようになる。\nthen が消えたことがわかる。\n\n(即時実行のasync関数を使っている。)\n\n\n\nもう一つ前節のコードを再掲し async/await に書き換えてみる。\n\n\n\nasync/await に書き換えると\n\n\n\n今度は then がなくなったことで短く書けたことが伝わるのではないか。\n\nawaitが現れると、Async 関数内のawaitより後ろの部分が全てthen()の引数として包まれる、といった見方もできる。\n\n以上のように、async/await は Promise を簡潔に書く構文である。\n\n\n\n余談: Promiseは必要か?\n\nasync/awaitで簡潔にかけるなら、Promiseなんて理解しなくて良いのでは？と思う方もいるだろう。\nしかし今の所そうも行かないのだ。\n\n複数のPromiseを同時に待つ処理をasync/awaitで書いてみる。\n\n\n\nうお、Promise出てきた。。。\n\nコードの内容はおいておいて、Promise という単語が出てきたことに注目。\n解説は省くが、async/await は Promise を完全には隠しきれていないのだ。\n\n(気になる方はこの記事を読み終えてからPromise.allをみると良いだろう。\n\n\n\nStep2 非同期処理\n\nさてさて、ここまで来ればゴールは近い。\nこの節では今まで苦労して覚えた謎構文 Promise と asnyc/await のありがたみがわかるようになる。\n\nStep2-1 同期関数と非同期関数\n\n同期関数と非同期関数について説明する。\n\n同期関数とは、中の処理が完了するまで待ってから戻り値を返す関数のこと\n\n非同期関数とは、中の処理にかかわらず、すぐに戻り値を返してしまう関数のこと\n\nJavaScript の代表的な非同期関数にsetTimeOut()がある。\n\n次のようなコードで考えてみよう。\n\n\n\nJavaScript は、普通は(同期関数は)、上から順番に1行ずつ実行される。\n\nしかし上記のコードを実行するとworldが表示された後にhelloが表示される。\nこれはsetTimeOut()関数が非同期関数だからだ。\n\n書き方を少し変えてみる。\n\n\n\nさっきと同じ動作をするコードだ。\n\nコンピュータの気持ちになってみると\n\nHello 関数を定義するよ。Hello 関数は実行されたら'hello'と表示するよ。まだ定義だけで実行しないよ。\n\nsetTimeOut 関数を実行するよ。Hello 関数を 1000ms 後に実行するとを登録するよ。登録するだけで、すぐに戻り値を返すよ。\n\n'world'と表示するよ。\n\n... しばらく (1000ms) 経って ...\n\nHello 関数を実行するよ、'hello'と表示するよ。\n\nこのような順で動作する。\n同期関数はその行で処理が停止するのに対し、非同期関数はすぐに次の行が実行される。\n\nStep2-2 コールバック (非同期関数)\n\n先程の例で非同期関数を実現してるのがコールバックだ。\n\nあとで実行して欲しい関数を引数で伝えておいて、ときが来たら実行する。\n\nやりたいことはコールバックで実現できるものの、何重にも重なると次のようなコードにになってしまう。\n\n\n\nコールバック関数を呼ぶたびにネストが深くなってしまい読みづらい。\n\n俗に言うコールバック地獄である。\nたとえばこの例だと、どの秒数がどの setTimeOut に対応するのかわかりづらい。\n\n(上記の例は全て一つの setTimeOut にまとめられるが)\n実際には次のような状況が考えられる。\n\nサーバと通信して、記事のリストをとってくる。\n\n記事のリストから該当の記事を探して、再度サーバと通信して本文をとってくる。\n\nこのように、複数の非同期処理が数珠つなぎになることもあるだろう。\n\n数珠つなぎ、、、\n\nStep2-3 Promise (非同期関数)\n\nそう、数珠つなぎならさっきの Promise チェーンと相性が良い。\n\nさっきの6秒待つ処理も\n\n\n\nネストが解消されて、引数もコンパクトになって見やすくなった。\n\nStep2-4 asnyc/await (非同期関数)\n\nさらに async/awaitで書き直すと\n\n\n\nこれは見やすい！\n非同期関数を同期的に書けるようになった。\n\nawait の行で停止しているかのように動作する。\n\nさいごに\n\n本記事を読み次の2つを知れば、他の記事が格段に読みやすくなるだろう。\n\n同期処理と非同期処理の違い\n\n同期処理でPromiseがどういう動作をするか\n\nこれからは「コールバック地獄を解決するために Promise チェーンがある」「 async/await は Promise の生成だ」などと書かれた他の記事も読めるのではないだろうか。\n\nこの記事を完全に理解できなくても、 読者の皆様はこれから JavaScript の非同期処理を深める土台ができているのではないかと思う。\n\nここまでの長文に付き合いいただきありがたい。\n\n以上。\n"},{"id":"http://localhost:3000/posts/promise-then-arg2","url":"http://localhost:3000/posts/promise-then-arg2","title":"Promiseのthenメソッドには第二引数がある","summary":"この記事は以下のツイートについて。 きっかけはMDN web docsのPromiseについてのページを見ていたことに始まる。 以前、私がPromiseとaync/awaitを理解するときにとても役にたった記事があった。 Qiitaにあった記事で同期処理でPromiseをしてみて理解しようと試みる記事だったのだが、いま探しても見つからない。 需要がありそうなので自分で書いているのだが、そんな中でMDNを見ていてthenメソッドに関する発見があった。 あなたの運(実行タイミング)によってfulfilledかrejectedが表示されるコードである。 thenの第一引数は、promiseオブジェク","date_published":"2020-05-19T15:57:35+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Promise%E3%81%AEthen%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%AB%E3%81%AF%E7%AC%AC%E4%BA%8C%E5%BC%95%E6%95%B0%E3%81%8C%E3%81%82%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["JavaScript","非同期"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4b666324175c9cee2ca3d30b753b1c9187cf04d1","comment":"Add a post of promise-then-args\n","date_modified":"2020-05-19T16:35:11+09:00"}],"content_html":"<p>この記事は以下のツイートについて。</p>\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">thenメソッドって第2引数でrejectedなときに実行する関数も指定できるのか、いつもcatchばかり使っていた。</p>&mdash; けーすけ@やんまー (@yammerjp) <a href=\"https://twitter.com/yammerjp/status/1262637541028585475?ref_src=twsrc%5Etfw\">May 19, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n<p>きっかけは<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN web docsのPromiseについてのページ</a>を見ていたことに始まる。</p>\n<p>以前、私がPromiseとaync/awaitを理解するときにとても役にたった記事があった。\nQiitaにあった記事で同期処理でPromiseをしてみて理解しようと試みる記事だったのだが、いま探しても見つからない。</p>\n<p>需要がありそうなので自分で書いているのだが、そんな中でMDNを見ていてthenメソッドに関する発見があった。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>( <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">if</span>( (<span class=\"hljs-built_in\">Date</span>.now()%<span class=\"hljs-number\">2</span>) === <span class=\"hljs-number\">0</span> ){\n      resolve()\n      <span class=\"hljs-keyword\">return</span>\n    }\n    reject()\n  }, <span class=\"hljs-number\">1000</span>)\n})\n\npromise.then(\n  <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'fulfilled'</span>)},\n  <span class=\"hljs-function\">() =></span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'rejected'</span>)}\n)</code></pre>\n<p>あなたの運(実行タイミング)によってfulfilledかrejectedが表示されるコードである。</p>\n<ul>\n<li>thenの第一引数は、promiseオブジェクトがfulfilled状態になったとき(上記コードでいえば<code>resolve()</code>が実行されたとき)、実行される関数である。</li>\n</ul>\n<p>これは理解していたが次だ。</p>\n<ul>\n<li>thenの第二引数は、promiseオブジェクトがrejected状態になったとき(上記コードでいえば<code>reject()</code>が実行されたとき)、に実行される関数である。</li>\n</ul>\n<p>これは見落としていた。\nいつも<code>then(A).catch(B)</code>として拾っていたが、<code>then( A, B )</code>として書けるのだな。</p>\n<p>書けることと見やすいことは別で、今の私の感情ではcatchと書いたほうが見やすいのでは？と思うのだが、実際のところどうなのだろう。\nthenの第二引数がどれだけ使われているのか気になるところである。</p>\n<br/>\n<p>ところで、promiseの状態について、初期状態をpendingと表現し、それがfulfilledかrejectedに変化するのだが、fulfilledのことをついresolvedと表現したくなってしまう。</p>\n<p>正確にはresolvedというと、fulfilledとrejectedをどちらも指すようで、promiseが成功したときはfulfilledと表現すべきらしい。\n(resolvedと同じ意味でsettledという言葉も使われるようだ。)</p>\n<p>なるほど区別するのは良いのだが、それならよく</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, relect</span>) =></span> {})</code></pre>\n<p>と書いているのはどうなの。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\">(<span class=\"hljs-params\">fulfill, reject</span>) =></span> {})</code></pre>\n<p>と予め書いてあるほうが混乱を産まないと思うのだが。</p>\n<br/>\n<p>話がそれたが今日はPromiseのthenメソッド第二引数についてであった。\nいつも使っている文でも知らないことが隠れていたりするので、ことあるごとに正しい文献に戻ることを心がけていきたい。</p>\n","content_text":"この記事は以下のツイートについて。\n\n\n\nきっかけはMDN web docsのPromiseについてのページを見ていたことに始まる。\n\n以前、私がPromiseとaync/awaitを理解するときにとても役にたった記事があった。\nQiitaにあった記事で同期処理でPromiseをしてみて理解しようと試みる記事だったのだが、いま探しても見つからない。\n\n需要がありそうなので自分で書いているのだが、そんな中でMDNを見ていてthenメソッドに関する発見があった。\n\n\n\nあなたの運(実行タイミング)によってfulfilledかrejectedが表示されるコードである。\n\nthenの第一引数は、promiseオブジェクトがfulfilled状態になったとき(上記コードでいえばresolve()が実行されたとき)、実行される関数である。\n\nこれは理解していたが次だ。\n\nthenの第二引数は、promiseオブジェクトがrejected状態になったとき(上記コードでいえばreject()が実行されたとき)、に実行される関数である。\n\nこれは見落としていた。\nいつもthen(A).catch(B)として拾っていたが、then( A, B )として書けるのだな。\n\n書けることと見やすいことは別で、今の私の感情ではcatchと書いたほうが見やすいのでは？と思うのだが、実際のところどうなのだろう。\nthenの第二引数がどれだけ使われているのか気になるところである。\n\n\n\nところで、promiseの状態について、初期状態をpendingと表現し、それがfulfilledかrejectedに変化するのだが、fulfilledのことをついresolvedと表現したくなってしまう。\n\n正確にはresolvedというと、fulfilledとrejectedをどちらも指すようで、promiseが成功したときはfulfilledと表現すべきらしい。\n(resolvedと同じ意味でsettledという言葉も使われるようだ。)\n\nなるほど区別するのは良いのだが、それならよく\n\n\n\nと書いているのはどうなの。\n\n\n\nと予め書いてあるほうが混乱を産まないと思うのだが。\n\n\n\n話がそれたが今日はPromiseのthenメソッド第二引数についてであった。\nいつも使っている文でも知らないことが隠れていたりするので、ことあるごとに正しい文献に戻ることを心がけていきたい。\n"},{"id":"http://localhost:3000/posts/raspberry-pi-zero-setup","url":"http://localhost:3000/posts/raspberry-pi-zero-setup","title":"Raspberry Pi Zeroをモニタレスで使うためのSetup","summary":"2020/3/4のメモ。 Raspberry pi Zero を、購入後一切モニタにつなぐことなく無線LAN経由でSSHできるようセットアップする手順。 母艦は MacOS X で行っているが、SDカードへの書き込みができればなんでもよい。 肝となるのは、OSを書き込んだSDカードに次のように手を加えておくことだ。 事前に無線LANのSSIDとパスワードを記述したファイルをおく SSHを有効化する 起動前 micro SD cardのフォーマット SD Association公式サイトより、SDカードフォーマッターをダウンロードする。 ダウンロードしたSDカードフォーマッターでSDカードをフォ","date_published":"2020-05-16T01:21:46+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Raspberry%20Pi%20Zero%E3%82%92%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%AC%E3%82%B9%E3%81%A7%E4%BD%BF%E3%81%86%E3%81%9F%E3%82%81%E3%81%AESetup,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["RaspberryPi"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/8c87df65101c79604bfdd986be0dc77f7a8b26f0","comment":"Add post\n","date_modified":"2020-05-16T01:26:34+09:00"}],"content_html":"<p>2020/3/4のメモ。\nRaspberry pi Zero を、購入後一切モニタにつなぐことなく無線LAN経由でSSHできるようセットアップする手順。</p>\n<p>母艦は MacOS X で行っているが、SDカードへの書き込みができればなんでもよい。</p>\n<p>肝となるのは、OSを書き込んだSDカードに次のように手を加えておくことだ。</p>\n<ul>\n<li>事前に無線LANのSSIDとパスワードを記述したファイルをおく</li>\n<li>SSHを有効化する</li>\n</ul>\n<h2>起動前</h2>\n<h3>micro SD cardのフォーマット</h3>\n<p><a href=\"https://www.sdcard.org/jp/downloads/formatter_4/\">SD Association公式サイト</a>より、SDカードフォーマッターをダウンロードする。</p>\n<p>ダウンロードしたSDカードフォーマッターでSDカードをフォーマットする。</p>\n<p>( FAT, FAT32, exFAT)。 4GB以上(要出典)。</p>\n<h3>OSイメージのダウンロード</h3>\n<p><a href=\"https://www.raspberrypi.org/downloads/raspbian/\">raspberry pi公式サイト</a>からraspbianをダウンロードする。</p>\n<p>ここではGUIが必要ないので、[Raspbian Buster Lite]のzipをダウンロードする。</p>\n<h3>OSイメージの書き込み</h3>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># ダウンロードしたzipを展開してimgファイルを得る</span>\n$ unzip 2020-02-13-raspbian-buster-lite.zip\n\n<span class=\"hljs-comment\"># デバイスを確認</span>\n$ diskutil list\n\n<span class=\"hljs-comment\"># フォーマット済みの書き込み先デバイス(ここでは/dev/disk2)をunmount</span>\n$ diskutil unMountDisk /dev/disk2\n\n<span class=\"hljs-comment\"># 書き込み</span>\n$ sudo dd bs=1m <span class=\"hljs-keyword\">if</span>=2020-02-13-raspbian-buster-lite.img of=/dev/disk2</code></pre>\n<h3>wifiの事前設定とsshの有効化</h3>\n<p>書き込み後のSDカードのbootドライブをマウントする。(/Volumes/boot)</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> /Volumes/boot\n<span class=\"hljs-comment\"># bootドライブちょっかいsshという名前のファイルが有ると、初期状態でsshが起動する</span>\n$ touch ssh\n\n<span class=\"hljs-comment\"># wifi設定を書き込む</span>\n$ vim wpa_supplicant.conf</code></pre>\n<p><code>wpa_supplicant.conf</code>の中身は以下の通り</p>\n<div class=\"remark-code-title\">wpa_supplicant.conf</div>\n<pre><code class=\"hljs language-plaintext\">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\ncountry=JP\n\nnetwork={\n        ssid=\"接続先アクセスポイントのSSID\"\n        psk=\"接続先アクセスポイントのパスワード\"\n}</code></pre>\n<h2>起動</h2>\n<p>micro SDカードを差し込み、PWRと書かれた方のmicro USB Bポートに電源ケーブルをつなぐと起動する。</p>\n<h3>ipアドレスとmacアドレスの確認とDHCPリースの固定</h3>\n<p>起動すると、自動でwifiに接続して22版ポートが開いてsshが立ち上がる(少し時間がかかる)</p>\n<p>ルータの設定画面などをみて、新しく接続されたデバイスに注目する。raspberry piっぽい端末のmacアドレスを見つける。</p>\n<p>DHCPリースを固定にして、このMACアドレスに対応するIPアドレスをわかりやすいものに固定しておく</p>\n<h3>sshで接続</h3>\n<p><strong>クライアント側</strong></p>\n<pre><code class=\"hljs language-sh\">$ ssh pi@192.168.0.13\n<span class=\"hljs-comment\"># raspberry pi のIPアドレスを指定(ここでは 192.168.0.13 であるとする)</span>\n<span class=\"hljs-comment\"># デフォルトのIDは pi</span>\n<span class=\"hljs-comment\"># デフォルトのパスワードは raspberry</span></code></pre>\n<h3>設定</h3>\n<p><strong>raspberry pi側</strong></p>\n<pre><code># visudoでnanoではなくvimを立ち上げる\n# 参考: https://qiita.com/koara-local/items/35b999631b6ab41fdc9f\n$ sudo update-alternatives --config editor\n\n# vimをエイリアスとして登録\n$ vim ~/.bashrc\n</code></pre>\n<p><code>.bashrc</code>に下記を追記</p>\n<div class=\"remark-code-title\">.bashrc</div>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">alias</span> vim=<span class=\"hljs-string\">'vi'</span></code></pre>\n<p>変更を読み込む</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-built_in\">source</span> ~/.bashrc</code></pre>\n<h2>sshの設定</h2>\n<h3>ssh用ユーザの作成</h3>\n<p><strong>raspberry pi側</strong></p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># yammerというユーザを作るとする</span>\n$ sudo useradd yammer\n$ sudo passwd yammer\n$ sudo visudo</code></pre>\n<p>visudoによって、<code>/etc/sudoers</code>に下記を追記</p>\n<div class=\"remark-code-title\">/etc/sudoers</div>\n<pre><code class=\"hljs language-plaintext\">yammer  ALL=(ALL) ALL</code></pre>\n<h3>ssh用公開鍵の作成</h3>\n<p>ssh用の公開鍵を作る。</p>\n<p><strong>クライアント側</strong></p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> ~/.ssh\n$ ssh-keygen -t rsa -b 4096 -C <span class=\"hljs-string\">\"raspberry-pi\"</span> -f ~/.ssh/id_rsa_pi</code></pre>\n<h3>sshのパーミッションを設定</h3>\n<p><strong>raspberry pi側</strong></p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> /home/yammer\n$ chmod 700 .ssh\n$ chmod 600 .ssh/authorized_keys</code></pre>\n<h3>ssh公開鍵を送る</h3>\n<p><strong>クライアント側</strong></p>\n<pre><code class=\"hljs language-sh\">$ scp ~/.ssh/id_rsa_pi.pub yammer@192.168.0.13:/home/yammer/.ssh/authorized_keys</code></pre>\n<h3>ssh設定</h3>\n<p><strong>raspberry pi側</strong></p>\n<pre><code class=\"hljs language-sh\">$ sudo vi /etc/ssh/sshd_config</code></pre>\n<div class=\"remark-code-title\">/etc/ssh/sshd_config</div>\n<pre><code class=\"hljs language-plaintext\">RSAAuthentication   yes\nPubkeyAuthentication   yes\nAuthorizedKeysFile   .ssh/authorized_keys\nAllowUsers yammer # ユーザ名を追加</code></pre>\n<pre><code class=\"hljs language-sh\">$ sudo /etc/init.d/sshd restart</code></pre>\n<h3>接続できるか確認</h3>\n<p><strong>クライアント側</strong></p>\n<pre><code>$ ssh -i ~/.ssh/id_rsa_pi yammer@192.168.0.13\n</code></pre>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://qiita.com/tattn/items/a03cbf7c185d7efa6769\">SSH用のユーザー追加手順と注意点のまとめ - Qiita</a></li>\n</ul>\n","content_text":"2020/3/4のメモ。\nRaspberry pi Zero を、購入後一切モニタにつなぐことなく無線LAN経由でSSHできるようセットアップする手順。\n\n母艦は MacOS X で行っているが、SDカードへの書き込みができればなんでもよい。\n\n肝となるのは、OSを書き込んだSDカードに次のように手を加えておくことだ。\n\n事前に無線LANのSSIDとパスワードを記述したファイルをおく\n\nSSHを有効化する\n\n起動前\n\nmicro SD cardのフォーマット\n\nSD Association公式サイトより、SDカードフォーマッターをダウンロードする。\n\nダウンロードしたSDカードフォーマッターでSDカードをフォーマットする。\n\n( FAT, FAT32, exFAT)。 4GB以上(要出典)。\n\nOSイメージのダウンロード\n\nraspberry pi公式サイトからraspbianをダウンロードする。\n\nここではGUIが必要ないので、\\[Raspbian Buster Lite]のzipをダウンロードする。\n\nOSイメージの書き込み\n\n\n\nwifiの事前設定とsshの有効化\n\n書き込み後のSDカードのbootドライブをマウントする。(/Volumes/boot)\n\n\n\nwpa_supplicant.confの中身は以下の通り\n\n\n\n起動\n\nmicro SDカードを差し込み、PWRと書かれた方のmicro USB Bポートに電源ケーブルをつなぐと起動する。\n\nipアドレスとmacアドレスの確認とDHCPリースの固定\n\n起動すると、自動でwifiに接続して22版ポートが開いてsshが立ち上がる(少し時間がかかる)\n\nルータの設定画面などをみて、新しく接続されたデバイスに注目する。raspberry piっぽい端末のmacアドレスを見つける。\n\nDHCPリースを固定にして、このMACアドレスに対応するIPアドレスをわかりやすいものに固定しておく\n\nsshで接続\n\nクライアント側\n\n\n\n設定\n\nraspberry pi側\n\n\n\n.bashrcに下記を追記\n\n\n\n変更を読み込む\n\n\n\nsshの設定\n\nssh用ユーザの作成\n\nraspberry pi側\n\n\n\nvisudoによって、/etc/sudoersに下記を追記\n\n\n\nssh用公開鍵の作成\n\nssh用の公開鍵を作る。\n\nクライアント側\n\n\n\nsshのパーミッションを設定\n\nraspberry pi側\n\n\n\nssh公開鍵を送る\n\nクライアント側\n\n\n\nssh設定\n\nraspberry pi側\n\n\n\n接続できるか確認\n\nクライアント側\n\n\n\n参考\n\nSSH用のユーザー追加手順と注意点のまとめ - Qiita\n"},{"id":"http://localhost:3000/posts/vim-intro","url":"http://localhost:3000/posts/vim-intro","title":"Vimに入門したときの覚書","summary":"昨年、Vimを使える人間になりたいという気持ちからVimに入門した。 まずvimtutorをやり、またVim以外のエディタを使うことを禁止して慣れるようにした。 vimtuorのあとは実践Vimを読んだりしながら日常使いの中でVimに慣れていった。 また基本的にプラグインを追加することを禁止し、不用意な.vimrcの編集も禁止して、素の状態のVimに慣れるように気を配っていた。 そんなこんなでVimに慣れようとしていたわけだが、最初期vimtutorをやるだけではなかなかキーバインドが覚えられず、とても編集速度が遅かったので、同時にメモに書き出すことで覚えていたようである。 このときのメモをこ","date_published":"2020-05-16T01:07:44+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Vim%E3%81%AB%E5%85%A5%E9%96%80%E3%81%97%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AE%E8%A6%9A%E6%9B%B8,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Vim"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/419545d6e9024462bcbe6cd0d8addfa5b5f8895e","comment":"Add posts\n","date_modified":"2020-05-16T01:17:36+09:00"}],"content_html":"<p>昨年、Vimを使える人間になりたいという気持ちからVimに入門した。</p>\n<p>まずvimtutorをやり、またVim以外のエディタを使うことを禁止して慣れるようにした。\nvimtuorのあとは<a href=\"https://www.amazon.co.jp/dp/B00HWLJI3U/ref=dp-kindle-redirect?_encoding=UTF8&#x26;btkr=1\">実践Vim</a>を読んだりしながら日常使いの中でVimに慣れていった。\nまた基本的にプラグインを追加することを禁止し、不用意な<code>.vimrc</code>の編集も禁止して、素の状態のVimに慣れるように気を配っていた。</p>\n<p>そんなこんなでVimに慣れようとしていたわけだが、最初期vimtutorをやるだけではなかなかキーバインドが覚えられず、とても編集速度が遅かったので、同時にメモに書き出すことで覚えていたようである。</p>\n<p>このときのメモをここに供養する。書いた日付は2019/10/28。</p>\n<hr/>\n<h2>Vim :help 日本語化</h2>\n<p>まず次のコマンドを実行</p>\n<pre><code>% curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n</code></pre>\n<p>次に<code>~/.vimrc</code>に次の内容を追記</p>\n<div class=\"remark-code-title\">.vimrc</div>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-keyword\">call</span> plug#begin(<span class=\"hljs-string\">'~/.vim/plugged'</span>)\n<span class=\"hljs-comment\">\" A project which translate Vim documents into Japanese.</span>\nPlug <span class=\"hljs-string\">'vim-jp/vimdoc-ja'</span>\n<span class=\"hljs-keyword\">call</span> plug#end()\n\n<span class=\"hljs-keyword\">set</span> helplang=ja,<span class=\"hljs-keyword\">en</span></code></pre>\n<p>次にVimを立ち上げて<code>:PlugInstall</code>と入力しプラグインをインストールする</p>\n<p>参考: <a href=\"https://qiita.com/issuy/items/919d76ac1b94dc56a77e\">Vimをちゃんと知りたい！だからHelpを日本語化する！</a></p>\n<h2>.vimrcを無視する</h2>\n<p>.vimrcを書き換えて起動しなくなったら</p>\n<pre><code class=\"hljs language-sh\">$ vim -u NONE -N\n<span class=\"hljs-comment\"># -u None ... .vimrcを読み込まない vi互換モードにする</span>\n<span class=\"hljs-comment\"># -N ...(nocompatible) vi互換モードをオフにする</span></code></pre>\n<h2>. 直前の操作を繰り返す</h2>\n<h3>ノーマルモード</h3>\n<p>直前のコマンドを繰り返す(カーソル移動はコマンドとみなされない) (ex.<code>x</code>, <code>dd</code>, <code>>G</code>)</p>\n<h3>インサートモード</h3>\n<p>挿入モードに入った瞬間(<code>i</code>を押す等)からノーマルモードに戻る(<code>&#x3C;Esc></code>を押す)までの間のキーストロークが記録されている<br>\n.を押すことでこの一連の流れを再生できる</p>\n<h2>移動</h2>\n<ul>\n<li><code>h</code> ... ←</li>\n<li><code>j</code> ... ↓</li>\n<li><code>k</code> ... ↑</li>\n<li><code>l</code> ... →</li>\n<li><code>$</code> ... 行末に移動</li>\n<li><code>w</code> ... 次の単語へ移動</li>\n<li><code>gg</code> ... ファイル先頭へ移動</li>\n<li><code>G</code> ... ファイル末尾へ移動</li>\n<li><code>{数字}G</code> ... {数字}行目に移動</li>\n<li><code>&#x3C;Ctrl>G</code> ... 現在のカーソル行を表示</li>\n<li><code>>G</code> ... 現在の行からファイル末尾までのインデントを1段深くする</li>\n</ul>\n<h2>基本操作</h2>\n<ul>\n<li><code>x</code> ... カーソル下の文字を削除</li>\n<li><code>dd</code> ... 行頭から行末まで削除</li>\n<li><code>i</code> ... インサートモードへ切り替え</li>\n<li><code>a</code> ... カーソルの右隣でインサートモードへ切り替え</li>\n<li><code>A</code> ... 行末に移動してインサートモードに切り替え</li>\n<li><code>o</code> ... 次行を作りインサートモードへ</li>\n<li><code>O</code> ... 前行を作りインサートモードへ</li>\n<li><code>u</code> ... アンドゥ 戻る</li>\n<li><code>U</code> ... 行単位でアンドゥ 戻る</li>\n<li><code>&#x3C;Ctrl>R</code> ... リドゥ　戻るの取り消し</li>\n<li><code>0</code> ... 行頭へ移動</li>\n<li><code>p</code> ... 貼り付け (削除したものを貼り付け 例えば<code>dd</code>コマンドで削除した行等</li>\n<li><code>r</code> ... 置き換え カーソル下の文字を一文字消して次に入力した一文字で置き換える。なお置き換え後もノーマルモードを維持する</li>\n<li><code>R</code> ... 置換モード カーソル下を上書きして文字を挿入する escキーでノーマルモードに戻る</li>\n<li><code>%</code> ... 対応する括弧へ移動</li>\n<li><code>yy</code> ... 行をヤンク</li>\n<li><code>yw</code> ... カーソル後ろの空白を含む単語をヤンク</li>\n</ul>\n<h2>モーション操作</h2>\n<h3><code>d</code></h3>\n<p>ノーマルモードでモーション操作を行うとカーソル移動</p>\n<p><code>d{モーション}</code>を行うと現カーソルからモーション先まで削除</p>\n<p><code>d{数字}{モーション}</code>ないし<code>{数字}d{モーション}</code>は等価で、数字個先のモーションの差示す場所まで削除する</p>\n<h3><code>e</code></h3>\n<p><code>c{モーション}</code>を行うと、現カーソルからモーション先まで削除して挿入モードに切り替え</p>\n<h3>モーション</h3>\n<ul>\n<li><code>w</code> ... 空白を含む単語尾</li>\n<li><code>e</code> ... 空白を含まない単語尾</li>\n<li><code>$</code> ... 行末</li>\n</ul>\n<h2>コマンド</h2>\n<h3>終了</h3>\n<ul>\n<li><code>:q!</code> ... 内容を破棄して終了</li>\n<li><code>:wq</code> ... 内容を保存して終了</li>\n</ul>\n<h3>書き込み</h3>\n<ul>\n<li><code>:w filename</code> ... ファイルfilenameへ書き込み</li>\n</ul>\n<h3>検索</h3>\n<ul>\n<li><code>/hoge</code> ... hogeを前方検索</li>\n<li><code>?hoge</code> ... hogeを逆方向に検索</li>\n<li>(検索した状態で)<code>n</code> ... 次を検索</li>\n<li>(検索した状態で)<code>&#x3C;Ctrl>o</code> ... 一つ前の検索結果に戻る</li>\n</ul>\n<h3>置換</h3>\n<ul>\n<li><code>:s/before/after</code> ... カーソル行の１つ目のbeforeをafterへ置換</li>\n<li><code>:s/before/after/g</code> ... カーソル行の全てのbeforeをafterへ置換</li>\n<li><code>:3,5s/before/after/g</code> ... 3行目から5行目の全てのbeforeをafterへ置換</li>\n<li><code>:%s/before/after/g</code> ... ファイル内全てのbeforeをafterへ置換</li>\n<li><code>:%s/before/after/gc</code> ... ファイル内全てのbeforeを都度確認しながらafterへ置換</li>\n</ul>\n<h3>検索/置換のオプション</h3>\n<ul>\n<li><code>:set ic</code> ... 検索時に大文字小文字を区別しない(ignorecase)</li>\n<li><code>:set is</code> ... 検索フレーズに部分マッチしている部分を表示する(incsearch)</li>\n<li><code>:set hls</code> ... マッチする全てを強調表示する(hlsearch)</li>\n</ul>\n<h3>ターミナルコマンド実行</h3>\n<ul>\n<li><code>:!ls</code> ... lsを実行(のちエンターでvimに戻る)</li>\n</ul>\n<h3>挿入</h3>\n<ul>\n<li><code>:r filename</code> ... filenameの内容をカーソル位置へ挿入</li>\n<li><code>:r !ls</code> ... lsの結果をカーソル位置へ挿入</li>\n</ul>\n<h3>help</h3>\n<ul>\n<li><code>:help</code> ... helpウィンドウを開く</li>\n<li><code>:help hoge</code> ... hogeに関するhelpを見る</li>\n</ul>\n<h3>候補と保管</h3>\n<ul>\n<li><code>:e&#x3C;TAB></code> ... eから始まるコマンドを補完</li>\n<li><code>:e&#x3C;Ctrl>d</code> ... eから始まるコマンドを一覧表示</li>\n</ul>\n<h2>visualモード</h2>\n<ul>\n<li><code>v</code> ... visualモードへ切り替え カーソルを移動させると、visualモード移行時のカーソルとの間が反転し選択される</li>\n<li>(visualモードで短形選択時)<code>:'&#x3C;,'>w filename</code>(<code>'&#x3C;,'></code>は自動で入力される) ... 短形選択部分をfilenameへ書き出し</li>\n<li>(visualモードで短形選択時)<code>y</code> ... ヤンク(コピー)</li>\n</ul>\n","content_text":"昨年、Vimを使える人間になりたいという気持ちからVimに入門した。\n\nまずvimtutorをやり、またVim以外のエディタを使うことを禁止して慣れるようにした。\nvimtuorのあとは実践Vimを読んだりしながら日常使いの中でVimに慣れていった。\nまた基本的にプラグインを追加することを禁止し、不用意な.vimrcの編集も禁止して、素の状態のVimに慣れるように気を配っていた。\n\nそんなこんなでVimに慣れようとしていたわけだが、最初期vimtutorをやるだけではなかなかキーバインドが覚えられず、とても編集速度が遅かったので、同時にメモに書き出すことで覚えていたようである。\n\nこのときのメモをここに供養する。書いた日付は2019/10/28。\n\n\n\nVim :help 日本語化\n\nまず次のコマンドを実行\n\n\n\n次に\\~/.vimrcに次の内容を追記\n\n\n\n次にVimを立ち上げて:PlugInstallと入力しプラグインをインストールする\n\n参考: Vimをちゃんと知りたい！だからHelpを日本語化する！\n\n.vimrcを無視する\n\n.vimrcを書き換えて起動しなくなったら\n\n\n\n. 直前の操作を繰り返す\n\nノーマルモード\n\n直前のコマンドを繰り返す(カーソル移動はコマンドとみなされない) (ex.x, dd, >G)\n\nインサートモード\n\n挿入モードに入った瞬間(iを押す等)からノーマルモードに戻る(\\<Esc>を押す)までの間のキーストロークが記録されている\n.を押すことでこの一連の流れを再生できる\n\n移動\n\nh ... ←\n\nj ... ↓\n\nk ... ↑\n\nl ... →\n\n$ ... 行末に移動\n\nw ... 次の単語へ移動\n\ngg ... ファイル先頭へ移動\n\nG ... ファイル末尾へ移動\n\n{数字}G ... {数字}行目に移動\n\n\\<Ctrl>G ... 現在のカーソル行を表示\n\n\\>G ... 現在の行からファイル末尾までのインデントを1段深くする\n\n基本操作\n\nx ... カーソル下の文字を削除\n\ndd ... 行頭から行末まで削除\n\ni ... インサートモードへ切り替え\n\na ... カーソルの右隣でインサートモードへ切り替え\n\nA ... 行末に移動してインサートモードに切り替え\n\no ... 次行を作りインサートモードへ\n\nO ... 前行を作りインサートモードへ\n\nu ... アンドゥ 戻る\n\nU ... 行単位でアンドゥ 戻る\n\n\\<Ctrl>R ... リドゥ　戻るの取り消し\n\n0 ... 行頭へ移動\n\np ... 貼り付け (削除したものを貼り付け 例えばddコマンドで削除した行等\n\nr ... 置き換え カーソル下の文字を一文字消して次に入力した一文字で置き換える。なお置き換え後もノーマルモードを維持する\n\nR ... 置換モード カーソル下を上書きして文字を挿入する escキーでノーマルモードに戻る\n\n% ... 対応する括弧へ移動\n\nyy ... 行をヤンク\n\nyw ... カーソル後ろの空白を含む単語をヤンク\n\nモーション操作\n\nd\n\nノーマルモードでモーション操作を行うとカーソル移動\n\nd{モーション}を行うと現カーソルからモーション先まで削除\n\nd{数字}{モーション}ないし{数字}d{モーション}は等価で、数字個先のモーションの差示す場所まで削除する\n\ne\n\nc{モーション}を行うと、現カーソルからモーション先まで削除して挿入モードに切り替え\n\nモーション\n\nw ... 空白を含む単語尾\n\ne ... 空白を含まない単語尾\n\n$ ... 行末\n\nコマンド\n\n終了\n\n:q! ... 内容を破棄して終了\n\n:wq ... 内容を保存して終了\n\n書き込み\n\n:w filename ... ファイルfilenameへ書き込み\n\n検索\n\n/hoge ... hogeを前方検索\n\n?hoge ... hogeを逆方向に検索\n\n(検索した状態で)n ... 次を検索\n\n(検索した状態で)\\<Ctrl>o ... 一つ前の検索結果に戻る\n\n置換\n\n:s/before/after ... カーソル行の１つ目のbeforeをafterへ置換\n\n:s/before/after/g ... カーソル行の全てのbeforeをafterへ置換\n\n:3,5s/before/after/g ... 3行目から5行目の全てのbeforeをafterへ置換\n\n:%s/before/after/g ... ファイル内全てのbeforeをafterへ置換\n\n:%s/before/after/gc ... ファイル内全てのbeforeを都度確認しながらafterへ置換\n\n検索/置換のオプション\n\n:set ic ... 検索時に大文字小文字を区別しない(ignorecase)\n\n:set is ... 検索フレーズに部分マッチしている部分を表示する(incsearch)\n\n:set hls ... マッチする全てを強調表示する(hlsearch)\n\nターミナルコマンド実行\n\n:!ls ... lsを実行(のちエンターでvimに戻る)\n\n挿入\n\n:r filename ... filenameの内容をカーソル位置へ挿入\n\n:r !ls ... lsの結果をカーソル位置へ挿入\n\nhelp\n\n:help ... helpウィンドウを開く\n\n:help hoge ... hogeに関するhelpを見る\n\n候補と保管\n\n:e\\<TAB> ... eから始まるコマンドを補完\n\n:e\\<Ctrl>d ... eから始まるコマンドを一覧表示\n\nvisualモード\n\nv ... visualモードへ切り替え カーソルを移動させると、visualモード移行時のカーソルとの間が反転し選択される\n\n(visualモードで短形選択時):'<,'>w filename('<,'>は自動で入力される) ... 短形選択部分をfilenameへ書き出し\n\n(visualモードで短形選択時)y ... ヤンク(コピー)\n"},{"id":"http://localhost:3000/posts/my-type-of-typescript","url":"http://localhost:3000/posts/my-type-of-typescript","title":"TypeScriptでプロジェクト内独自の型定義をまとめたファイルを読み込ませる方法。","summary":"TypeScriptでプロジェクト内の型定義をするときのための過去のメモをここに供養する。 日付は2020/1/10。 やりたいこと TypeScriptで、独自の型定義をプロジェクト内の複数のファイルで利用したい。 src/types/index.d.tsで定義する型DayOfWeekをはじめとして、src/typesディレクトリ以下のファイルにある型定義をTypeScriptコンパイラに読み込ませて、プロジェクト内の任意のファイルで利用できるようにする。 方法 tsconfig.jsonに次を追記する tsconfig.json内でのcompilerOptions.typeRootsは文字","date_published":"2020-05-16T01:01:45+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:TypeScript%E3%81%A7%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%86%85%E7%8B%AC%E8%87%AA%E3%81%AE%E5%9E%8B%E5%AE%9A%E7%BE%A9%E3%82%92%E3%81%BE%E3%81%A8%E3%82%81%E3%81%9F%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BE%E3%81%9B%E3%82%8B%E6%96%B9%E6%B3%95%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["TypeScript"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/8c87df65101c79604bfdd986be0dc77f7a8b26f0","comment":"Add post\n","date_modified":"2020-05-16T01:26:34+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/419545d6e9024462bcbe6cd0d8addfa5b5f8895e","comment":"Add posts\n","date_modified":"2020-05-16T01:17:36+09:00"}],"content_html":"<p>TypeScriptでプロジェクト内の型定義をするときのための過去のメモをここに供養する。\n日付は2020/1/10。</p>\n<h2>やりたいこと</h2>\n<p>TypeScriptで、独自の型定義をプロジェクト内の複数のファイルで利用したい。</p>\n<p><code>src/types/index.d.ts</code>で定義する型<code>DayOfWeek</code>をはじめとして、<code>src/types</code>ディレクトリ以下のファイルにある型定義をTypeScriptコンパイラに読み込ませて、プロジェクト内の任意のファイルで利用できるようにする。</p>\n<div class=\"remark-code-title\">src/types/index.d.ts</div>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">type</span> DayOfWeek = <span class=\"hljs-string\">\"Sunday\"</span> | <span class=\"hljs-string\">\"Monday\"</span> | <span class=\"hljs-string\">\"Tuesday\"</span> | Wednesday<span class=\"hljs-string\">\" | \"</span>Tursday<span class=\"hljs-string\">\" | \"</span>Friday<span class=\"hljs-string\">\" | Saturday\"</span>; </code></pre>\n<h2>方法</h2>\n<p><code>tsconfig.json</code>に次を追記する</p>\n<div class=\"remark-code-title\">tsconfig.json</div>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-attr\">\"typeRoots\"</span>: [\n      <span class=\"hljs-string\">\"node_modules/@types\"</span>,\n      <span class=\"hljs-string\">\"src/types\"</span>\n    ]\n  }\n}</code></pre>\n<p><code>tsconfig.json</code>内での<code>compilerOptions.typeRoots</code>は文字列の配列をおく。</p>\n<p>文字列は型定義ファイルを置くディレクトリのパスを表す。</p>\n<p>もともと、npmでインストールしたパッケージの型定義は<code>node_modules/@types</code>以下に配置され、<code>compilerOptions.typeRoots</code>が定義されていないときはデフォルトで読み込まれる。</p>\n<p><code>compilerOptions.typeRoots</code>を記述する際には、自分の定義したい型ファイルのディレクトリと合わせて、デフォルトで読み込まれる型定義ファイルのパスも記述する必要がある。</p>\n<h2>発展して</h2>\n<p>逆に、インストールした型定義を無視したい時は、<code>compilerOptions.typeRoots</code>に<code>node_modules/@types</code>を除いて記述すれば良い。</p>\n<p>使うシチュエーションはあまりないかもしれないが。</p>\n<h2>感想</h2>\n<p>TypeScriptは毎回完全理解()しているので、チョットデキル人間になるために一度ちゃんと学び直す必要がありそう。</p>\n<p>(この項目はメモをここに移したときに書いた)</p>\n","content_text":"TypeScriptでプロジェクト内の型定義をするときのための過去のメモをここに供養する。\n日付は2020/1/10。\n\nやりたいこと\n\nTypeScriptで、独自の型定義をプロジェクト内の複数のファイルで利用したい。\n\nsrc/types/index.d.tsで定義する型DayOfWeekをはじめとして、src/typesディレクトリ以下のファイルにある型定義をTypeScriptコンパイラに読み込ませて、プロジェクト内の任意のファイルで利用できるようにする。\n\n\n\n方法\n\ntsconfig.jsonに次を追記する\n\n\n\ntsconfig.json内でのcompilerOptions.typeRootsは文字列の配列をおく。\n\n文字列は型定義ファイルを置くディレクトリのパスを表す。\n\nもともと、npmでインストールしたパッケージの型定義はnode_modules/@types以下に配置され、compilerOptions.typeRootsが定義されていないときはデフォルトで読み込まれる。\n\ncompilerOptions.typeRootsを記述する際には、自分の定義したい型ファイルのディレクトリと合わせて、デフォルトで読み込まれる型定義ファイルのパスも記述する必要がある。\n\n発展して\n\n逆に、インストールした型定義を無視したい時は、compilerOptions.typeRootsにnode_modules/@typesを除いて記述すれば良い。\n\n使うシチュエーションはあまりないかもしれないが。\n\n感想\n\nTypeScriptは毎回完全理解()しているので、チョットデキル人間になるために一度ちゃんと学び直す必要がありそう。\n\n(この項目はメモをここに移したときに書いた)\n"},{"id":"http://localhost:3000/posts/telnet-http","url":"http://localhost:3000/posts/telnet-http","title":"TELNETでHTTP通信する","summary":"TELNETでHTTP通信するだけの記事である。 すぐ終わる。 相手ホストやポート番号、手書きのHTTPヘッダを渡せば、 TELNET で HTTP 通信ができる。 IPv6でつないでくれている。 あいにく memo.yammer.jp は HTTP をリダイレクトしてしまうのでページの内容は取得できなかったが、通信できた。 たまには HTTP ヘッダを手書きしてみるのも趣があるのではなかろうか。(??) 以上。 ","date_published":"2020-05-16T00:43:55+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:TELNET%E3%81%A7HTTP%E9%80%9A%E4%BF%A1%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Shell","HTTP"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/95288fd84531f6946852261ba69cf82ab2f6db52","comment":"Add article\n","date_modified":"2020-05-16T00:51:49+09:00"}],"content_html":"<p>TELNETでHTTP通信するだけの記事である。\nすぐ終わる。</p>\n<p>相手ホストやポート番号、手書きのHTTPヘッダを渡せば、 TELNET で HTTP 通信ができる。</p>\n<pre><code class=\"hljs language-sh\">$ telnet memo.yammer.jp 80\nTrying 2400:6180:0:d1::4df:d001...\nConnected to memo-basd4g-net.netlify.com.\nEscape character is <span class=\"hljs-string\">'^]'</span>.\nGET / HTTP/1.1\nHost: memo.yammer.jp\nConnection: close\n\nHTTP/1.1 301 Moved Permanently\nCache-Control: public, max-age=0, must-revalidate\nContent-Length: 40\nContent-Type: text/plain\nDate: Fri, 15 May 2020 15:46:22 GMT\nLocation: https://memo.yammer.jp/\nAge: 2\nConnection: close\nServer: Netlify\nX-NF-Request-ID: e38b7b4a-47e9-4306-8d60-e917e96c78cd-2547281\n\nRedirecting to https://memo.yammer.jp/\nConnection closed by foreign host.</code></pre>\n<p>IPv6でつないでくれている。</p>\n<p>あいにく memo.yammer.jp は HTTP をリダイレクトしてしまうのでページの内容は取得できなかったが、通信できた。</p>\n<p>たまには HTTP ヘッダを手書きしてみるのも趣があるのではなかろうか。(??)</p>\n<p>以上。</p>\n","content_text":"TELNETでHTTP通信するだけの記事である。\nすぐ終わる。\n\n相手ホストやポート番号、手書きのHTTPヘッダを渡せば、 TELNET で HTTP 通信ができる。\n\n\n\nIPv6でつないでくれている。\n\nあいにく memo.yammer.jp は HTTP をリダイレクトしてしまうのでページの内容は取得できなかったが、通信できた。\n\nたまには HTTP ヘッダを手書きしてみるのも趣があるのではなかろうか。(??)\n\n以上。\n"},{"id":"http://localhost:3000/posts/internet-tcpip","url":"http://localhost:3000/posts/internet-tcpip","title":"インターネットとTCP/IP","summary":"今日のインターネットの根幹をなすTCP/IPについての基本的な知識を説明する。 研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけ。 参考文献: マスタリングTCP/IP入門編 第二章 pp60-80 インターネット 今この文章もインターネットに公開され、インターネットを介して見ていることと思うが、インターネットとはそもそも何を指すのか。 Internet / The Internet とは、TCP/IPにより全世界を接続しているコンピュータネットワーク、ただ一つのことを指す。 語源は「複数のネットワークを結ぶ」ことを表す internet。 現在ではこの意味は inte","date_published":"2020-05-15T23:37:00+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88%E3%81%A8TCP%2FIP,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["インターネット","TCP/IP"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>今日のインターネットの根幹をなすTCP/IPについての基本的な知識を説明する。</p>\n<p>研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけ。</p>\n<ul>\n<li>参考文献: マスタリングTCP/IP入門編 第二章 pp60-80</li>\n</ul>\n<h2>インターネット</h2>\n<p>今この文章もインターネットに公開され、インターネットを介して見ていることと思うが、インターネットとはそもそも何を指すのか。</p>\n<p>Internet / The Internet とは、TCP/IPにより全世界を接続しているコンピュータネットワーク、ただ一つのことを指す。</p>\n<p>語源は「複数のネットワークを結ぶ」ことを表す internet。\n現在ではこの意味は internet ではなく internetworking という言葉で表される。</p>\n<h3>インターネットの構造</h3>\n<p>インターネットは、小さなネットワークが相互接続し1つのネットワークを成し、これが複数接続して大きなネットワークを成し、、のように階層的な構造をもつ。</p>\n<p>ISP (Internet Service Provider) のネットワーク内では、NOC (Network Operation Center) と呼ばれる施設を通じて接続し、ネットワークを構成している。\nISP 同士の接続には、2者間接続を行うプライベートピアリングや、多数の ISP を IX (Internet Exchange) を通じてつなぐ IP トランジットがある。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-internet-construction.png\" alt=\"インターネットの構造\"></p>\n<p>画像はインターネットの構造を表した図。</p>\n<p>ISP 以外にも有志で運営される地域ネットといわれるネットワークも存在すると本に記載があるが、2020年現在の実態は不明。\n過去にあった地域ネットとして<a href=\"https://ja.wikipedia.org/wiki/%E6%9F%8F%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88%E3%83%A6%E3%83%8B%E3%82%AA%E3%83%B3\">柏インターネットユニオン</a>などがあるようだ。</p>\n<h2>TCP/IP</h2>\n<p>TCP/IP とは、パケット交換プロトコルである IP (Internet Protocol) を利用したり、 IP で通信したりするときに必要なプロトコル群の総称のことである。\nインターネットで必要なプロトコルをまとめたものであることから、インターネットプロトコルスイートとも言われる。\nTCP/IP という語を使うとき、 TCP プロトコルと IP プロトコルだけを指しているわけではない。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-internet-protocol-suite.png\" alt=\"TCP/IP に含むプロトコルの一例\"></p>\n<h3>パケット交換ネットワーク</h3>\n<p>先程出てきたパケット交換について。\nパケット交換ネットワークとは、電話に用いられるような回線交換型と対比されるネットワークの形式である。</p>\n<p>一つの回線を複数が共有して使う。\n代表的な利点として、回線の利用効率を高められること、分散型のネットワークの構築に向くことが挙げられる。</p>\n<h3>TCP/IP の歴史</h3>\n<p>1960年代、米国防総省 (The Depertment of Defense) が中心に、分散型ネットワークによる通信技術の開発が行われた。\nその中で学術機関4ノードを結ぶ、パケット交換の実用性を試験するための分散型ネットワーク ARPANET が誕生した。\nARPANET は急速に発展し、3年間で34ノードにまで拡大し、パケット交換によるデータ通信に実用性があることがわかった。</p>\n<p>その後、単なるパケット交換通信にとどまらず、各ノードのコンピュータ間での信頼性の高い通信手段を提供する総合的な通信プロトコルが実験、開発される。これがTCP/IPとなった。</p>\n<p>TCP/IP は当時普及していた OS である BSD UNIX に実装され、利用がさらに加速する。\nARPANET は拡大し、多数のネットワークと接続するようになる。\nやがて ARPANET や後継の NSFnet に接続する TCP/IP による世界的なネットワークをインターネット (The Internet) と呼ぶようになった。</p>\n<p>1995年ごろには ISP (Internet Service Provider) が乱立し、インターネットの商用化が進む。\nこのような流れで今日に至り、世界中を TCP/IP によるネットワークであるインターネットが覆い尽している。</p>\n<ul>\n<li>1960s DoD による通信技術の研究</li>\n<li>1969 ARPANET の誕生。パケット交換技術の開発</li>\n<li>1972 TCP/IP の誕生</li>\n<li>1975 TCP/IP の仕様決定と、 TCP/IP が実装された UNIX の提供</li>\n<li>1982 ARPANET でのプロトコルがTCP/IPに統一</li>\n<li>1989 LAN/WAN 上で TCP/IP が普及</li>\n<li>1995 インターネットの商用化が進む</li>\n</ul>\n<h3>TCP/IP の標準化</h3>\n<p>TCP/IP はプロトコル群であり、通信のためには両者が同一のプロトコルを使用する必要がある。\nそのためにTCP/IP にも標準が存在するが、 TCP/IP の標準化には次の2つの特徴があり、これがプロトコルの急速な実現と普及に影響した。</p>\n<ul>\n<li>オープンである</li>\n<li>実用を重視する</li>\n</ul>\n<h4>特徴:オープンである</h4>\n<p>TCP/IP の仕様を議論する IETF (Internet Engineering Task Force) のメーリングリストには自由に参加できる。</p>\n<p>また仕様や実装も公開されており、自由にアクセスできることもオープンであるという特徴を表している。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-ietf-maling-list.png\" alt=\"IETF のWebページ\"></p>\n<p>画像は<a href=\"https://www.ietf.org/how/lists/\">IETF のあるWebページ</a>の冒頭部分である。\n画像下部分に書かれているように、IETF の議論には、どんな個人でも参加できる。\nこのページの更に下に行くと、実際にメーリングリストに参加する手順が書かれていた。</p>\n<h4>特徴:実用を重視する</h4>\n<p>TCP/IP は仕様策定時に実装することを念頭において進む。\nプロトコルの詳細仕様を決める際には既に通信できる実装が存在し、標準になる頃には既に製品に実装されている。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-tcpip-standardizatin.png\" alt=\"TCP/IP 標準化の手続き\"></p>\n<p>画像はTCP/IP 標準化の手続きを図示したものである。</p>\n<p>以上のように、TCP/IP の標準化手続きには特徴がある。\n普及した要因に、他のプロトコルと比べ、実用を重視したことで動作するプロトコルをはやく作れたこと、オープンな仕様策定の仕組みにより急速な技術革新に対応できたことが考えられる。</p>\n<h4>TCP/IP の仕様</h4>\n<p>標準化しようとするプロトコルは RFC (Request For Comments) と呼ばれるドキュメントになり、<a href=\"http://rfc-editor.org/rfc\">インターネット上で公開</a>される。\n仕様だけでなく、実装や運用、実験に関する情報を含む。</p>\n<p>RFC には番号をがつけられており、一度 RFC になると改定することはない。\n拡張や廃止、新規のプロトコルを定める際には新たな RFC として公開される。\nそのため通し番号は大きくなり、プロトコルごとに番号の統一性があるわけでもないので人間にはわかりづらいところがある。\nこれを助けるため、複数の RFC を指す STD (STanDard), FYI (For Your Information) などの文書単位もある。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-rfc2616.png\" alt=\"rfc2616の冒頭\"></p>\n<p>画像は <a href=\"https://tools.ietf.org/html/rfc2616\">RFC2617</a> の冒頭である。</p>\n<h3>TCP/IP の階層モデル</h3>\n<p>TCP/IP モデルは階層構造になっている。\nネットワークの信頼のある通信を実現するには様々な機能を実装せねばならないので、各層に分けて他層を抽象化することが現実的には必須。</p>\n<p>TCP/IP が普及した理由の一つに柔軟性が挙げられる。\nIP が動作すればそれより下位層は何を使ってもよいし、 TCP / UDP 上で動作すればそれより上位のアプリケーションはなんでもよいのである。</p>\n<p>以下では、 OSI 参照モデルと TCP/IP 階層モデルの対応を示した後、下位層から順に、代表的なプロトコルを示す。</p>\n<h4>OSI 参照モデルとの対応</h4>\n<p>TCP/IP の階層モデルは、アプリケーション層、トランスポート層、インターネット層、リンク層の4階層から成る。\nOSI 参照モデル7階層に完全に対応するものではないが、対応するとしたらつぎのようになる。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-tcpip-protocol-stack.png\" alt=\"OSI 参照モデルと TCP/IP 階層モデルの対応\"></p>\n<h4>ハードウェア</h4>\n<p>OSI 参照モデルで物理層に当たる部分である。</p>\n<p>ハードウェアついては、 TCP/IP プロトコルでは特に指定されていない。\n通信する上での信頼性、セキュリテイ、帯域、遅延、無線/有線、電話回線やイーサネットなど、物理的なものには拘束されず、ネットワークで接続された装置間で通信できればよい。</p>\n<hr/>\n<p>余談だが、 TCP/IP におけるハードウェアとして伝書鳩を用いることもできる。\nRFC にも、<a href=\"https://tools.ietf.org/html/rfc1149\">RFC1149 鳥類キャリアによるIPデータグラムの伝送企画</a>としてきちんと仕様が存在する。</p>\n<p>これはエイプリルフールに作られたようだが、このような<strike>ふざけた</strike>お茶目な RFC はジョーク RFC と呼ばれ、他にも次のようなものがある。</p>\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc2322\">RFC2322 洗濯バサミDHCPによるIPアドレスの管理手法</a>(<a href=\"http://www.kt.rim.or.jp/~ksk/joke-RFC/rfc2322j.txt\">邦訳</a>)</li>\n<li><a href=\"https://www.ietf.org/rfc/rfc2324.txt\">RFC2324 ハイパーテクストコーヒーポット制御プロトコル</a></li>\n</ul>\n<p>等。 鳩を用意するのは厳しいが、後者2つは実装してみたい気もする。</p>\n<hr/> \n<h4>リンク層</h4>\n<p>ネットワークインタフェース層とも。(マスタリングTCP/IP入門編より)</p>\n<p>デバイスドライバが実装にあたる。(マスタリングTCP/IP入門編より)\nハードウェアの違いを吸収し、上位層で IP が使えるようにする。</p>\n<p>PPP (Point to Point Protocol) もここに含まれる。</p>\n<h4>インターネット層</h4>\n<p>OSI 参照モデルの下から3番目であるネットワーク層に対応する。</p>\n<p>経路制御を行う。\n通信したいホスト間のデータリンクを上位層へ隠し、実際は Hop-by-Hop で行われている通信を End-to-End で行われているようにみせる役割がある。</p>\n<p>代表的な3つのプロトコルを紹介する。</p>\n<h5>IP (Internet Protocol)</h5>\n<p>パケットを転送するために用いられる、インターネット層で代表的なプロトコル。\nIP アドレスでホストを識別し、通信相手までパケットを配送する。\n通信経路の確立を行うが、データが正しく送られる保証はない。</p>\n<h5>ICMP (Internet Control Message Protocol)</h5>\n<p>IP によるパケット転送に誤りがあったり、失敗したときにこれを通知するために用いられる。\n他に、ネットワークが正常に通信できるか診断する機能ももつ。\nping コマンドや traceroute コマンドなどは ICMP パケットを送信することで実現している。</p>\n<h5>ARP (Address Resolution Protocol)</h5>\n<p>IP アドレスと MAC アドレスの対応関係を取得するためのプロトコル。IP が目的地へ通信するために、ARP を用いて途中の各通信経路の解決が行われる。</p>\n<h4>トランスポート層</h4>\n<p>OSI 参照モデルの下から4番目であるトランスポート層に対応する。\nアプリケーション間のプログラムの通信を実現し、場合によってはデータの到達性も保証する。</p>\n<h5>TCP (Transmission Control Protocol)</h5>\n<p>コネクション型のプロトコル。\nデータの到達性を保証し、再送制御や輻輳制御を行う。\nコネクションの確立に3パケット、切断に4パケットの通信が少なくとも必要である。</p>\n<h5>UDP (User Datagram Protocol)</h5>\n<p>コネクションレス型のプロトコル。\nデータの到達性を保証しない。\nパケット数の少ない通信、2者間ではないブロードキャスト/マルチキャスト通信, データが多少抜け落ちても問題ない動画や音声の通信に向く。</p>\n<h4>アプリケーション層</h4>\n<p>OSI 参照モデルの5-7階層に相当する。\nTCP/IP上では様々なアプリケーションを動かすことができる。\n以下では、それぞれのアプリケーションごとに使われるプロトコルを紹介する。</p>\n<h5>WWW (World Wide Web)</h5>\n<p>HTML (Hyper Text Markup Language) 文書をはじめとするデータを、Webブラウザを介して HTTP (Hyper Text Transfer Protocol) / HTTPS ( - Secure) で受信し閲覧する。</p>\n<p>(QUIC などの例外を除いて)主に TCP 上で動作する。</p>\n<h5>電子メール</h5>\n<p>MIME (Multipurpose Internet Mail Extensions) (マイム)形式のデータを、専用のプロトコルを用いて送受信する。</p>\n<p>メールの送受信には SMTP (Simple Mail Transfer Protocol), POP3 (Post Office Protocol version 3), IMAP (Internet Message Access Protocol)などが用いられる。</p>\n<p>送信者はメールを SMTP サーバを経由して相手方の POP3 / IMAP サーバへ送信する。\n受信者は POP3 / IMAP サーバよりメールを受け取る。</p>\n<p>TCP 上で動作する。</p>\n<h5>ファイル転送</h5>\n<p>FTP (File Transfer Protocol) / SFTP (Secure - )によりファイルを送受信する</p>\n<p>TCP 上で動作する。</p>\n<h5>遠隔ログイン</h5>\n<p>TELNET (TELetypewriter NETwork) や SSH (Secure SHell) を用いて離れたコンピュータにログインする。</p>\n<p>Linux で GUI を実現するためによく用いられる X Window System の X Protocol も TCP/IP 上で実現している。</p>\n<p>TELNET や SSH 等は TCP 上で動作する。\nX Protocol の中でも XDMCP (X Display Manager Control Protocol) は UDP。</p>\n<h5>ネットワーク管理</h5>\n<p>SNMP (Simple Network Management Protocol) など。</p>\n<p>ネットワーク上のルータやスイッチなどの管理対象(SNMP エージェント)を管理端末(SNMP マネージャ)が管理する。\nパケットの量や機器の温度などを管理できる。\nネットワーク機器の動作を妨げないため、また通信に必要なパケットが少ないため、UDP で動作する。</p>\n<h3>実際の通信</h3>\n<p>通信を行う際、送信側は上位層から順にその層で必要となる管理情報を含むヘッダを付加してカプセル化する。\n受信側は下位層から順にヘッダを解釈して除去し上位層に渡す。</p>\n<p>例えばWebページを閲覧する際は、サーバ側で HTML 文書に HTTP ヘッダを付加し、  TCP ヘッダを付加し、 IP ヘッダを付加し、イーサネットフレームのヘッダを付加し送信される。\nクライアントはイーサネットフレームのヘッダを解釈し、 IP ヘッダを解釈し、 TCP ヘッダを解釈し、 HTTP ヘッダを解釈し、 HTML 文章を画面に描画する。</p>\n<p><img src=\"https://blob.yammer.jp/internet-tcpip-encapsulation.png\" alt=\"実際の通信のカプセル化\"></p>\n<h2>まとめ</h2>\n<p>以上の内容をまとめると次のようになる。</p>\n<ul>\n<li>インターネットは TCP/IP で接続される世界全体のネットワークのこと</li>\n<li>TCP/IP は IP をはじめとするプロトコル群</li>\n<li>TCP/IP はオープンな議論で, 実用重視の仕様策定を行っている</li>\n<li>TCP/IP の各プロトコルは階層モデルでわけることができる</li>\n</ul>\n<p>ネットワーク全体について俯瞰して振り返ることはあまりないので、スライドを作ったのに合わせて文章にも起こしてみた。\nこういった復習を多く含む地道な勉強も、怠らずにやっていきたい。</p>\n<hr>\n<p>追記: (2020/10/04) 不要な改行タグを削除</p>\n","content_text":"今日のインターネットの根幹をなすTCP/IPについての基本的な知識を説明する。\n\n研究室の輪講で「マスタリングTCP/IP 入門編」を読んだことがきっかけ。\n\n参考文献: マスタリングTCP/IP入門編 第二章 pp60-80\n\nインターネット\n\n今この文章もインターネットに公開され、インターネットを介して見ていることと思うが、インターネットとはそもそも何を指すのか。\n\nInternet / The Internet とは、TCP/IPにより全世界を接続しているコンピュータネットワーク、ただ一つのことを指す。\n\n語源は「複数のネットワークを結ぶ」ことを表す internet。\n現在ではこの意味は internet ではなく internetworking という言葉で表される。\n\nインターネットの構造\n\nインターネットは、小さなネットワークが相互接続し1つのネットワークを成し、これが複数接続して大きなネットワークを成し、、のように階層的な構造をもつ。\n\nISP (Internet Service Provider) のネットワーク内では、NOC (Network Operation Center) と呼ばれる施設を通じて接続し、ネットワークを構成している。\nISP 同士の接続には、2者間接続を行うプライベートピアリングや、多数の ISP を IX (Internet Exchange) を通じてつなぐ IP トランジットがある。\n\nインターネットの構造\n\n画像はインターネットの構造を表した図。\n\nISP 以外にも有志で運営される地域ネットといわれるネットワークも存在すると本に記載があるが、2020年現在の実態は不明。\n過去にあった地域ネットとして柏インターネットユニオンなどがあるようだ。\n\nTCP/IP\n\nTCP/IP とは、パケット交換プロトコルである IP (Internet Protocol) を利用したり、 IP で通信したりするときに必要なプロトコル群の総称のことである。\nインターネットで必要なプロトコルをまとめたものであることから、インターネットプロトコルスイートとも言われる。\nTCP/IP という語を使うとき、 TCP プロトコルと IP プロトコルだけを指しているわけではない。\n\nTCP/IP に含むプロトコルの一例\n\nパケット交換ネットワーク\n\n先程出てきたパケット交換について。\nパケット交換ネットワークとは、電話に用いられるような回線交換型と対比されるネットワークの形式である。\n\n一つの回線を複数が共有して使う。\n代表的な利点として、回線の利用効率を高められること、分散型のネットワークの構築に向くことが挙げられる。\n\nTCP/IP の歴史\n\n1960年代、米国防総省 (The Depertment of Defense) が中心に、分散型ネットワークによる通信技術の開発が行われた。\nその中で学術機関4ノードを結ぶ、パケット交換の実用性を試験するための分散型ネットワーク ARPANET が誕生した。\nARPANET は急速に発展し、3年間で34ノードにまで拡大し、パケット交換によるデータ通信に実用性があることがわかった。\n\nその後、単なるパケット交換通信にとどまらず、各ノードのコンピュータ間での信頼性の高い通信手段を提供する総合的な通信プロトコルが実験、開発される。これがTCP/IPとなった。\n\nTCP/IP は当時普及していた OS である BSD UNIX に実装され、利用がさらに加速する。\nARPANET は拡大し、多数のネットワークと接続するようになる。\nやがて ARPANET や後継の NSFnet に接続する TCP/IP による世界的なネットワークをインターネット (The Internet) と呼ぶようになった。\n\n1995年ごろには ISP (Internet Service Provider) が乱立し、インターネットの商用化が進む。\nこのような流れで今日に至り、世界中を TCP/IP によるネットワークであるインターネットが覆い尽している。\n\n1960s DoD による通信技術の研究\n\n1969 ARPANET の誕生。パケット交換技術の開発\n\n1972 TCP/IP の誕生\n\n1975 TCP/IP の仕様決定と、 TCP/IP が実装された UNIX の提供\n\n1982 ARPANET でのプロトコルがTCP/IPに統一\n\n1989 LAN/WAN 上で TCP/IP が普及\n\n1995 インターネットの商用化が進む\n\nTCP/IP の標準化\n\nTCP/IP はプロトコル群であり、通信のためには両者が同一のプロトコルを使用する必要がある。\nそのためにTCP/IP にも標準が存在するが、 TCP/IP の標準化には次の2つの特徴があり、これがプロトコルの急速な実現と普及に影響した。\n\nオープンである\n\n実用を重視する\n\n特徴:オープンである\n\nTCP/IP の仕様を議論する IETF (Internet Engineering Task Force) のメーリングリストには自由に参加できる。\n\nまた仕様や実装も公開されており、自由にアクセスできることもオープンであるという特徴を表している。\n\nIETF のWebページ\n\n画像はIETF のあるWebページの冒頭部分である。\n画像下部分に書かれているように、IETF の議論には、どんな個人でも参加できる。\nこのページの更に下に行くと、実際にメーリングリストに参加する手順が書かれていた。\n\n特徴:実用を重視する\n\nTCP/IP は仕様策定時に実装することを念頭において進む。\nプロトコルの詳細仕様を決める際には既に通信できる実装が存在し、標準になる頃には既に製品に実装されている。\n\nTCP/IP 標準化の手続き\n\n画像はTCP/IP 標準化の手続きを図示したものである。\n\n以上のように、TCP/IP の標準化手続きには特徴がある。\n普及した要因に、他のプロトコルと比べ、実用を重視したことで動作するプロトコルをはやく作れたこと、オープンな仕様策定の仕組みにより急速な技術革新に対応できたことが考えられる。\n\nTCP/IP の仕様\n\n標準化しようとするプロトコルは RFC (Request For Comments) と呼ばれるドキュメントになり、インターネット上で公開される。\n仕様だけでなく、実装や運用、実験に関する情報を含む。\n\nRFC には番号をがつけられており、一度 RFC になると改定することはない。\n拡張や廃止、新規のプロトコルを定める際には新たな RFC として公開される。\nそのため通し番号は大きくなり、プロトコルごとに番号の統一性があるわけでもないので人間にはわかりづらいところがある。\nこれを助けるため、複数の RFC を指す STD (STanDard), FYI (For Your Information) などの文書単位もある。\n\nrfc2616の冒頭\n\n画像は RFC2617 の冒頭である。\n\nTCP/IP の階層モデル\n\nTCP/IP モデルは階層構造になっている。\nネットワークの信頼のある通信を実現するには様々な機能を実装せねばならないので、各層に分けて他層を抽象化することが現実的には必須。\n\nTCP/IP が普及した理由の一つに柔軟性が挙げられる。\nIP が動作すればそれより下位層は何を使ってもよいし、 TCP / UDP 上で動作すればそれより上位のアプリケーションはなんでもよいのである。\n\n以下では、 OSI 参照モデルと TCP/IP 階層モデルの対応を示した後、下位層から順に、代表的なプロトコルを示す。\n\nOSI 参照モデルとの対応\n\nTCP/IP の階層モデルは、アプリケーション層、トランスポート層、インターネット層、リンク層の4階層から成る。\nOSI 参照モデル7階層に完全に対応するものではないが、対応するとしたらつぎのようになる。\n\nOSI 参照モデルと TCP/IP 階層モデルの対応\n\nハードウェア\n\nOSI 参照モデルで物理層に当たる部分である。\n\nハードウェアついては、 TCP/IP プロトコルでは特に指定されていない。\n通信する上での信頼性、セキュリテイ、帯域、遅延、無線/有線、電話回線やイーサネットなど、物理的なものには拘束されず、ネットワークで接続された装置間で通信できればよい。\n\n\n\n余談だが、 TCP/IP におけるハードウェアとして伝書鳩を用いることもできる。\nRFC にも、RFC1149 鳥類キャリアによるIPデータグラムの伝送企画としてきちんと仕様が存在する。\n\nこれはエイプリルフールに作られたようだが、このようなふざけたお茶目な RFC はジョーク RFC と呼ばれ、他にも次のようなものがある。\n\nRFC2322 洗濯バサミDHCPによるIPアドレスの管理手法(邦訳)\n\nRFC2324 ハイパーテクストコーヒーポット制御プロトコル\n\n等。 鳩を用意するのは厳しいが、後者2つは実装してみたい気もする。\n\n\n\nリンク層\n\nネットワークインタフェース層とも。(マスタリングTCP/IP入門編より)\n\nデバイスドライバが実装にあたる。(マスタリングTCP/IP入門編より)\nハードウェアの違いを吸収し、上位層で IP が使えるようにする。\n\nPPP (Point to Point Protocol) もここに含まれる。\n\nインターネット層\n\nOSI 参照モデルの下から3番目であるネットワーク層に対応する。\n\n経路制御を行う。\n通信したいホスト間のデータリンクを上位層へ隠し、実際は Hop-by-Hop で行われている通信を End-to-End で行われているようにみせる役割がある。\n\n代表的な3つのプロトコルを紹介する。\n\nIP (Internet Protocol)\n\nパケットを転送するために用いられる、インターネット層で代表的なプロトコル。\nIP アドレスでホストを識別し、通信相手までパケットを配送する。\n通信経路の確立を行うが、データが正しく送られる保証はない。\n\nICMP (Internet Control Message Protocol)\n\nIP によるパケット転送に誤りがあったり、失敗したときにこれを通知するために用いられる。\n他に、ネットワークが正常に通信できるか診断する機能ももつ。\nping コマンドや traceroute コマンドなどは ICMP パケットを送信することで実現している。\n\nARP (Address Resolution Protocol)\n\nIP アドレスと MAC アドレスの対応関係を取得するためのプロトコル。IP が目的地へ通信するために、ARP を用いて途中の各通信経路の解決が行われる。\n\nトランスポート層\n\nOSI 参照モデルの下から4番目であるトランスポート層に対応する。\nアプリケーション間のプログラムの通信を実現し、場合によってはデータの到達性も保証する。\n\nTCP (Transmission Control Protocol)\n\nコネクション型のプロトコル。\nデータの到達性を保証し、再送制御や輻輳制御を行う。\nコネクションの確立に3パケット、切断に4パケットの通信が少なくとも必要である。\n\nUDP (User Datagram Protocol)\n\nコネクションレス型のプロトコル。\nデータの到達性を保証しない。\nパケット数の少ない通信、2者間ではないブロードキャスト/マルチキャスト通信, データが多少抜け落ちても問題ない動画や音声の通信に向く。\n\nアプリケーション層\n\nOSI 参照モデルの5-7階層に相当する。\nTCP/IP上では様々なアプリケーションを動かすことができる。\n以下では、それぞれのアプリケーションごとに使われるプロトコルを紹介する。\n\nWWW (World Wide Web)\n\nHTML (Hyper Text Markup Language) 文書をはじめとするデータを、Webブラウザを介して HTTP (Hyper Text Transfer Protocol) / HTTPS ( - Secure) で受信し閲覧する。\n\n(QUIC などの例外を除いて)主に TCP 上で動作する。\n\n電子メール\n\nMIME (Multipurpose Internet Mail Extensions) (マイム)形式のデータを、専用のプロトコルを用いて送受信する。\n\nメールの送受信には SMTP (Simple Mail Transfer Protocol), POP3 (Post Office Protocol version 3), IMAP (Internet Message Access Protocol)などが用いられる。\n\n送信者はメールを SMTP サーバを経由して相手方の POP3 / IMAP サーバへ送信する。\n受信者は POP3 / IMAP サーバよりメールを受け取る。\n\nTCP 上で動作する。\n\nファイル転送\n\nFTP (File Transfer Protocol) / SFTP (Secure - )によりファイルを送受信する\n\nTCP 上で動作する。\n\n遠隔ログイン\n\nTELNET (TELetypewriter NETwork) や SSH (Secure SHell) を用いて離れたコンピュータにログインする。\n\nLinux で GUI を実現するためによく用いられる X Window System の X Protocol も TCP/IP 上で実現している。\n\nTELNET や SSH 等は TCP 上で動作する。\nX Protocol の中でも XDMCP (X Display Manager Control Protocol) は UDP。\n\nネットワーク管理\n\nSNMP (Simple Network Management Protocol) など。\n\nネットワーク上のルータやスイッチなどの管理対象(SNMP エージェント)を管理端末(SNMP マネージャ)が管理する。\nパケットの量や機器の温度などを管理できる。\nネットワーク機器の動作を妨げないため、また通信に必要なパケットが少ないため、UDP で動作する。\n\n実際の通信\n\n通信を行う際、送信側は上位層から順にその層で必要となる管理情報を含むヘッダを付加してカプセル化する。\n受信側は下位層から順にヘッダを解釈して除去し上位層に渡す。\n\n例えばWebページを閲覧する際は、サーバ側で HTML 文書に HTTP ヘッダを付加し、  TCP ヘッダを付加し、 IP ヘッダを付加し、イーサネットフレームのヘッダを付加し送信される。\nクライアントはイーサネットフレームのヘッダを解釈し、 IP ヘッダを解釈し、 TCP ヘッダを解釈し、 HTTP ヘッダを解釈し、 HTML 文章を画面に描画する。\n\n実際の通信のカプセル化\n\nまとめ\n\n以上の内容をまとめると次のようになる。\n\nインターネットは TCP/IP で接続される世界全体のネットワークのこと\n\nTCP/IP は IP をはじめとするプロトコル群\n\nTCP/IP はオープンな議論で, 実用重視の仕様策定を行っている\n\nTCP/IP の各プロトコルは階層モデルでわけることができる\n\nネットワーク全体について俯瞰して振り返ることはあまりないので、スライドを作ったのに合わせて文章にも起こしてみた。\nこういった復習を多く含む地道な勉強も、怠らずにやっていきたい。\n\n\n\n追記: (2020/10/04) 不要な改行タグを削除\n"},{"id":"http://localhost:3000/posts/job-hunting-6-month-ago","url":"http://localhost:3000/posts/job-hunting-6-month-ago","title":"就活を終えて半年経って思うこと。","summary":"進路を迷っている知人に就活のことを聞かれ、自分が何を考えて決めたのかを、主に次の視点で綴ったので、ここにも記します。 就職先の決め手 なぜエンジニアとして働くのか なぜ大学院に進学しなかったのか 就職先の決め手 就活時に重視していたところはつぎのようなことがあります。 文化 技術的な成長 会社のサービスに自分が貢献したいと思えるか 会社を決めた理由は、ざっくりまとめると「自分が最も成長できそうだから」でしょうか。 就職予定の会社は、独特の企業文化が特徴です。これが自分が働くモチベーション高く保つことにつながると考えました。 技術が身につく環境でも、自分に合わない環境で働くのは長続きしないでしょ","date_published":"2020-05-13T23:54:22+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E5%B0%B1%E6%B4%BB%E3%82%92%E7%B5%82%E3%81%88%E3%81%A6%E5%8D%8A%E5%B9%B4%E7%B5%8C%E3%81%A3%E3%81%A6%E6%80%9D%E3%81%86%E3%81%93%E3%81%A8%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["お気持ち"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a8ffbbb92c446493c9f7dafb313af6488f58d9b9","comment":"Add post\n","date_modified":"2020-05-14T00:21:15+09:00"}],"content_html":"<p>進路を迷っている知人に就活のことを聞かれ、自分が何を考えて決めたのかを、主に次の視点で綴ったので、ここにも記します。</p>\n<ul>\n<li>就職先の決め手</li>\n<li>なぜエンジニアとして働くのか</li>\n<li>なぜ大学院に進学しなかったのか</li>\n</ul>\n<h2>就職先の決め手</h2>\n<p>就活時に重視していたところはつぎのようなことがあります。</p>\n<ul>\n<li>文化</li>\n<li>技術的な成長</li>\n<li>会社のサービスに自分が貢献したいと思えるか</li>\n</ul>\n<p>会社を決めた理由は、ざっくりまとめると「自分が最も成長できそうだから」でしょうか。\n就職予定の会社は、独特の企業文化が特徴です。これが自分が働くモチベーション高く保つことにつながると考えました。\n技術が身につく環境でも、自分に合わない環境で働くのは長続きしないでしょう。しかしこの会社でなら正直に過ごせそう、自分が成長の努力をしながら楽しんで働けそうだと感じたからです。</p>\n<p>新卒時点の給料はそこまで重視していなくて、技術が身につけばいくらでも給料を高められるだろうから、自分が成長できること(長期的に見て稼げること)のほうが大事だと考えていました。</p>\n<p>あとは、会社規模も関係しています。決めた会社は社内のエンジニアコミュニティが強く、その中で高めあっているところが魅力に写りました。</p>\n<p>他に受けていた会社で、エンジニアが数人ほどの企業もあったのですが、私の技術的な未熟さゆえに選考を断念しました。\n(極端に言うと幅広い技術や一歩先の技術を身につける余裕を自分に持てないのではないかとの懸念がありました。)\n規模が小さいほうが裁量があったり、ビジネスサイドにも足をつっこんだりしやすい側面はありそうです。この魅力を重視する方は私とは違う決断をするでしょう。)</p>\n<p>逆にもっと大きな会社だと、細分化されすぎていて私には楽しくないようにみえました。(エンジニアリングに関してはいろんなことに足を突っ込んでみたい。)\n会社規模は選考がある程度進んでから、比較するようになって考えだしました。</p>\n<h2>エンジニアになるかどうか</h2>\n<p>私はわりと初期の段階でWebエンジニアに絞ってしまっていました。とりあえず行動してみて、納得できなければ変えるつもりでしたが、働くイメージが湧いてきたのでそのまま方向を変えずに就活をつづけました。</p>\n<p>自分がどれだけ技術を好きになれるか、勉強を苦に思わないかが自分の中での判断基準です。世の中には自分よりコンピュータが好きな人はたくさんいるし、上を見たらきりはないので、現時点での技術力と熱意が他人に負けているからダメという選び方はしていません。\n私にとって、他の仕事よりWebエンジニアとして働いたほうが、仕事を楽しめてかつ社会に出せる価値が多そうだと判断し決めました。</p>\n<p>(Web)エンジニアになるのはある意味賭けで、専門的な技術は身につくけど、いざとなれば転職で入ってこれる業界でもあるので、難しいですね。</p>\n<p>エンジニアといっても、ビジネスやデザインのわかるエンジニア、他方、技術に尖ったエンジニアをより欲しているところ、育てようとしているところはたくさんあるだろうし、非常に多種多様な姿があるだろうから、自分にあったキャリアを見つけるのは大変でしょう。さらに世の中には本当に様々な仕事があり、Webエンジニア、プログラマーだけをを見ているのは勿体無いかもしれません。</p>\n<p>私なりにいくつかの選択肢を考える中で、自分に興味のある領域を深められる職・会社としていまの進路を選びました。</p>\n<h2>大学院に行くかどうか</h2>\n<p>就活を始めるときに、内心「良さげな企業に受かったら就職、うまく行かなかったら院にいこうか」と考えましたが、まず「とりあえず就職前提で動こう」(じゃないと何もしなそう)と自分に言い聞かせました。</p>\n<p>就活をしていくうちに、良い会社に出会えたこと、(まだ始まっていなかったが)大学での研究よりもWeb周りのことを触っている方が楽しいだろうと思ったことから就職へ傾きました。\n内心、面接が重なると早く就活を抜け出したい、(院卒で)もう一回やるのはちょっと大変という気持ちもありました。\n就活は真剣にキャリアを考える機会として面白い面もあるのですが、続けていると気持ちが疲れてくる面もあります。</p>\n<p>いまの会社に受かってなければ大学院に進学していたかもしれません。\n真っ当な理由「研究がしたい」 はもちろん、就活を先延ばしにする意味でも大学院進学もありだったなとは今も思ってます。(院卒に怒られる)。</p>\n<p>Web業界は新卒といえど、(私は経験ないですが)長期インターンに行っている人が結構いたり、ある程度の技術的素養が求められている会社もそこそこあるので、就活が先延ばしになると受かりやすくなる面はあるかもしれません。\n(どこかで読みましたがインターンに受かるコツはインターンに受かることだそうです。)\n大学院に進学すれば、インターンなどに参加する時間的な猶予ができるともとれます。</p>\n<hr/>\n<p>つたない文章ですが、私が考えていたことを思い返してみました。</p>\n<p>就活をはじめてから、自分がどんな価値を見いだせるか、どんな環境で働きたいか、あらためて何度も考えました。\n特に面接や面談はその考えが深まる、改まる場であって、このような機会を設けてくださった方々に感謝しています。</p>\n","content_text":"進路を迷っている知人に就活のことを聞かれ、自分が何を考えて決めたのかを、主に次の視点で綴ったので、ここにも記します。\n\n就職先の決め手\n\nなぜエンジニアとして働くのか\n\nなぜ大学院に進学しなかったのか\n\n就職先の決め手\n\n就活時に重視していたところはつぎのようなことがあります。\n\n文化\n\n技術的な成長\n\n会社のサービスに自分が貢献したいと思えるか\n\n会社を決めた理由は、ざっくりまとめると「自分が最も成長できそうだから」でしょうか。\n就職予定の会社は、独特の企業文化が特徴です。これが自分が働くモチベーション高く保つことにつながると考えました。\n技術が身につく環境でも、自分に合わない環境で働くのは長続きしないでしょう。しかしこの会社でなら正直に過ごせそう、自分が成長の努力をしながら楽しんで働けそうだと感じたからです。\n\n新卒時点の給料はそこまで重視していなくて、技術が身につけばいくらでも給料を高められるだろうから、自分が成長できること(長期的に見て稼げること)のほうが大事だと考えていました。\n\nあとは、会社規模も関係しています。決めた会社は社内のエンジニアコミュニティが強く、その中で高めあっているところが魅力に写りました。\n\n他に受けていた会社で、エンジニアが数人ほどの企業もあったのですが、私の技術的な未熟さゆえに選考を断念しました。\n(極端に言うと幅広い技術や一歩先の技術を身につける余裕を自分に持てないのではないかとの懸念がありました。)\n規模が小さいほうが裁量があったり、ビジネスサイドにも足をつっこんだりしやすい側面はありそうです。この魅力を重視する方は私とは違う決断をするでしょう。)\n\n逆にもっと大きな会社だと、細分化されすぎていて私には楽しくないようにみえました。(エンジニアリングに関してはいろんなことに足を突っ込んでみたい。)\n会社規模は選考がある程度進んでから、比較するようになって考えだしました。\n\nエンジニアになるかどうか\n\n私はわりと初期の段階でWebエンジニアに絞ってしまっていました。とりあえず行動してみて、納得できなければ変えるつもりでしたが、働くイメージが湧いてきたのでそのまま方向を変えずに就活をつづけました。\n\n自分がどれだけ技術を好きになれるか、勉強を苦に思わないかが自分の中での判断基準です。世の中には自分よりコンピュータが好きな人はたくさんいるし、上を見たらきりはないので、現時点での技術力と熱意が他人に負けているからダメという選び方はしていません。\n私にとって、他の仕事よりWebエンジニアとして働いたほうが、仕事を楽しめてかつ社会に出せる価値が多そうだと判断し決めました。\n\n(Web)エンジニアになるのはある意味賭けで、専門的な技術は身につくけど、いざとなれば転職で入ってこれる業界でもあるので、難しいですね。\n\nエンジニアといっても、ビジネスやデザインのわかるエンジニア、他方、技術に尖ったエンジニアをより欲しているところ、育てようとしているところはたくさんあるだろうし、非常に多種多様な姿があるだろうから、自分にあったキャリアを見つけるのは大変でしょう。さらに世の中には本当に様々な仕事があり、Webエンジニア、プログラマーだけをを見ているのは勿体無いかもしれません。\n\n私なりにいくつかの選択肢を考える中で、自分に興味のある領域を深められる職・会社としていまの進路を選びました。\n\n大学院に行くかどうか\n\n就活を始めるときに、内心「良さげな企業に受かったら就職、うまく行かなかったら院にいこうか」と考えましたが、まず「とりあえず就職前提で動こう」(じゃないと何もしなそう)と自分に言い聞かせました。\n\n就活をしていくうちに、良い会社に出会えたこと、(まだ始まっていなかったが)大学での研究よりもWeb周りのことを触っている方が楽しいだろうと思ったことから就職へ傾きました。\n内心、面接が重なると早く就活を抜け出したい、(院卒で)もう一回やるのはちょっと大変という気持ちもありました。\n就活は真剣にキャリアを考える機会として面白い面もあるのですが、続けていると気持ちが疲れてくる面もあります。\n\nいまの会社に受かってなければ大学院に進学していたかもしれません。\n真っ当な理由「研究がしたい」 はもちろん、就活を先延ばしにする意味でも大学院進学もありだったなとは今も思ってます。(院卒に怒られる)。\n\nWeb業界は新卒といえど、(私は経験ないですが)長期インターンに行っている人が結構いたり、ある程度の技術的素養が求められている会社もそこそこあるので、就活が先延ばしになると受かりやすくなる面はあるかもしれません。\n(どこかで読みましたがインターンに受かるコツはインターンに受かることだそうです。)\n大学院に進学すれば、インターンなどに参加する時間的な猶予ができるともとれます。\n\n\n\nつたない文章ですが、私が考えていたことを思い返してみました。\n\n就活をはじめてから、自分がどんな価値を見いだせるか、どんな環境で働きたいか、あらためて何度も考えました。\n特に面接や面談はその考えが深まる、改まる場であって、このような機会を設けてくださった方々に感謝しています。\n"},{"id":"http://localhost:3000/posts/plist","url":"http://localhost:3000/posts/plist","title":"(余談) User Defaultsとproperty list(plist)","summary":"Mac OS XのUser Defaultsを変更するためのシェルスクリプトを作るツール pdefを制作した。(解説記事: Macの設定を自動化するdefaultsコマンドと、それを助けるpdef) これを作る際にProperty listについて学んだことを記す。 User Defaults User Defaultsは、MacOSXやiOSにおける各アプリケーションが設定などを保持するためのデータベースである。 User Defaultsは、各アプリケーション(正確にはアプリケーションの持つドメイン)ごとにProperty listとして記録される。 普段は各アプリケーションを通して読み書","date_published":"2020-05-02T16:26:00+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:(%E4%BD%99%E8%AB%87)%20User%20Defaults%E3%81%A8property%20list(plist),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","plist"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/698524967ae01574a8037c627a8b083e253a04f2","comment":"Fix internal links\n","date_modified":"2020-10-04T22:43:27+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b0c059c4550ee771770fd379ca3784c7a200ea1e","comment":"Delete unnecessary text\n","date_modified":"2020-05-02T18:52:59+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/3c66a3806802300f6bcf4b8e94eaa74510b4bcf1","comment":"Draft -> Publish\n","date_modified":"2020-05-02T16:27:03+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10de6b6d5a073094ad62202ad3173f9825829c96","comment":"Fix typo\n","date_modified":"2020-05-02T16:24:57+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/79560c53fe90e51cc5ef0eff7e4645ecf89d3d5d","comment":"Fix link\n","date_modified":"2020-05-02T16:24:05+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/63789db2e633ff7668e68a82823e26d16818aec1","comment":"Fix plist.md\n","date_modified":"2020-05-02T16:20:31+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/75b44add9b7f39b14eccba471ba1b2dc4ea87f21","comment":"Delete  description\n","date_modified":"2020-05-02T16:11:13+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c3d9ce2b0f8fe9a80a42424b8e43c29bbcafe8e3","comment":"Add old-style-ascii sample (draft)\n","date_modified":"2020-05-02T15:49:19+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/62c4e30b2e568c26d086fcc1564491b25f30934b","comment":"Update plist.md (draft)\n","date_modified":"2020-05-02T15:38:50+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/274345589b379cea58a03f64e56f38a390c12ee5","comment":"Update plist.md (draft)\n","date_modified":"2020-05-02T11:58:38+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/2e71607b56bddeb8a67e337b81526238b3c2447f","comment":"Add draft post. plist\n","date_modified":"2020-05-01T01:02:11+09:00"}],"content_html":"<p>Mac OS XのUser Defaultsを変更するためのシェルスクリプトを作るツール <a href=\"https://github.com/yammerjp/pdef\">pdef</a>を制作した。(解説記事: <a href=\"/posts/pdef/\">Macの設定を自動化するdefaultsコマンドと、それを助けるpdef</a>)</p>\n<p>これを作る際にProperty listについて学んだことを記す。</p>\n<h2>User Defaults</h2>\n<p>User Defaultsは、MacOSXやiOSにおける各アプリケーションが設定などを保持するためのデータベースである。\nUser Defaultsは、各アプリケーション(正確にはアプリケーションの持つドメイン)ごとにProperty listとして記録される。\n普段は各アプリケーションを通して読み書きされるが、ターミナル上からアクセスできる<code>$ defaults</code>コマンドも提供されている。(後述)</p>\n<h2>Property list</h2>\n<p>User Defaultsに使われているproperty list(以下plist)は、Mac OS Xにおいてオブジェクトの永続化におけるファイル形式としてよく用いられている。\n例えば、iOSアプリを開発する際に自動生成されてXcode上から見える<code>info.plist</code>がその例だ。</p>\n<p>plistはNeXTSTEP時代から続く歴史あるフォーマットらしい。時代背景も相まってファイルの保存形式は多数ある(後述)。</p>\n<h3>論理構造</h3>\n<p>plistはJSON等と同様のキーバリュー形式の論理構造を取る。\nキーに一対一対応する値が存在し、値は即値の他に入れ子状にデータを保持できる。</p>\n<p>値のとりうる型は次の通り。</p>\n<ul>\n<li>辞書(dictionary)</li>\n<li>配列(array)</li>\n<li>文字列(string)</li>\n<li>数値(number(integer and float))</li>\n<li>日付(date)</li>\n<li>バイナリ(binary data)</li>\n<li>真偽値(Boolean value)</li>\n</ul>\n<p>この中でも辞書型と配列型は特殊で、辞書型はキーと値の組を、配列型は値を、子にもつことができる。</p>\n<p>JSONに無い型(日付,バイナリ)が存在するので、完全な相互変換は不可。</p>\n<p>参考: <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/PropertyList.html\">Property list - Apple Developper Documentation</a> (plist関する公式のドキュメント)</p>\n<h3>保存形式</h3>\n<h4>old-style ASCII形式</h4>\n<p>テキストベースで、可読性が高いのがこの形式。NeXT形式とも呼ばれる?。NeXTSTEP時代にできた。\n作られた当時、文字列、配列、ディクショナリ、そしてバイナリデータのみを表現できたらしい。\nシンプルなフォーマットであるが、型情報がなく、型の判別が難しい。</p>\n<p><code>$ defaults read</code>コマンドで出力される形式であり、現在では主にここでみられる。</p>\n<p>old-style ASCII形式の例として、あるplistをold-style ASCIIで表した表記を以下に示す。</p>\n<pre><code class=\"hljs language-txt\">{\n    \"boolean-example\" = 0;\n    fuga =     {\n        p0y0p0y0 = 0;\n        punipuni = value;\n    };\n    hoge = helloworld;\n    wara =     (\n        {length = 8, bytes = 0x0123456789abcdef},\n        123,\n        \"0.5\",\n        1,\n        \"2019-09-16 05:45:42 +0000\"\n    );\n}</code></pre>\n<h4>XML形式</h4>\n<p>plistのデータ構造をXML形式で表現した形式。\n前述のold-style ASCIIのように欠けた情報がなく、なおかつ人間にも読めるのでplistをこねくり回す際にはお世話になるだろう。</p>\n<p>それぞれの型におけるxml上での表記は次の通り</p>\n<ul>\n<li>辞書: <code>&#x3C;dict> &#x3C;key>keystring&#x3C;/key> [value] (繰り返し) &#x3C;/dict></code></li>\n<li>配列: <code>&#x3C;array> [vaule] (繰り返し) &#x3C;/array></code></li>\n<li>文字列: <code>&#x3C;string>value&#x3C;/string></code></li>\n<li>数値(整数): <code>&#x3C;integer>124234&#x3C;/integer></code></li>\n<li>数値(浮動小数点数): <code>&#x3C;real>0.43&#x3C;/real></code></li>\n<li>日付: <code>&#x3C;date>2019-09-16T05:45:42Z&#x3C;/date></code> (ISO8601と思われる)</li>\n<li>バイナリ: <code>&#x3C;data> ASNFZ4mrze8= &#x3C;/data></code> (base64でエンコード済みの文字列)</li>\n<li>真偽値: <code>&#x3C;true/></code>または<code>&#x3C;false/></code></li>\n</ul>\n<p>XML形式の例として、先程示したplistをXMLで表した表記を以下に示す。</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"hljs-meta\">&#x3C;!DOCTYPE <span class=\"hljs-meta-keyword\">plist</span> <span class=\"hljs-meta-keyword\">PUBLIC</span> <span class=\"hljs-meta-string\">\"-//Apple//DTD PLIST 1.0//EN\"</span> <span class=\"hljs-meta-string\">\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">plist</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.0\"</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">dict</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>hoge<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">string</span>></span>helloworld<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">string</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>boolean-example<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">false</span>/></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>wara<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">array</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">data</span>></span>\n    ASNFZ4mrze8=\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">data</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">integer</span>></span>123<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">integer</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">real</span>></span>0.5<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">real</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">true</span>/></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">date</span>></span>2019-09-16T05:45:42Z<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">date</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">array</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>fuga<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">dict</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>punipuni<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">string</span>></span>value<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">string</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">key</span>></span>p0y0p0y0<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">key</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">string</span>></span>0<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">string</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">dict</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">dict</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">plist</span>></span></code></pre>\n<h4>binary形式</h4>\n<p>テキストベースではなく人間が用意に読めなくした代わりに、ファイルサイズの削減と読み書きを高速化ができる形式。</p>\n<p>ここまでで述べたようにplistはバイナリデータも含むことができる。\nそのため、大きなバイナリデータを含むplistについては、old-style ASCIIやxmlでの表現は冗長で、ファイルが大きくなる、読み書きが遅くなるなどの問題が生まれる。\nこれを避けるためにバイナリ形式でデータを書き出すことができる。具体的な形式は未調査。</p>\n<p>おそらくあまり出会うことはないが、バイナリ形式には現在使われていない古い別形式もあるらしい。</p>\n<p>参考:  Plistの歴史</p>\n<ul>\n<li><a href=\"https://www.itmedia.co.jp/enterprise/articles/0705/14/news013_2.html\">第3回 plist（プロパティリスト）とFoundation【前編】 - ITmedia</a></li>\n<li><a href=\"https://www.itmedia.co.jp/enterprise/articles/0705/30/news011.html\">第4回 plist（プロパティリスト）とFoundation【後編】 - ITmedia</a></li>\n</ul>\n<h3>plistを操作できるデフォルトツール</h3>\n<p>plistを検証、確認、変更するコマンドラインツールが、Mac OS Xにはデフォルトでいくつか入っている。</p>\n<p><code>defaults</code>, <code>pl</code>, <code>plutil</code>, <code>/usr/libexec/PlistBuddy</code>を紹介する。</p>\n<h4>defaults</h4>\n<p>User Defaultsを読み書きするためのツール</p>\n<p>代表的な<code>read</code>,<code>write</code>,<code>import</code>,<code>export</code>のハマりどころを記す。</p>\n<ul>\n<li><code>$ defaults read</code></li>\n</ul>\n<p>\"ほぼ\"old-style ASCII形式で、User Defaultsを標準出力に出力する。\nold-style ASCIIには型情報を含まないので、型のみを調べる<code>$ defaults read-type</code>もある。</p>\n<p><strong>出力は正しい文法のold-style ASCII形式のplistとは限らない。大きなサイズのdata型の値は、一部省略して出力され、この部分は文法規則に反する。</strong>\n(これが原因で最初plistを正しく読み込めずに困った)</p>\n<p>readの後ろに引数を渡さないとすべてドメインのUser Defaultsを出力する。\n1コマンドでまとめて出力できるのは筆者の知る限り<code>$ defaults read</code>のみ。</p>\n<p>ネストしている深い値を指定して読むことはできない。</p>\n<ul>\n<li><code>$ defaults write</code></li>\n</ul>\n<p>引数にで値を指定して、User Defaultsに書き込める。\n型を区別するオプションを指定できる。</p>\n<p>data型は<code>-data</code>オプションをつけた上で、valueを16進数表記で記述する。</p>\n<p>date型は<code>-date</code>オプションをつけた上で、valueをISO8601形式で記述する。</p>\n<p>ネストしている深い値を指定して書き込むことはできない。</p>\n<ul>\n<li><code>$ defaults export</code></li>\n</ul>\n<p>特定のドメインのUser Defualtsをxml形式またはバイナリ形式で出力する。</p>\n<p>ドメインは必ず指定する必要があり、<code>$ defaults read</code>のようにすべてのドメインのUser Defaultsを一括して出力することはできない。</p>\n<ul>\n<li><code>$ defaults import</code></li>\n</ul>\n<p>xml形式またはバイナリ形式でUser Defaultsに書き込める。</p>\n<h4>pl</h4>\n<p>old-style ASCII形式のplistの文法をチェックするツール。</p>\n<h4>plutil</h4>\n<p>XML,binary形式のplistの文法をチェックするツール。</p>\n<p>値の読み書き/削除ができるが、深いネストしている深い値を指定して操作することはできない。</p>\n<ul>\n<li><a href=\"https://qiita.com/trakwkbys/items/a94c4d43342e96352bde\">コマンドラインでplistを操作（データ追加・編集・削除） - Qiita(@trakwkbys)</a></li>\n</ul>\n<h4>/usr/libexec/PlistBuddy</h4>\n<p>ネストしている深い値を直接指定して読み書き/削除できるスグレモノ。</p>\n<p>data型を書き込むときは、文字列がそのままbyte列として読み込まれるらしい。\nよって書き込める値が制限される。\nネストが深い場所にあるdata型の値を書き込む際は、xmlファイルに直接base64エンコードした文字列を書き込むなどすると良い。</p>\n<p>date型を書き込むときは、<code>Mon Apr 20 20:52:00 2020 JST</code>のような形式を渡す。\n(PlistBuddyのdata型の値書き込みに関するドキュメントは見つけられなかったが、<a href=\"https://github.com/darlinghq/darling/blob/master/src/PlistBuddy/PlistBuddy.c\">darling</a>の実装を参考にして実験し見つけた。)</p>\n<h2>plistファイルを読み書きする際の、Swiftでの実装</h2>\n<p>今回作成した<a href=\"https://github.com/yammerjp/pdef\">pdef</a>において、Swiftでplistを扱う際に肝になった部分を実装を交えて紹介する。</p>\n<p>ちなみにPythonでは<a href=\"https://docs.python.org/ja/3/library/plistlib.html\">plistlib</a>が使えるようだ。</p>\n<h3>plistファイル全体をNSDictionaryとして読み込む</h3>\n<p>plistファイルをSwiftの変数として扱えるように取り込むのは非常に簡単。\n下記のサンプルコードのように一行で読み込める。</p>\n<p>ファイル形式がold-style ASCIIだろうがxmlだろうがbinaryだろうが、勝手に判断してよしなにしてくれる。\n(ただし<a href=\"#defaults\">ハマりどころ</a>に注意)</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// https://github.com/yammerjp/pdef/blob/516f0215306b6ca206ebad646190ba74bd5d4b17/src/loadFile.swift</span>\n<span class=\"hljs-comment\">// 以上より一部抜粋</span>\n\n<span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> plist <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NSDictionary</span>(contentsOfFile: path) <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-type\">ErrorMessage</span>(<span class=\"hljs-string\">\"Failed to load property list '<span class=\"hljs-subst\">\\(path)</span>'\"</span>)\n  exit(<span class=\"hljs-number\">1</span>)\n}</code></pre>\n<p>pdefをSwiftで実装したのはplistを扱うのが楽だろうからという目論見だったが、それが一番功を奏したのがこの部分。</p>\n<h3>型を判別する</h3>\n<p>上記の方法でplistファイルをSwift内の変数として読み込んでも、型はすべてAnyとして扱われてしまう。\nこれは困るので、値を次のサンプルコードの関数<code>GetPlistType(value: Any) -> PlistType</code>に与えることで型を調べられる。\n型がわかればキャストできるので、その後Swiftで扱うのが楽になる。</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// https://github.com/yammerjp/pdef/blob/516f0215306b6ca206ebad646190ba74bd5d4b17/src/plist.swift</span>\n<span class=\"hljs-comment\">// 以上より一部抜粋、書き換え</span>\n\n<span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">PlistType</span>: <span class=\"hljs-title\">Int</span> </span>{\n  <span class=\"hljs-keyword\">case</span> string\n  <span class=\"hljs-keyword\">case</span> real\n  <span class=\"hljs-keyword\">case</span> integer\n  <span class=\"hljs-keyword\">case</span> bool\n  <span class=\"hljs-keyword\">case</span> data\n  <span class=\"hljs-keyword\">case</span> date\n  <span class=\"hljs-keyword\">case</span> array\n  <span class=\"hljs-keyword\">case</span> dict\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GetPlistType</span>(<span class=\"hljs-params\">value</span>: <span class=\"hljs-keyword\">Any</span>)</span> -> <span class=\"hljs-type\">PlistType</span> {\n  <span class=\"hljs-keyword\">let</span> typeID <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">CFGetTypeID</span>(value <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFTypeRef</span>?)\n  <span class=\"hljs-keyword\">switch</span> typeID {\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFNumberGetTypeID</span>():\n    <span class=\"hljs-keyword\">if</span> value <span class=\"hljs-keyword\">is</span> <span class=\"hljs-type\">NSInteger</span> {\n      <span class=\"hljs-keyword\">return</span> .integer\n    }\n    <span class=\"hljs-keyword\">return</span> .real\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFArrayGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .array\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFDictionaryGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .dict\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFStringGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .string\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFDataGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .data\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFDateGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .date\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">CFBooleanGetTypeID</span>():\n    <span class=\"hljs-keyword\">return</span> .bool\n  <span class=\"hljs-keyword\">default</span>:\n    exit(<span class=\"hljs-number\">1</span>)\n  }\n}</code></pre>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/documentation/corefoundation/cftypeid\">CFTypeID - Apple Developper Documantation</a>(Property listの型をSwiftで判別する)</li>\n<li><a href=\"https://qiita.com/junpluse/items/e334e511457f8c133de9\">Swift.Any as? CFType - Qiita(@junpluse)</a>(Property listの型をSwiftで判別する)</li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/Inspecting.html\">Inspecting Objects - Apple Developper Docuumentation</a>(Property listの型をSwiftで判別する)</li>\n</ul>\n<h2>おわりに</h2>\n<p>Swiftでplistを扱うための情報を集めるのに時間がかかったので、まとめる記事を書くに至った。</p>\n<p>この記事は<a href=\"/posts/pdef/\">Macの設定を自動化するdefaultsコマンドと、それを助けるpdef</a>(pdefの紹介記事)の余談と補足として作った。\nここまでの内容を実装して作った、User Defaults書き換えを支援するツールである<a href=\"https://github.com/yammerjp/pdef\">pdef</a>も興味があれば使ってみてほしい。</p>\n<p>User DefaultsだけでなくProperty listをSwiftで扱う際に、どこから手をつけてよいかわからない人が概要を掴むのにこの記事が役立てば幸いだ。</p>\n<hr>\n<p>追記: (2020/10/04) pdefの記事へのリンクを相対リンクに修正</p>\n","content_text":"Mac OS XのUser Defaultsを変更するためのシェルスクリプトを作るツール pdefを制作した。(解説記事: Macの設定を自動化するdefaultsコマンドと、それを助けるpdef)\n\nこれを作る際にProperty listについて学んだことを記す。\n\nUser Defaults\n\nUser Defaultsは、MacOSXやiOSにおける各アプリケーションが設定などを保持するためのデータベースである。\nUser Defaultsは、各アプリケーション(正確にはアプリケーションの持つドメイン)ごとにProperty listとして記録される。\n普段は各アプリケーションを通して読み書きされるが、ターミナル上からアクセスできる$ defaultsコマンドも提供されている。(後述)\n\nProperty list\n\nUser Defaultsに使われているproperty list(以下plist)は、Mac OS Xにおいてオブジェクトの永続化におけるファイル形式としてよく用いられている。\n例えば、iOSアプリを開発する際に自動生成されてXcode上から見えるinfo.plistがその例だ。\n\nplistはNeXTSTEP時代から続く歴史あるフォーマットらしい。時代背景も相まってファイルの保存形式は多数ある(後述)。\n\n論理構造\n\nplistはJSON等と同様のキーバリュー形式の論理構造を取る。\nキーに一対一対応する値が存在し、値は即値の他に入れ子状にデータを保持できる。\n\n値のとりうる型は次の通り。\n\n辞書(dictionary)\n\n配列(array)\n\n文字列(string)\n\n数値(number(integer and float))\n\n日付(date)\n\nバイナリ(binary data)\n\n真偽値(Boolean value)\n\nこの中でも辞書型と配列型は特殊で、辞書型はキーと値の組を、配列型は値を、子にもつことができる。\n\nJSONに無い型(日付,バイナリ)が存在するので、完全な相互変換は不可。\n\n参考: Property list - Apple Developper Documentation (plist関する公式のドキュメント)\n\n保存形式\n\nold-style ASCII形式\n\nテキストベースで、可読性が高いのがこの形式。NeXT形式とも呼ばれる?。NeXTSTEP時代にできた。\n作られた当時、文字列、配列、ディクショナリ、そしてバイナリデータのみを表現できたらしい。\nシンプルなフォーマットであるが、型情報がなく、型の判別が難しい。\n\n$ defaults readコマンドで出力される形式であり、現在では主にここでみられる。\n\nold-style ASCII形式の例として、あるplistをold-style ASCIIで表した表記を以下に示す。\n\n\n\nXML形式\n\nplistのデータ構造をXML形式で表現した形式。\n前述のold-style ASCIIのように欠けた情報がなく、なおかつ人間にも読めるのでplistをこねくり回す際にはお世話になるだろう。\n\nそれぞれの型におけるxml上での表記は次の通り\n\n辞書: \\<dict> \\<key>keystring\\</key> \\[value] (繰り返し) \\</dict>\n\n配列: \\<array> \\[vaule] (繰り返し) \\</array>\n\n文字列: \\<string>value\\</string>\n\n数値(整数): \\<integer>124234\\</integer>\n\n数値(浮動小数点数): \\<real>0.43\\</real>\n\n日付: \\<date>2019-09-16T05:45:42Z\\</date> (ISO8601と思われる)\n\nバイナリ: \\<data> ASNFZ4mrze8= \\</data> (base64でエンコード済みの文字列)\n\n真偽値: \\<true/>または\\<false/>\n\nXML形式の例として、先程示したplistをXMLで表した表記を以下に示す。\n\n\n\nbinary形式\n\nテキストベースではなく人間が用意に読めなくした代わりに、ファイルサイズの削減と読み書きを高速化ができる形式。\n\nここまでで述べたようにplistはバイナリデータも含むことができる。\nそのため、大きなバイナリデータを含むplistについては、old-style ASCIIやxmlでの表現は冗長で、ファイルが大きくなる、読み書きが遅くなるなどの問題が生まれる。\nこれを避けるためにバイナリ形式でデータを書き出すことができる。具体的な形式は未調査。\n\nおそらくあまり出会うことはないが、バイナリ形式には現在使われていない古い別形式もあるらしい。\n\n参考:  Plistの歴史\n\n第3回 plist（プロパティリスト）とFoundation【前編】 - ITmedia\n\n第4回 plist（プロパティリスト）とFoundation【後編】 - ITmedia\n\nplistを操作できるデフォルトツール\n\nplistを検証、確認、変更するコマンドラインツールが、Mac OS Xにはデフォルトでいくつか入っている。\n\ndefaults, pl, plutil, /usr/libexec/PlistBuddyを紹介する。\n\ndefaults\n\nUser Defaultsを読み書きするためのツール\n\n代表的なread,write,import,exportのハマりどころを記す。\n\n$ defaults read\n\n\"ほぼ\"old-style ASCII形式で、User Defaultsを標準出力に出力する。\nold-style ASCIIには型情報を含まないので、型のみを調べる$ defaults read-typeもある。\n\n出力は正しい文法のold-style ASCII形式のplistとは限らない。大きなサイズのdata型の値は、一部省略して出力され、この部分は文法規則に反する。\n(これが原因で最初plistを正しく読み込めずに困った)\n\nreadの後ろに引数を渡さないとすべてドメインのUser Defaultsを出力する。\n1コマンドでまとめて出力できるのは筆者の知る限り$ defaults readのみ。\n\nネストしている深い値を指定して読むことはできない。\n\n$ defaults write\n\n引数にで値を指定して、User Defaultsに書き込める。\n型を区別するオプションを指定できる。\n\ndata型は-dataオプションをつけた上で、valueを16進数表記で記述する。\n\ndate型は-dateオプションをつけた上で、valueをISO8601形式で記述する。\n\nネストしている深い値を指定して書き込むことはできない。\n\n$ defaults export\n\n特定のドメインのUser Defualtsをxml形式またはバイナリ形式で出力する。\n\nドメインは必ず指定する必要があり、$ defaults readのようにすべてのドメインのUser Defaultsを一括して出力することはできない。\n\n$ defaults import\n\nxml形式またはバイナリ形式でUser Defaultsに書き込める。\n\npl\n\nold-style ASCII形式のplistの文法をチェックするツール。\n\nplutil\n\nXML,binary形式のplistの文法をチェックするツール。\n\n値の読み書き/削除ができるが、深いネストしている深い値を指定して操作することはできない。\n\nコマンドラインでplistを操作（データ追加・編集・削除） - Qiita(@trakwkbys)\n\n/usr/libexec/PlistBuddy\n\nネストしている深い値を直接指定して読み書き/削除できるスグレモノ。\n\ndata型を書き込むときは、文字列がそのままbyte列として読み込まれるらしい。\nよって書き込める値が制限される。\nネストが深い場所にあるdata型の値を書き込む際は、xmlファイルに直接base64エンコードした文字列を書き込むなどすると良い。\n\ndate型を書き込むときは、Mon Apr 20 20:52:00 2020 JSTのような形式を渡す。\n(PlistBuddyのdata型の値書き込みに関するドキュメントは見つけられなかったが、darlingの実装を参考にして実験し見つけた。)\n\nplistファイルを読み書きする際の、Swiftでの実装\n\n今回作成したpdefにおいて、Swiftでplistを扱う際に肝になった部分を実装を交えて紹介する。\n\nちなみにPythonではplistlibが使えるようだ。\n\nplistファイル全体をNSDictionaryとして読み込む\n\nplistファイルをSwiftの変数として扱えるように取り込むのは非常に簡単。\n下記のサンプルコードのように一行で読み込める。\n\nファイル形式がold-style ASCIIだろうがxmlだろうがbinaryだろうが、勝手に判断してよしなにしてくれる。\n(ただしハマりどころに注意)\n\n\n\npdefをSwiftで実装したのはplistを扱うのが楽だろうからという目論見だったが、それが一番功を奏したのがこの部分。\n\n型を判別する\n\n上記の方法でplistファイルをSwift内の変数として読み込んでも、型はすべてAnyとして扱われてしまう。\nこれは困るので、値を次のサンプルコードの関数GetPlistType(value: Any) -> PlistTypeに与えることで型を調べられる。\n型がわかればキャストできるので、その後Swiftで扱うのが楽になる。\n\n\n\n参考:\n\nCFTypeID - Apple Developper Documantation(Property listの型をSwiftで判別する)\n\nSwift.Any as? CFType - Qiita(@junpluse)(Property listの型をSwiftで判別する)\n\nInspecting Objects - Apple Developper Docuumentation(Property listの型をSwiftで判別する)\n\nおわりに\n\nSwiftでplistを扱うための情報を集めるのに時間がかかったので、まとめる記事を書くに至った。\n\nこの記事はMacの設定を自動化するdefaultsコマンドと、それを助けるpdef(pdefの紹介記事)の余談と補足として作った。\nここまでの内容を実装して作った、User Defaults書き換えを支援するツールであるpdefも興味があれば使ってみてほしい。\n\nUser DefaultsだけでなくProperty listをSwiftで扱う際に、どこから手をつけてよいかわからない人が概要を掴むのにこの記事が役立てば幸いだ。\n\n\n\n追記: (2020/10/04) pdefの記事へのリンクを相対リンクに修正\n"},{"id":"http://localhost:3000/posts/pdef","url":"http://localhost:3000/posts/pdef","title":"Macの設定を自動化するdefaultsコマンドと、それを助けるpdef","summary":"tl;dr Mac OS XのUser Defaultsの差分をdefaultsコマンドの形式に変換するコマンドラインツール、\"pdef\"を作った。 本題(pdefでシェルスクリプトを作る)まで飛ばす defaultsコマンドでMacの設定を自動化する Macには、OSや各アプリの設定を保存するUser Defaultsというデータベースがある。 例えばドックの大きさやメニューバーに表示するアイコン、Safariの開発者ツールの有効化フラグ、(使用している場合は)サードパーティ製アプリケーションの設定情報なども記録されている。 これらのUser Defaultsの項目は普通、GUI上の設定画面","date_published":"2020-05-01T00:52:47+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Mac%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%82%92%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%99%E3%82%8Bdefaults%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%A8%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E5%8A%A9%E3%81%91%E3%82%8Bpdef,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","plist"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>tl;dr Mac OS XのUser Defaultsの差分をdefaultsコマンドの形式に変換するコマンドラインツール、<a href=\"https://github.com/yammerjp/pdef\">\"pdef\"</a>を作った。</p>\n<p><a href=\"#pdef%E3%81%A7%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8B\">本題(pdefでシェルスクリプトを作る)まで飛ばす</a></p>\n<h2>defaultsコマンドでMacの設定を自動化する</h2>\n<p>Macには、OSや各アプリの設定を保存するUser Defaultsというデータベースがある。\n例えばドックの大きさやメニューバーに表示するアイコン、Safariの開発者ツールの有効化フラグ、(使用している場合は)サードパーティ製アプリケーションの設定情報なども記録されている。</p>\n<p>これらのUser Defaultsの項目は普通、GUI上の設定画面を変更することでデータを読み書きするが、ターミナル上から操作するdefaultsコマンドなるものもMacに標準で入っている。</p>\n<p>これを用いることで、Macの初期設定を自動化するシェルスクリプトがよく作られているようだ。</p>\n<p>たとえば、次のスクリプトは、Finder(ファイラー)において、隠しファイル・隠しフォルダを表示する設定を有効にする。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/bash</span>\ndefaults write com.apple.finder AppleShowAllFiles YES</code></pre>\n<p>(スクリプト実行後に<code>$ killall Finder</code>としてアプリケーションを再起動する必要がある。)</p>\n<p>このようなdefaultsコマンドによる設定例はブログなどで見つけることができる。\nそれらをまとめて自分用のシェルスクリプトを作っておけば、Macを初期設定する際にすぐに自分好みの環境にすることができるというわけだ。</p>\n<p>GUIからの設定は項目が増えると手間がかかるし同じ環境を再現するのは大変なので、自動化できるのはありがたい。</p>\n<p>様々なdefaultsコマンドの一例を記載したサイト</p>\n<ul>\n<li><a href=\"https://neos21.hatenablog.com/entry/2019/01/10/080000\">MacOS で設定する defaults コマンドをまとめてみた - Corredor</a></li>\n<li><a href=\"https://qiita.com/ry0f/items/f2c75f0a77b1012182d6\">OS X を自分色に染める w/ defaults - Qiita(@ry0f)</a></li>\n<li><a href=\"https://qiita.com/idtkb/items/68c44c6f7ba1e15924bb\">Macの環境設定 - Qiita(@idtkb)</a></li>\n<li><a href=\"https://github.com/mathiasbynens/dotfiles/blob/master/.macos\">.macos - GitHub(mathiasbynens/dotfiles)</a></li>\n</ul>\n<h2>defaultsコマンドの引数を調べる</h2>\n<p>ところで、このdefaultsコマンドの引数はどのようにして知るのだろうか。\n先程のサイトに載っているものはよいものの、他の設定項目はdefaultsコマンドにどんな引数を渡せばよいのだろうか。\n私の調べた限りでは、公式なまとまった情報はないようだった。</p>\n<p>しかし、愚直に調査する方法はある。</p>\n<p>defaultsコマンドには、<code>$ defaults write</code>の他に<code>$ defaults read</code>というサブコマンドもある。これによりUser Defaultsを閲覧できる。\nGUI上の操作によってUser Defaultsにどんな変更が加わるか、変更前後の<code>$ defaults read</code>の出力を比較すればわかる。</p>\n<pre><code class=\"hljs language-sh\">$ defaults <span class=\"hljs-built_in\">read</span> > before.txt\n<span class=\"hljs-comment\"># GUI上で設定を変更する</span>\n$ defaults <span class=\"hljs-built_in\">read</span> > after.txt\n\n$ diff before.txt after.txt</code></pre>\n<p>diffで該当した部分を中心に、defaultsコマンドで指定する値を抜き出せばよい。</p>\n<p>が、<code>$ defaults read</code>の出力結果を読むのが面倒なので、これを自動で行うツールを作成した。</p>\n<p>(<code>$ defaults read</code>の出力形式は、property list(old-style ascii)である。\n<a href=\"/posts/plist/\">(余談) UserDefaultsとplistについて</a>として別記事にまとめたので、plistについてはこちらを参照してほしい。)</p>\n<h2>pdefでシェルスクリプトを作る</h2>\n<p>閑話休題</p>\n<h3>pdefとは</h3>\n<p><a href=\"https://github.com/yammerjp/pdef\">pdef</a> (pi:def) は、User Defaultsの設定前後の差分から、defaultsコマンドの引数を調べてくれる。</p>\n<p>引数に<code>$ defaults read</code>の出力を記録したファイルのパスを与える。 (第一引数に設定前、第二引数に設定後)\nすると、設定前後の差分から、シェルスクリプト(defaultsコマンドを並べたもの)を出力する。</p>\n<h3>インストール</h3>\n<pre><code class=\"hljs language-sh\">$ git <span class=\"hljs-built_in\">clone</span> https://github.com/yammerjp/pdef.git\n$ <span class=\"hljs-built_in\">cd</span> pdef\n$ make\n$ cp bin/pdef /user/<span class=\"hljs-built_in\">local</span>/bin</code></pre>\n<h3>使用例</h3>\n<p>次のように使う。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 設定を記録する</span>\n\n$ defaults <span class=\"hljs-built_in\">read</span> > before.txt\n<span class=\"hljs-comment\"># [GUI上で設定を変更する]</span>\n$ defaults <span class=\"hljs-built_in\">read</span> > after.txt\n$ pdef before.txt after.txt > patch.sh\n\n<span class=\"hljs-comment\"># 設定を復元する</span>\n\n$ bash patch.sh</code></pre>\n<p>使用例として、メニューバーの音量アイコンを表示/非表示している様子。</p>\n<p><img src=\"https://blob.yammer.jp/pdef-demo.gif\" alt=\"使用例のスクリーンショット\"></p>\n<p>Mac上で設定を変更するときに、前後で<code>$ defaults read</code>でUser Defaultsの内容を書き出しておくと、pdefを使って再設定が楽にできるという算段である。</p>\n<h3>オプション</h3>\n<p><code>--domain</code>オプションをつけると、特定のアプリのUser Defaultsも比較できる。(<code>$ defaults export hogehoge -</code>の出力等)\n<code>--domain</code>オプションをつけた際は、old-style asciiのplist以外にも、xmlやバイナリも読み込める。</p>\n<p>実行例</p>\n<pre><code class=\"hljs language-sh\">$ defaults <span class=\"hljs-built_in\">export</span> com.apple.systemuiserver - > before.xml\n<span class=\"hljs-comment\"># メニューバーの変更(音量アイコンの表示/非表示等)</span>\n$ defaults <span class=\"hljs-built_in\">export</span> com.apple.systemuiserver - > after.xml\n$ pdef --domain com.apple.systemuiserver before.xml after.xml</code></pre>\n<h3>例外</h3>\n<p>pdefは現在は以下のようなものには対応していない。</p>\n<ul>\n<li>data型の長い値 ( --domainオプションを付加すれば可能)</li>\n<li>keyのrename</li>\n<li>追加と削除が混在した差分</li>\n</ul>\n<h2>さいごに</h2>\n<p>インターネットの海に流れるdefaultsコマンドの設定例の他に、このツールで調べた設定を追加して、自分専用のMac設定用スクリプトの作成に役立てていただければ幸いだ。</p>\n<p>私のdefaultsコマンドを集めた<a href=\"https://github.com/yammerjp/dotfiles/tree/master/bin/user-default\">シェルスクリプトはこちら</a>。</p>\n<hr>\n<p>追記: (2020/10/04) plistへの記事リンクを相対リンクに修正</p>\n","content_text":"tl;dr Mac OS XのUser Defaultsの差分をdefaultsコマンドの形式に変換するコマンドラインツール、\"pdef\"を作った。\n\n本題(pdefでシェルスクリプトを作る)まで飛ばす\n\ndefaultsコマンドでMacの設定を自動化する\n\nMacには、OSや各アプリの設定を保存するUser Defaultsというデータベースがある。\n例えばドックの大きさやメニューバーに表示するアイコン、Safariの開発者ツールの有効化フラグ、(使用している場合は)サードパーティ製アプリケーションの設定情報なども記録されている。\n\nこれらのUser Defaultsの項目は普通、GUI上の設定画面を変更することでデータを読み書きするが、ターミナル上から操作するdefaultsコマンドなるものもMacに標準で入っている。\n\nこれを用いることで、Macの初期設定を自動化するシェルスクリプトがよく作られているようだ。\n\nたとえば、次のスクリプトは、Finder(ファイラー)において、隠しファイル・隠しフォルダを表示する設定を有効にする。\n\n\n\n(スクリプト実行後に$ killall Finderとしてアプリケーションを再起動する必要がある。)\n\nこのようなdefaultsコマンドによる設定例はブログなどで見つけることができる。\nそれらをまとめて自分用のシェルスクリプトを作っておけば、Macを初期設定する際にすぐに自分好みの環境にすることができるというわけだ。\n\nGUIからの設定は項目が増えると手間がかかるし同じ環境を再現するのは大変なので、自動化できるのはありがたい。\n\n様々なdefaultsコマンドの一例を記載したサイト\n\nMacOS で設定する defaults コマンドをまとめてみた - Corredor\n\nOS X を自分色に染める w/ defaults - Qiita(@ry0f)\n\nMacの環境設定 - Qiita(@idtkb)\n\n.macos - GitHub(mathiasbynens/dotfiles)\n\ndefaultsコマンドの引数を調べる\n\nところで、このdefaultsコマンドの引数はどのようにして知るのだろうか。\n先程のサイトに載っているものはよいものの、他の設定項目はdefaultsコマンドにどんな引数を渡せばよいのだろうか。\n私の調べた限りでは、公式なまとまった情報はないようだった。\n\nしかし、愚直に調査する方法はある。\n\ndefaultsコマンドには、$ defaults writeの他に$ defaults readというサブコマンドもある。これによりUser Defaultsを閲覧できる。\nGUI上の操作によってUser Defaultsにどんな変更が加わるか、変更前後の$ defaults readの出力を比較すればわかる。\n\n\n\ndiffで該当した部分を中心に、defaultsコマンドで指定する値を抜き出せばよい。\n\nが、$ defaults readの出力結果を読むのが面倒なので、これを自動で行うツールを作成した。\n\n($ defaults readの出力形式は、property list(old-style ascii)である。\n(余談) UserDefaultsとplistについてとして別記事にまとめたので、plistについてはこちらを参照してほしい。)\n\npdefでシェルスクリプトを作る\n\n閑話休題\n\npdefとは\n\npdef (pi:def) は、User Defaultsの設定前後の差分から、defaultsコマンドの引数を調べてくれる。\n\n引数に$ defaults readの出力を記録したファイルのパスを与える。 (第一引数に設定前、第二引数に設定後)\nすると、設定前後の差分から、シェルスクリプト(defaultsコマンドを並べたもの)を出力する。\n\nインストール\n\n\n\n使用例\n\n次のように使う。\n\n\n\n使用例として、メニューバーの音量アイコンを表示/非表示している様子。\n\n使用例のスクリーンショット\n\nMac上で設定を変更するときに、前後で$ defaults readでUser Defaultsの内容を書き出しておくと、pdefを使って再設定が楽にできるという算段である。\n\nオプション\n\n\\--domainオプションをつけると、特定のアプリのUser Defaultsも比較できる。($ defaults export hogehoge -の出力等)\n\\--domainオプションをつけた際は、old-style asciiのplist以外にも、xmlやバイナリも読み込める。\n\n実行例\n\n\n\n例外\n\npdefは現在は以下のようなものには対応していない。\n\ndata型の長い値 ( --domainオプションを付加すれば可能)\n\nkeyのrename\n\n追加と削除が混在した差分\n\nさいごに\n\nインターネットの海に流れるdefaultsコマンドの設定例の他に、このツールで調べた設定を追加して、自分専用のMac設定用スクリプトの作成に役立てていただければ幸いだ。\n\n私のdefaultsコマンドを集めたシェルスクリプトはこちら。\n\n\n\n追記: (2020/10/04) plistへの記事リンクを相対リンクに修正\n"},{"id":"http://localhost:3000/posts/macos-defaults","url":"http://localhost:3000/posts/macos-defaults","title":"macOSでの各種設定を自動化するdefaultsコマンド","summary":"研究室や就職先などでのコンピュータのセットアップのために、3月頃からdotfilesを構築している。 その流れでdefaultsコマンドを知ったので、その記録と使い方、調べ方を残しておく。。 defaultsコマンドとは macOSにおける環境設定や各アプリケーションの設定は.plist拡張子のプロパティリストと言われるファイルに記録される。 このプロパティリストを読み書きするためにmacOSに標準で搭載されているのがdefaultsコマンドである。 (詳細は$ man defaultsしてください。) これを利用して、OS全体の環境設定やアプリケーションの設定を自動化するスクリプトをつくって","date_published":"2020-04-13T21:57:37+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:macOS%E3%81%A7%E3%81%AE%E5%90%84%E7%A8%AE%E8%A8%AD%E5%AE%9A%E3%82%92%E8%87%AA%E5%8B%95%E5%8C%96%E3%81%99%E3%82%8Bdefaults%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["macOS","Shell","dotfiles","plist"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/10abacf2484fb0e6c7875db393ad0d3add6ff7ca","comment":"Update to move pictures to save on blob.basd4g.net\n","date_modified":"2020-12-24T22:37:31+09:00"}],"content_html":"<p>研究室や就職先などでのコンピュータのセットアップのために、3月頃から<a href=\"https://github.com/yammerjp/dotfiles\">dotfiles</a>を構築している。</p>\n<p>その流れでdefaultsコマンドを知ったので、その記録と使い方、調べ方を残しておく。。</p>\n<h2>defaultsコマンドとは</h2>\n<p>macOSにおける環境設定や各アプリケーションの設定は.plist拡張子の<a href=\"https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/AboutInformationPropertyListFiles.html\">プロパティリスト</a>と言われるファイルに記録される。\nこのプロパティリストを読み書きするためにmacOSに標準で搭載されているのがdefaultsコマンドである。\n(詳細は<code>$ man defaults</code>してください。)</p>\n<p>これを利用して、OS全体の環境設定やアプリケーションの設定を自動化するスクリプトをつくっている。(<a href=\"https://github.com/yammerjp/dotfiles/blob/master/bin/macos-defaults.sh\">実際に作ったスクリプト - yammerjp/dotfiles - GitHub</a>)</p>\n<p>今回はこのスクリプトを構築するための話。</p>\n<p>参考: <a href=\"https://support.apple.com/ja-jp/guide/terminal/apda49a1bb2-577e-4721-8f25-ffc0836f6997/mac\">Macの「ターミナル」でプロパティリストを編集する - ターミナルユーザガイド - Apple</a></p>\n<h2>他人の設定を拝借する</h2>\n<p>ネット上に他の人がどのコマンドを叩くとどの設定が変更できるかを調べてすでにまとめてくれたものがある。これを拝借するのが第一の手。</p>\n<p>公式でどこかに情報がまとまっていればよいのだが、「公式な」設定変更のやり方はGUIから変えることだからか、そんな丁寧なマニュアルはなさそう。</p>\n<ul>\n<li><a href=\"https://amasuda.xyz/post/2016-10-23-mastering-mac-defaults-command/\">MacOS defaults コマンドをマスターする - Think Abstract</a></li>\n<li><a href=\"https://neos21.hatenablog.com/entry/2019/01/10/080000\">MacOS で設定する defaults コマンドをまとめてみた - Corredor</a></li>\n<li><a href=\"https://qiita.com/djmonta/items/17531dde1e82d9786816\">ターミナルから Mac を設定する（defaults write コマンド等） - Qiita</a></li>\n<li><a href=\"https://qiita.com/ryuichi1208/items/5905240f3bfce793b33d\">iMac/MacBook購入後に必ず設定したい設定項目 - Qiita</a></li>\n<li><a href=\"https://oki2a24.com/2019/01/21/nitial-setting-done-manually-and-setting-with-defaults-command-on-macbook-pro-2018/\">Macbook Pro 2018 で手動で行った初期設定と、defaults コマンドを使った設定のメモ - Just another oki2a24 ブロゴ</a></li>\n<li><a href=\"https://ottan.xyz/system-preferences-terminal-defaults-2-4643/\">システム環境設定をターミナル（defaultsコマンド）から設定する方法（一般） - OTTAN.XYZ</a></li>\n<li><a href=\"https://matsuokah.hateblo.jp/entry/2016/01/01/161753\">OSXのコマンドラインからすると捗った設定リスト - will and way</a></li>\n<li><a href=\"http://www.neko.ne.jp/~freewing/software/macos_mojave_speed_up_setting_tips/\">macOS Mojaveを高速化する 20の効果的な設定、Macを買ったら最初に設定する俺チューン設定項目 - FREE WINGの Androidと Windows、中国語の便利ソフト</a></li>\n<li><a href=\"http://wordpress.ideacompo.com/?p=4826\">Tips of Rubbish DIYとIoTをこよなく愛する、WEB関連やデジモノなどの雑多な情報ブログ</a></li>\n</ul>\n<p><em>注釈: defaultsコマンドを実行すると、設定変更が即座に反映されるわけではない。以下のように再起動するなどして設定を読み込ませると良い。</em></p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># Dockの設定変更を反映</span>\n$ killall Dock\n<span class=\"hljs-comment\"># finderの設定変更を反映</span>\n$ killall Finder\n<span class=\"hljs-comment\"># メニューバー(画面上部)の設定変更を反映</span>\n$ killall SystemUIServer\n<span class=\"hljs-comment\"># その他駄目なら再起動。</span>\n$ sudo reboot</code></pre>\n<h2>設定するコマンドを探す</h2>\n<p>ネットを探していても自分の思うような設定がみつからないことがある。そのときは以下の手順で調べると見つかるかもしれない。</p>\n<h3>defaultsコマンドの使い方</h3>\n<p>前提として、manual(<code>$ man defaults</code>)の通り、defaultsコマンドは次のように使う。\n以下は簡略に示す。実際に実行する際はmanualを参照。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># すべて読む</span>\n$ defaults <span class=\"hljs-built_in\">read</span>\n\n<span class=\"hljs-comment\"># 読む</span>\n$ defaults <span class=\"hljs-built_in\">read</span> DOMAIN KEY\n$ defaults <span class=\"hljs-built_in\">read</span> -g KEY\n<span class=\"hljs-comment\"># 書き込む</span>\n$ defaults write DOMAIN KEY VALUE\n$ defaults write -g KEY VALUE</code></pre>\n<p>プロパティリストはkeyとvalueの対が原則で、jsonのようにvalueの中に入れ子でkeyとvalueのまとまりなどが入る。</p>\n<p>valueにはstringやdata, int, float, bool, array, dictなどの形式がある。</p>\n<p><code>$defaults write</code>する際にオプションで<code>-string</code>や<code>-array</code>, <code>-array-add</code>とすると希望のデータ型で値を書き込める。</p>\n<h3>探し方</h3>\n<p>設定変更前後のプロパティリストの差分から、それっぽい設定項目を見つける。\nその後実際に<code>$ defaults write</code>でプロパティリストを書き換えて、設定が反映されるかを確認する。</p>\n<p>このとき、設定変更のためのGUIウィンドウは予め開いておいて、beforeとafterの記録をすると良い。\nプロパティリストには我々が手動で設定した環境設定の他にも多用途に利用されているらしく、時間をあけるとあっという間にdiffが汚くなる。</p>\n<pre><code class=\"hljs language-sh\">$ defaults <span class=\"hljs-built_in\">read</span> > before\n\n<span class=\"hljs-comment\"># GUI上で設定を変更する</span>\n\n$ defaults <span class=\"hljs-built_in\">read</span> > after\n$ diff before after\n<span class=\"hljs-comment\"># colordiff(brew install colordiff)などを使うと捗る</span></code></pre>\n<h3>実際に探す一例</h3>\n<p>一例として、メニューバーに音量アイコンを表示する設定を探す。</p>\n<h4>プロパティリストを読む</h4>\n<p>GUIで設定する前後のプロパティリストを比較する。</p>\n<p><img src=\"https://blob.yammer.jp/macos-defaults-read.gif\" alt=\"プロパティリストを読み込むスクリーンショット\"></p>\n<pre><code class=\"hljs language-sh\">$ defaults <span class=\"hljs-built_in\">read</span> > before\n<span class=\"hljs-comment\"># GUIで設定変更</span>\n$ defaults <span class=\"hljs-built_in\">read</span> > after\n$ diff before after\n6504a6505\n>         <span class=\"hljs-string\">\"NSStatusItem Visible com.apple.menuextra.volume\"</span> = 1;\n6511c6512,6513\n&#x3C;             <span class=\"hljs-string\">\"/System/Library/CoreServices/Menu Extras/Bluetooth.menu\"</span>\n---\n>             <span class=\"hljs-string\">\"/System/Library/CoreServices/Menu Extras/Bluetooth.menu\"</span>,\n>             <span class=\"hljs-string\">\"/System/Library/CoreServices/Menu Extras/Volume.menu\"</span></code></pre>\n<p>差分を見ると、6500行目あたりに設定項目がありそう。</p>\n<p>実際にafterの6500行目以降の数行を見てみる。</p>\n<div class=\"remark-code-title\">after</div>\n<pre><code class=\"hljs language-plaintext\">     \"com.apple.systemuiserver\" =     {\n         \"NSStatusItem Visible com.apple.menuextra.airport\" = 1;\n         \"NSStatusItem Visible com.apple.menuextra.battery\" = 1;\n         \"NSStatusItem Visible com.apple.menuextra.bluetooth\" = 1;\n         \"NSStatusItem Visible com.apple.menuextra.clock\" = 1;\n         \"NSStatusItem Visible com.apple.menuextra.volume\" = 1;\n         \"__NSEnableTSMDocumentWindowLevel\" = 1;\n         \"last-analytics-stamp\" = \"608273612.570469\";\n         menuExtras =         (\n             \"/System/Library/CoreServices/Menu Extras/Clock.menu\",\n             \"/System/Library/CoreServices/Menu Extras/Battery.menu\",\n             \"/System/Library/CoreServices/Menu Extras/AirPort.menu\",\n             \"/System/Library/CoreServices/Menu Extras/Bluetooth.menu\",\n             \"/System/Library/CoreServices/Menu Extras/Volume.menu\"\n         );\n     };</code></pre>\n<p>以上より、設定は次の内容を書き込めば良さそう。</p>\n<ul>\n<li>ドメイン <code>com.apple.systemuiserver</code> 、キー <code>NSStatusItem Visible com.apple.menuextra.volume</code> に、値 <code>1</code> を設定する。</li>\n<li>ドメイン <code>com.apple.systemuiserver</code> 、キー <code>menuExtra</code> の値の配列に、</li>\n</ul>\n<p><code>/System/Library/CoreServices/Menu Extras/Volume.menu</code> を追加。</p>\n<p>シェルスクリプトにまとめると次の通り。</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash -e</span>\n\n<span class=\"hljs-comment\"># 音量アイコンをMenuBarに表示</span>\ndefaults write com.apple.systemuiserver \\\n  <span class=\"hljs-string\">\"NSStatusItem Visible com.apple.menuextra.volume\"</span> 1\n\ndefaults write com.apple.systemuiserver \\\n  menuExtras -array-add <span class=\"hljs-string\">\"/System/Library/CoreServices/Menu Extras/Volume.menu\"</span>\n\n<span class=\"hljs-comment\"># メニューバーを再起動</span>\nkillall SystemUIServer</code></pre>\n<h4>プロパティリストに書き込んで試す</h4>\n<p>実際に試してみると、反映されていることがわかる。</p>\n<p><img src=\"https://blob.yammer.jp/macos-defaults-write.gif\" alt=\"プロパティリストに書き込むスクリーンショット\"></p>\n<h2>なぜdefaultsコマンドを使うのか</h2>\n<h3>メリット</h3>\n<ul>\n<li>設定を自動化できる</li>\n</ul>\n<p>PCで新しく環境構築する際に、シェルスクリプトにまとまっているので一括で設定できる</p>\n<ul>\n<li>自分が行っていた設定を記録できる。</li>\n</ul>\n<p>自分がGUI上でどんな設定を行っているか、いたかをコードで示すことができる。\nアプリケーションがプロパティリストとしてデータを持っているならば、サードパーティアプリケーションでも同様に設定を記録できる。</p>\n<p>たとえば、私は<a href=\"https://github.com/fikovnik/ShiftIt\">ShiftIt</a>というアプリケーションを使っている。\nこのアプリケーションで使うキーバインドはGUI上から設定するのだが、自分がどんな設定をしているのかをコードとして記録できるのは、再設定だけでなく今後のなんらかのキーバインド設定の参考にもなる。</p>\n<p>参考: <a href=\"https://github.com/yammerjp/dotfiles/blob/master/bin/shiftit-init.sh\">私の現在のShiftItのキーバインド設定</a></p>\n<h3>デメリット</h3>\n<ul>\n<li>設定変更のたびに逐一調べてシェルスクリプトを更新しなければならない</li>\n</ul>\n<p>これはたしかに面倒だけどね。\nプロパティリストをむやみに書き換えると、パソコンが上手く動かなくなる可能性もある。。</p>\n<ul>\n<li>OSのアップデートによって設定が適用できなくなるかもしれない</li>\n</ul>\n<p>GUIもアップデートで項目がなくなったりどこにいったかわからなくなったりするよね</p>\n<h2>まとめ</h2>\n<p>以下を使って頑張ってシェルスクリプトを書こう。</p>\n<pre><code class=\"hljs language-sh\">$ defaults <span class=\"hljs-built_in\">read</span> > before\n<span class=\"hljs-comment\"># GUIで設定変更</span>\n$ defaults <span class=\"hljs-built_in\">read</span> > after\n$ diff before after\n\n$ man defaults</code></pre>\n<h2>将来の自分へ</h2>\n<p>diffを読み取ってdefaultsコマンドのシェルスクリプト形式にするのは自動化できるのでは？\nと思ったが、<a href=\"https://rcmdnk.com/blog/2015/03/22/computer-mac/\">先駆者がいたようだ</a></p>\n","content_text":"研究室や就職先などでのコンピュータのセットアップのために、3月頃からdotfilesを構築している。\n\nその流れでdefaultsコマンドを知ったので、その記録と使い方、調べ方を残しておく。。\n\ndefaultsコマンドとは\n\nmacOSにおける環境設定や各アプリケーションの設定は.plist拡張子のプロパティリストと言われるファイルに記録される。\nこのプロパティリストを読み書きするためにmacOSに標準で搭載されているのがdefaultsコマンドである。\n(詳細は$ man defaultsしてください。)\n\nこれを利用して、OS全体の環境設定やアプリケーションの設定を自動化するスクリプトをつくっている。(実際に作ったスクリプト - yammerjp/dotfiles - GitHub)\n\n今回はこのスクリプトを構築するための話。\n\n参考: Macの「ターミナル」でプロパティリストを編集する - ターミナルユーザガイド - Apple\n\n他人の設定を拝借する\n\nネット上に他の人がどのコマンドを叩くとどの設定が変更できるかを調べてすでにまとめてくれたものがある。これを拝借するのが第一の手。\n\n公式でどこかに情報がまとまっていればよいのだが、「公式な」設定変更のやり方はGUIから変えることだからか、そんな丁寧なマニュアルはなさそう。\n\nMacOS defaults コマンドをマスターする - Think Abstract\n\nMacOS で設定する defaults コマンドをまとめてみた - Corredor\n\nターミナルから Mac を設定する（defaults write コマンド等） - Qiita\n\niMac/MacBook購入後に必ず設定したい設定項目 - Qiita\n\nMacbook Pro 2018 で手動で行った初期設定と、defaults コマンドを使った設定のメモ - Just another oki2a24 ブロゴ\n\nシステム環境設定をターミナル（defaultsコマンド）から設定する方法（一般） - OTTAN.XYZ\n\nOSXのコマンドラインからすると捗った設定リスト - will and way\n\nmacOS Mojaveを高速化する 20の効果的な設定、Macを買ったら最初に設定する俺チューン設定項目 - FREE WINGの Androidと Windows、中国語の便利ソフト\n\nTips of Rubbish DIYとIoTをこよなく愛する、WEB関連やデジモノなどの雑多な情報ブログ\n\n注釈: defaultsコマンドを実行すると、設定変更が即座に反映されるわけではない。以下のように再起動するなどして設定を読み込ませると良い。\n\n\n\n設定するコマンドを探す\n\nネットを探していても自分の思うような設定がみつからないことがある。そのときは以下の手順で調べると見つかるかもしれない。\n\ndefaultsコマンドの使い方\n\n前提として、manual($ man defaults)の通り、defaultsコマンドは次のように使う。\n以下は簡略に示す。実際に実行する際はmanualを参照。\n\n\n\nプロパティリストはkeyとvalueの対が原則で、jsonのようにvalueの中に入れ子でkeyとvalueのまとまりなどが入る。\n\nvalueにはstringやdata, int, float, bool, array, dictなどの形式がある。\n\n$defaults writeする際にオプションで-stringや-array, -array-addとすると希望のデータ型で値を書き込める。\n\n探し方\n\n設定変更前後のプロパティリストの差分から、それっぽい設定項目を見つける。\nその後実際に$ defaults writeでプロパティリストを書き換えて、設定が反映されるかを確認する。\n\nこのとき、設定変更のためのGUIウィンドウは予め開いておいて、beforeとafterの記録をすると良い。\nプロパティリストには我々が手動で設定した環境設定の他にも多用途に利用されているらしく、時間をあけるとあっという間にdiffが汚くなる。\n\n\n\n実際に探す一例\n\n一例として、メニューバーに音量アイコンを表示する設定を探す。\n\nプロパティリストを読む\n\nGUIで設定する前後のプロパティリストを比較する。\n\nプロパティリストを読み込むスクリーンショット\n\n\n\n差分を見ると、6500行目あたりに設定項目がありそう。\n\n実際にafterの6500行目以降の数行を見てみる。\n\n\n\n以上より、設定は次の内容を書き込めば良さそう。\n\nドメイン com.apple.systemuiserver 、キー NSStatusItem Visible com.apple.menuextra.volume に、値 1 を設定する。\n\nドメイン com.apple.systemuiserver 、キー menuExtra の値の配列に、\n\n/System/Library/CoreServices/Menu Extras/Volume.menu を追加。\n\nシェルスクリプトにまとめると次の通り。\n\n\n\nプロパティリストに書き込んで試す\n\n実際に試してみると、反映されていることがわかる。\n\nプロパティリストに書き込むスクリーンショット\n\nなぜdefaultsコマンドを使うのか\n\nメリット\n\n設定を自動化できる\n\nPCで新しく環境構築する際に、シェルスクリプトにまとまっているので一括で設定できる\n\n自分が行っていた設定を記録できる。\n\n自分がGUI上でどんな設定を行っているか、いたかをコードで示すことができる。\nアプリケーションがプロパティリストとしてデータを持っているならば、サードパーティアプリケーションでも同様に設定を記録できる。\n\nたとえば、私はShiftItというアプリケーションを使っている。\nこのアプリケーションで使うキーバインドはGUI上から設定するのだが、自分がどんな設定をしているのかをコードとして記録できるのは、再設定だけでなく今後のなんらかのキーバインド設定の参考にもなる。\n\n参考: 私の現在のShiftItのキーバインド設定\n\nデメリット\n\n設定変更のたびに逐一調べてシェルスクリプトを更新しなければならない\n\nこれはたしかに面倒だけどね。\nプロパティリストをむやみに書き換えると、パソコンが上手く動かなくなる可能性もある。。\n\nOSのアップデートによって設定が適用できなくなるかもしれない\n\nGUIもアップデートで項目がなくなったりどこにいったかわからなくなったりするよね\n\nまとめ\n\n以下を使って頑張ってシェルスクリプトを書こう。\n\n\n\n将来の自分へ\n\ndiffを読み取ってdefaultsコマンドのシェルスクリプト形式にするのは自動化できるのでは？\nと思ったが、先駆者がいたようだ\n"},{"id":"http://localhost:3000/posts/vim-lsp-init","url":"http://localhost:3000/posts/vim-lsp-init","title":"vim-lspを使った、Vim上でのTypeScript(JavaScript)の補完の実現","summary":"LSPとは LSP(Language Server Protocol)とは、IDEと言語サーバとの通信用プロトコル。 IDEやテキストエディタが補完やコードジャンプなどの様々な機能を実現するために、以前はIDEやエディタのプラグイン内に内包されていた機能を、言語ごとにLanguage Serverとして切り出す。 これにより言語補完部分の製作はLanguage Serverさえ作ってしまえばたくさんのIDE(エディタ)に対応できるし、IDE(エディタ)開発側も、LSPにさえ対応してしまえば各言語への対応を独自実装しなくて済む。 2016年6月にMicrosoftが発表したらしい。 参考: la","date_published":"2020-04-01T17:37:46+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:vim-lsp%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E3%80%81Vim%E4%B8%8A%E3%81%A7%E3%81%AETypeScript(JavaScript)%E3%81%AE%E8%A3%9C%E5%AE%8C%E3%81%AE%E5%AE%9F%E7%8F%BE,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Vim","LSP","TypeScript","JavaScript"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>LSPとは</h2>\n<p><a href=\"https://github.com/Microsoft/language-server-protocol\">LSP(Language Server Protocol)</a>とは、IDEと言語サーバとの通信用プロトコル。</p>\n<p>IDEやテキストエディタが補完やコードジャンプなどの様々な機能を実現するために、以前はIDEやエディタのプラグイン内に内包されていた機能を、言語ごとにLanguage Serverとして切り出す。</p>\n<p>これにより言語補完部分の製作はLanguage Serverさえ作ってしまえばたくさんのIDE(エディタ)に対応できるし、IDE(エディタ)開発側も、LSPにさえ対応してしまえば各言語への対応を独自実装しなくて済む。</p>\n<p>2016年6月にMicrosoftが発表したらしい。</p>\n<p>参考: <a href=\"https://qiita.com/atsushieno/items/ce31df9bd88e98eec5c4\">language server protocolについて (前編) - Qiita</a></p>\n<h2>やること</h2>\n<p>今回はTypeScript,JavaScript用のLanguage Serverをインストールし、これをvim-lspにつないでvim上でLanguage Serverの支援が得られるようにする。</p>\n<p>( <a href=\"https://github.com/prabirshrestha/vim-lsp\">vim-lsp</a>はvimでLanguage Serverを利用できるようにするプラグイン )</p>\n<h2>環境</h2>\n<ul>\n<li>macOS Mojave(10.14.6)</li>\n<li>VIM 8.2  Compiled by Homebrew</li>\n<li>dein.vimでプラグイン管理</li>\n</ul>\n<p>Vim8上で、dein.vimにプラグインを読み込ませる。</p>\n<h2>手順</h2>\n<ol>\n<li>typescript-language-serverをインストールする</li>\n</ol>\n<pre><code class=\"hljs language-sh\">$ npm install -g typescript typescript-language-server\n<span class=\"hljs-comment\"># または</span>\n$ yarn global add typescript typescript-language-server</code></pre>\n<p>typescript-language-serverはJavaScriptのLanguage Serverとしても動く</p>\n<ol start=\"2\">\n<li>各種vimプラグインを入れる</li>\n</ol>\n<p>dein.tomlに以下の記述を追記</p>\n<div class=\"remark-code-title\">dein.toml</div>\n<pre><code class=\"hljs language-toml\"><span class=\"hljs-comment\">#========== vim-lsp とその関連プラグイン ==========</span>\n<span class=\"hljs-comment\">#vim-lspとLanguage Serverの連携に必要なプラグイン群</span>\n<span class=\"hljs-section\">[[plugins]]</span>\n<span class=\"hljs-attr\">repo</span> = <span class=\"hljs-string\">'prabirshrestha/async.vim'</span>\n<span class=\"hljs-section\">[[plugins]]</span>\n<span class=\"hljs-attr\">repo</span> = <span class=\"hljs-string\">'prabirshrestha/asyncomplete.vim'</span>\n<span class=\"hljs-section\">[[plugins]]</span>\n<span class=\"hljs-attr\">repo</span> = <span class=\"hljs-string\">'prabirshrestha/asyncomplete-lsp.vim'</span>\n\n<span class=\"hljs-comment\"># 事前にnpm install -g typescript typescript-language-server </span>\n<span class=\"hljs-section\">[[plugins]]</span>\n<span class=\"hljs-attr\">repo</span> = <span class=\"hljs-string\">'prabirshrestha/vim-lsp'</span>\n<span class=\"hljs-attr\">hook_add</span> = <span class=\"hljs-string\">'''\n\" TypeScript, JavaScript\nif executable('typescript-language-server')\n    au User lsp_setup call lsp#register_server({\n        \\ 'name': 'typescript-language-server',\n        \\ 'cmd': {server_info->[&#x26;shell, &#x26;shellcmdflag, 'typescript-language-server --stdio']},\n        \\ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'package.json'))},\n\"       \\ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'tsconfig.json'))},\n        \\ 'whitelist': ['typescript', 'typescript.tsx', 'javascript', 'javascript.jsx'],\n        \\ })\nendif\n\n\" 他言語サーバの読み込みはここに挿入\n'''</span>\n\n<span class=\"hljs-comment\">#vim-lspのキーバインドを設定</span>\n後で書く</code></pre>\n<ol start=\"3\">\n<li>vimを起動</li>\n</ol>\n<pre><code class=\"hljs language-sh\">$ vim</code></pre>\n","content_text":"LSPとは\n\nLSP(Language Server Protocol)とは、IDEと言語サーバとの通信用プロトコル。\n\nIDEやテキストエディタが補完やコードジャンプなどの様々な機能を実現するために、以前はIDEやエディタのプラグイン内に内包されていた機能を、言語ごとにLanguage Serverとして切り出す。\n\nこれにより言語補完部分の製作はLanguage Serverさえ作ってしまえばたくさんのIDE(エディタ)に対応できるし、IDE(エディタ)開発側も、LSPにさえ対応してしまえば各言語への対応を独自実装しなくて済む。\n\n2016年6月にMicrosoftが発表したらしい。\n\n参考: language server protocolについて (前編) - Qiita\n\nやること\n\n今回はTypeScript,JavaScript用のLanguage Serverをインストールし、これをvim-lspにつないでvim上でLanguage Serverの支援が得られるようにする。\n\n( vim-lspはvimでLanguage Serverを利用できるようにするプラグイン )\n\n環境\n\nmacOS Mojave(10.14.6)\n\nVIM 8.2  Compiled by Homebrew\n\ndein.vimでプラグイン管理\n\nVim8上で、dein.vimにプラグインを読み込ませる。\n\n手順\n\ntypescript-language-serverをインストールする\n\n\n\ntypescript-language-serverはJavaScriptのLanguage Serverとしても動く\n\n各種vimプラグインを入れる\n\ndein.tomlに以下の記述を追記\n\n\n\nvimを起動\n\n"},{"id":"http://localhost:3000/posts/20200330","url":"http://localhost:3000/posts/20200330","title":"今日欲しい物(2020/3/30)","summary":"欲しい物 ほしいと思ったものの記録。 docomo系MVNOのSIM 60%の自作キーボード ヘッドホン docomo系のMVNOのSIM 昨年macを買ったのに合わせて初めてiphoneを購入し、それ以降iphone7を使い続けているが、そろそろandroidに戻りたい気持ちが強くなってきた。 ビッグローブの3GB音声通話有りのプランは、半年間400円で使えて2500円キャッシュバックが有るらしい。 iphone7に挿しているsimは最近UQmobileに乗り換えたばかりだし、UQmobileの回線速度は素晴らしいので、乗り換えるのは早計かなと思っている。 しかしUQmobileのsimが使","date_published":"2020-03-30T10:06:22+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E4%BB%8A%E6%97%A5%E6%AC%B2%E3%81%97%E3%81%84%E7%89%A9(2020%2F3%2F30),w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["日記","欲しい物"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>欲しい物</h2>\n<p>ほしいと思ったものの記録。</p>\n<ul>\n<li>docomo系MVNOのSIM</li>\n<li>60%の自作キーボード</li>\n<li>ヘッドホン</li>\n</ul>\n<h2>docomo系のMVNOのSIM</h2>\n<p>昨年macを買ったのに合わせて初めてiphoneを購入し、それ以降iphone7を使い続けているが、そろそろandroidに戻りたい気持ちが強くなってきた。</p>\n<p><a href=\"https://www.amazon.co.jp/dp/B072PS4Q3H/ref=sspa_dk_detail_0?psc=1&#x26;pd_rd_i=B072PS4Q3H&#x26;pd_rd_w=MtTuU&#x26;pf_rd_p=6413bd85-d494-49e7-9f81-0e63e79171a9&#x26;pd_rd_wg=eJADD&#x26;pf_rd_r=9K6KRSP0W1DSTS5MQEPK&#x26;pd_rd_r=f0f592c6-efca-451e-ad83-7a5fe8f4bfe2&#x26;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUExU1g2MENHQ0VZWEtGJmVuY3J5cHRlZElkPUEwNTQ2MDM2MklSSzVWVDlJQUFVQiZlbmNyeXB0ZWRBZElkPUE2V1UwTDFMNjBLM04md2lkZ2V0TmFtZT1zcF9kZXRhaWwmYWN0aW9uPWNsaWNrUmVkaXJlY3QmZG9Ob3RMb2dDbGljaz10cnVl\">ビッグローブの3GB音声通話有りのプラン</a>は、半年間400円で使えて2500円キャッシュバックが有るらしい。</p>\n<p>iphone7に挿しているsimは最近UQmobileに乗り換えたばかりだし、UQmobileの回線速度は素晴らしいので、乗り換えるのは早計かなと思っている。</p>\n<p>しかしUQmobileのsimが使える端末が手元にないので、とりあえずdocomo系のsimを契約して2台持ちにしようかと検討している。\n今、お金をほとんど使わずに不満を解消できるのが2台持ち。</p>\n<p>しばらくしたらUQmobileでも使えるandroidを買うか、androidへ乗り換える夢を諦めるか、メインの回線をdocomo系のMVNOに乗り換えるかしよう。</p>\n<p>以下はiphoneを一年弱使った感想。</p>\n<p>生粋のandroid人間だったので、操作感など最初は中々慣れなかった。</p>\n<h3>iphoneの不満</h3>\n<ul>\n<li>オートメーションで位置情報による自動実行、WIFI接続時の自動実行が出来ない。</li>\n</ul>\n<p>家の鍵(Sesami mini)を、帰宅/外出を自動検知しAPIを叩いて自動開閉をしたい。\nandroidならIFTTTで実現できそう。</p>\n<ul>\n<li>OK googleしたい</li>\n</ul>\n<p>スマホの音声操作は車を運転するときに真価を発揮する。</p>\n<p>Googleマップの検索と案内開始、音楽再生をどちらも音声操作だけで完結できるのでGoogleアシスタントを使いたい。</p>\n<p>夏、特にダイビングに行くときに車を運転するので、今後もっとandroidが欲しくなるはず。</p>\n<p>(注:Siriは○ソ。使えない。自明。)</p>\n<ul>\n<li>公式ストア外のアプリをインストールできない。</li>\n</ul>\n<p>セキュリティ的には良いところなのだが。(一般向けのスマートフォンOSの戦略としては正解だと思う)</p>\n<p>私には自由が必要なのだ、androidのような自由が。</p>\n<h3>iphoneのいいところ</h3>\n<ul>\n<li>テザリング時にスマホを操作しなくて良い</li>\n</ul>\n<p>iphoneからmacへテザリングする際に、ポケットに入ったiphoneに指一本触れずにMac上からテザリングを有効化できる。Apple帝国に納税した分の福利厚生といったところか。</p>\n<ul>\n<li>セキュリティが安心</li>\n</ul>\n<p>政府要人でもないし抜かれる個人情報も大したこと無いけれど、国を敵に回してもiphoneには容易にはデータにアクセス出来なそう。\n(ただし、端末内のデータにアクセスできないからと言って安全とは限らない。PCやWebサービスのデータベースの情報を抜かれるかもしれない)</p>\n<h2>60%の自作キーボード</h2>\n<p>ちょっと前はHHKBを狙っていたけれど、高いし、「あれ、俺がほしいのはHHKBではなくUS配列60%キーボードだ」と気づいた。</p>\n<p>ここ1ヶ月ほどKarabinerでSandS(スペースバーを他キーと同時に押すとShiftキーとして扱う)を設定している。\nこれに味をシメて、数字キーのShift動作を反転させて、普段は記号、Shiftキー(SandSなので実際はスペースバー)が押されているときは数字が入力されるようにしようとしていた。</p>\n<p>こんなふうに配列をいじっていると、はたしてこのまま日本語配列でよいのかと思ってくる。\nUSキーボードの配列に慣れておいたほうがキーボードの選択肢が広がる(自作キーボードをするとき)し、かっこいい(厨2)(要出典)し、エンターキー押しやすそうだし、記号も自然な配列と聞くので、さっさとUSにしないと。</p>\n<p>KBDfansを見ていると頑張って安いものを選べば1.3万円くらいでできそう。</p>\n<p>自分への誕生日プレゼントとしてひとつ組んでみようかな。</p>\n<h2>ヘッドホン</h2>\n<p>5000円未満で音質が結構良いらしいヘッドホン、<a href=\"https://www.amazon.co.jp/%E3%83%9E%E3%83%A9%E3%83%B3%E3%83%84%E3%83%97%E3%83%AD-Marantz-Professional-MPH-1-%E5%AF%86%E9%96%89%E5%9E%8B%E3%83%A2%E3%83%8B%E3%82%BF%E3%83%BC%E3%83%98%E3%83%83%E3%83%89%E3%83%9B%E3%83%B3/dp/B01E74L2L0?psc=1&#x26;SubscriptionId=AKIAICDGYC76ENTD3PNA&#x26;tag=menbou0202-22&#x26;linkCode=xm2&#x26;camp=2025&#x26;creative=165953&#x26;creativeASIN=B01E74L2L0\">マランツプロ MPH-1</a>。</p>\n<p>今はSonyのXDR-XB950というヘッドホンを3年以上使っている。\nbluetoothのヘッドホンは本当に素晴らしくて、無線は本当に快適。\nバッテリーも公称40時間持つとかで、最近のワイヤレスイヤホンとは比較にならないほど持つ。</p>\n<p>ただ、音質はそこまで良くないと思う。bluetoothということで、ホワイトノイズも目立つ。</p>\n<p>次買うならSonyかboseの4万円くらいするワイヤレスヘッドホンなのだけれど、高いのでおいそれと手が出ない。</p>\n<p>そんなときに下を見つけた。\nギズモード・ジャパンの網藤さんのブログで見つけた、5000円のヘッドホン。</p>\n<p><a href=\"https://men-bou.net/mph-1-under-5000/\">アンダー5,000円のモニタリングヘッドホン「MPH-1」は脊髄で買っていいくらい高コスパ - MENBOU</a></p>\n<p>この価格帯で推せるヘッドホンが有るのはアツイ。</p>\n<p>2020年に有線ヘッドホンを買うかは迷いどころだけれど、机に座っているとき専用だったら有線でもまぁいいかな。</p>\n<p>現状に困っているわけではないので、なんだかんだ買わない気もするけれど。</p>\n","content_text":"欲しい物\n\nほしいと思ったものの記録。\n\ndocomo系MVNOのSIM\n\n60%の自作キーボード\n\nヘッドホン\n\ndocomo系のMVNOのSIM\n\n昨年macを買ったのに合わせて初めてiphoneを購入し、それ以降iphone7を使い続けているが、そろそろandroidに戻りたい気持ちが強くなってきた。\n\nビッグローブの3GB音声通話有りのプランは、半年間400円で使えて2500円キャッシュバックが有るらしい。\n\niphone7に挿しているsimは最近UQmobileに乗り換えたばかりだし、UQmobileの回線速度は素晴らしいので、乗り換えるのは早計かなと思っている。\n\nしかしUQmobileのsimが使える端末が手元にないので、とりあえずdocomo系のsimを契約して2台持ちにしようかと検討している。\n今、お金をほとんど使わずに不満を解消できるのが2台持ち。\n\nしばらくしたらUQmobileでも使えるandroidを買うか、androidへ乗り換える夢を諦めるか、メインの回線をdocomo系のMVNOに乗り換えるかしよう。\n\n以下はiphoneを一年弱使った感想。\n\n生粋のandroid人間だったので、操作感など最初は中々慣れなかった。\n\niphoneの不満\n\nオートメーションで位置情報による自動実行、WIFI接続時の自動実行が出来ない。\n\n家の鍵(Sesami mini)を、帰宅/外出を自動検知しAPIを叩いて自動開閉をしたい。\nandroidならIFTTTで実現できそう。\n\nOK googleしたい\n\nスマホの音声操作は車を運転するときに真価を発揮する。\n\nGoogleマップの検索と案内開始、音楽再生をどちらも音声操作だけで完結できるのでGoogleアシスタントを使いたい。\n\n夏、特にダイビングに行くときに車を運転するので、今後もっとandroidが欲しくなるはず。\n\n(注:Siriは○ソ。使えない。自明。)\n\n公式ストア外のアプリをインストールできない。\n\nセキュリティ的には良いところなのだが。(一般向けのスマートフォンOSの戦略としては正解だと思う)\n\n私には自由が必要なのだ、androidのような自由が。\n\niphoneのいいところ\n\nテザリング時にスマホを操作しなくて良い\n\niphoneからmacへテザリングする際に、ポケットに入ったiphoneに指一本触れずにMac上からテザリングを有効化できる。Apple帝国に納税した分の福利厚生といったところか。\n\nセキュリティが安心\n\n政府要人でもないし抜かれる個人情報も大したこと無いけれど、国を敵に回してもiphoneには容易にはデータにアクセス出来なそう。\n(ただし、端末内のデータにアクセスできないからと言って安全とは限らない。PCやWebサービスのデータベースの情報を抜かれるかもしれない)\n\n60%の自作キーボード\n\nちょっと前はHHKBを狙っていたけれど、高いし、「あれ、俺がほしいのはHHKBではなくUS配列60%キーボードだ」と気づいた。\n\nここ1ヶ月ほどKarabinerでSandS(スペースバーを他キーと同時に押すとShiftキーとして扱う)を設定している。\nこれに味をシメて、数字キーのShift動作を反転させて、普段は記号、Shiftキー(SandSなので実際はスペースバー)が押されているときは数字が入力されるようにしようとしていた。\n\nこんなふうに配列をいじっていると、はたしてこのまま日本語配列でよいのかと思ってくる。\nUSキーボードの配列に慣れておいたほうがキーボードの選択肢が広がる(自作キーボードをするとき)し、かっこいい(厨2)(要出典)し、エンターキー押しやすそうだし、記号も自然な配列と聞くので、さっさとUSにしないと。\n\nKBDfansを見ていると頑張って安いものを選べば1.3万円くらいでできそう。\n\n自分への誕生日プレゼントとしてひとつ組んでみようかな。\n\nヘッドホン\n\n5000円未満で音質が結構良いらしいヘッドホン、マランツプロ MPH-1。\n\n今はSonyのXDR-XB950というヘッドホンを3年以上使っている。\nbluetoothのヘッドホンは本当に素晴らしくて、無線は本当に快適。\nバッテリーも公称40時間持つとかで、最近のワイヤレスイヤホンとは比較にならないほど持つ。\n\nただ、音質はそこまで良くないと思う。bluetoothということで、ホワイトノイズも目立つ。\n\n次買うならSonyかboseの4万円くらいするワイヤレスヘッドホンなのだけれど、高いのでおいそれと手が出ない。\n\nそんなときに下を見つけた。\nギズモード・ジャパンの網藤さんのブログで見つけた、5000円のヘッドホン。\n\nアンダー5,000円のモニタリングヘッドホン「MPH-1」は脊髄で買っていいくらい高コスパ - MENBOU\n\nこの価格帯で推せるヘッドホンが有るのはアツイ。\n\n2020年に有線ヘッドホンを買うかは迷いどころだけれど、机に座っているとき専用だったら有線でもまぁいいかな。\n\n現状に困っているわけではないので、なんだかんだ買わない気もするけれど。\n"},{"id":"http://localhost:3000/posts/book-memo-do-now","url":"http://localhost:3000/posts/book-memo-do-now","title":"すぐやる人に変わる方法","summary":"2017年11月頃のメモを移動。以下、 先送りせずにすぐやる人に変わる方法 (中経の文庫)を読んだ際のメモだと思われる。 優先度を比較する「前」にやってしまう 「快楽を捨てること」と「苦痛を選択する」ということの2つのことを一度にやろうとしてはダメ まず「快楽を捨てる」ことだけに、全神経を集中 すぐに実行できるところまで分解する どんどん分解する癖がつけば自然と「すぐやる」人になれる 誘導タスクを設定する メールは「下書き」をしておく いまの状況を正直に伝える .. そういうときは、ざっと目を通して、簡単な感想を概ねポジティブに書いて出す 以下軽く目を通して考えてから採用すること すぐやる人は","date_published":"2020-03-28T11:52:38+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%81%99%E3%81%90%E3%82%84%E3%82%8B%E4%BA%BA%E3%81%AB%E5%A4%89%E3%82%8F%E3%82%8B%E6%96%B9%E6%B3%95,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["本"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<p>2017年11月頃のメモを移動。以下、\n<a href=\"https://www.amazon.co.jp/%E5%85%88%E9%80%81%E3%82%8A%E3%81%9B%E3%81%9A%E3%81%AB%E3%81%99%E3%81%90%E3%82%84%E3%82%8B%E4%BA%BA%E3%81%AB%E5%A4%89%E3%82%8F%E3%82%8B%E6%96%B9%E6%B3%95-%E4%B8%AD%E7%B5%8C%E3%81%AE%E6%96%87%E5%BA%AB-%E4%BD%90%E3%80%85%E6%9C%A8-%E6%AD%A3%E6%82%9F-ebook/dp/B00ARBMSQG\">先送りせずにすぐやる人に変わる方法 (中経の文庫)</a>を読んだ際のメモだと思われる。</p>\n<ul>\n<li>\n<p>優先度を比較する「前」にやってしまう</p>\n</li>\n<li>\n<p>「快楽を捨てること」と「苦痛を選択する」ということの2つのことを一度にやろうとしてはダメ まず「快楽を捨てる」ことだけに、全神経を集中</p>\n</li>\n<li>\n<p>すぐに実行できるところまで分解する どんどん分解する癖がつけば自然と「すぐやる」人になれる</p>\n</li>\n<li>\n<p>誘導タスクを設定する</p>\n</li>\n<li>\n<p>メールは「下書き」をしておく</p>\n</li>\n<li>\n<p>いまの状況を正直に伝える .. そういうときは、ざっと目を通して、簡単な感想を概ねポジティブに書いて出す</p>\n</li>\n<li>\n<p>以下軽く目を通して考えてから採用すること</p>\n</li>\n<li>\n<p>すぐやる人は肩の力が抜けている</p>\n</li>\n<li>\n<p>やりたいことを増やさない</p>\n</li>\n<li>\n<p>一気にやる快感に気をつける 溜める量を減らしていく</p>\n</li>\n<li>\n<p>締め切りが無くても動ける方法を探す 自分で設定したデッドラインでできたという経験を多く持つ</p>\n</li>\n</ul>\n","content_text":"2017年11月頃のメモを移動。以下、\n先送りせずにすぐやる人に変わる方法 (中経の文庫)を読んだ際のメモだと思われる。\n\n優先度を比較する「前」にやってしまう\n\n「快楽を捨てること」と「苦痛を選択する」ということの2つのことを一度にやろうとしてはダメ まず「快楽を捨てる」ことだけに、全神経を集中\n\nすぐに実行できるところまで分解する どんどん分解する癖がつけば自然と「すぐやる」人になれる\n\n誘導タスクを設定する\n\nメールは「下書き」をしておく\n\nいまの状況を正直に伝える .. そういうときは、ざっと目を通して、簡単な感想を概ねポジティブに書いて出す\n\n以下軽く目を通して考えてから採用すること\n\nすぐやる人は肩の力が抜けている\n\nやりたいことを増やさない\n\n一気にやる快感に気をつける 溜める量を減らしていく\n\n締め切りが無くても動ける方法を探す 自分で設定したデッドラインでできたという経験を多く持つ\n"},{"id":"http://localhost:3000/posts/virtualization","url":"http://localhost:3000/posts/virtualization","title":"仮想化","summary":"過去の自分向けメモを移動。以下、2019/4/27頃のメモである。 最近大学でOSの授業が始まった。 OSの基本的な役割として挙げられるのが、計算資源の管理とハードウェアの仮想化だそうな。 仮想化と聞くとVirtual Machineを使ったサーバー仮想化などあるが、それよりももっと前から仮想化という概念は存在していて。 CPUのハイパースレッディングテクノロジーなんかはCPUの仮想化。 デバイスドライバを介した入出力機器の仮想化。ファイルシステムによりデータを抽象的に操作できるハードディスクの仮想化。アドレスを意識する必要のないメモリの仮想化。 仮想化といわれると、以前はエミュレータなんかに","date_published":"2020-03-28T11:48:13+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E4%BB%AE%E6%83%B3%E5%8C%96,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["仮想化","お気持ち"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<p>過去の自分向けメモを移動。以下、2019/4/27頃のメモである。</p>\n<p>最近大学でOSの授業が始まった。</p>\n<p>OSの基本的な役割として挙げられるのが、計算資源の管理とハードウェアの仮想化だそうな。</p>\n<p>仮想化と聞くとVirtual Machineを使ったサーバー仮想化などあるが、それよりももっと前から仮想化という概念は存在していて。\nCPUのハイパースレッディングテクノロジーなんかはCPUの仮想化。\nデバイスドライバを介した入出力機器の仮想化。ファイルシステムによりデータを抽象的に操作できるハードディスクの仮想化。アドレスを意識する必要のないメモリの仮想化。</p>\n<p>仮想化といわれると、以前はエミュレータなんかに近いものを想像していた。</p>\n<p>しかしOSがハードウェアを仮想化しているということを意識すると言葉のイメージが変わった。\n仮想化(=抽象化)というのは、カプセル化だったり、階層化という概念に近く、コンピュータの中でごく一般的に広く用いられている手法ではないか？</p>\n<p>そこまで考えを広げたうえで、昨今のデータセンタ内の仮想化技術(サーバー、ストレージ、ネットワーク、、)は自然の流れとも言える。\n今まで使っていたハードウェアないしレイヤーを更に仮想的に(抽象的に、ソフトウェア的に)扱いやすくした、レイヤーが一層加わっただけである。</p>\n<p>大学1年のとき、某企業でデータセンタに関するソリューション提案のインターンをした。そのときは仮想化どころかデータセンタに関する知識が少なくて学ぶことばかりでついていくのもやっとだったけれど、概念の理解は当時より進んだと思う。</p>\n","content_text":"過去の自分向けメモを移動。以下、2019/4/27頃のメモである。\n\n最近大学でOSの授業が始まった。\n\nOSの基本的な役割として挙げられるのが、計算資源の管理とハードウェアの仮想化だそうな。\n\n仮想化と聞くとVirtual Machineを使ったサーバー仮想化などあるが、それよりももっと前から仮想化という概念は存在していて。\nCPUのハイパースレッディングテクノロジーなんかはCPUの仮想化。\nデバイスドライバを介した入出力機器の仮想化。ファイルシステムによりデータを抽象的に操作できるハードディスクの仮想化。アドレスを意識する必要のないメモリの仮想化。\n\n仮想化といわれると、以前はエミュレータなんかに近いものを想像していた。\n\nしかしOSがハードウェアを仮想化しているということを意識すると言葉のイメージが変わった。\n仮想化(=抽象化)というのは、カプセル化だったり、階層化という概念に近く、コンピュータの中でごく一般的に広く用いられている手法ではないか？\n\nそこまで考えを広げたうえで、昨今のデータセンタ内の仮想化技術(サーバー、ストレージ、ネットワーク、、)は自然の流れとも言える。\n今まで使っていたハードウェアないしレイヤーを更に仮想的に(抽象的に、ソフトウェア的に)扱いやすくした、レイヤーが一層加わっただけである。\n\n大学1年のとき、某企業でデータセンタに関するソリューション提案のインターンをした。そのときは仮想化どころかデータセンタに関する知識が少なくて学ぶことばかりでついていくのもやっとだったけれど、概念の理解は当時より進んだと思う。\n"},{"id":"http://localhost:3000/posts/sakura-vps-docker","url":"http://localhost:3000/posts/sakura-vps-docker","title":"さくらのVPSとdocker環境構築 ","summary":"PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。 windows10のPCから、さくらVPSでCentOS7のサーバでdockerを使えるようにする記録。 windows10にはあらかじめputty,WinSCPがインストールされていることを想定。 さくらVPS初期設定 OSインストール さくらVPS管理画面にて、> サーバ一覧 > (設定したいサーバ) > 各種設定 > OSインストール OSインストール形式の選択: 標準OS インストールするOSを選んでください: CentOS7 x86\\_64 rootパスワード: 適当に設定 スタートア","date_published":"2020-03-28T03:10:34+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%81%95%E3%81%8F%E3%82%89%E3%81%AEVPS%E3%81%A8docker%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89%20,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["さくらのVPS","Linux","CentOS","Docker"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<p>PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。</p>\n<p>windows10のPCから、さくらVPSでCentOS7のサーバでdockerを使えるようにする記録。</p>\n<p>windows10にはあらかじめputty,WinSCPがインストールされていることを想定。</p>\n<h2>さくらVPS初期設定</h2>\n<h3>OSインストール</h3>\n<p>さくらVPS管理画面にて、> サーバ一覧 > (設定したいサーバ) > 各種設定 > OSインストール</p>\n<ul>\n<li>OSインストール形式の選択: 標準OS</li>\n<li>インストールするOSを選んでください: CentOS7 x86_64</li>\n<li>rootパスワード: 適当に設定</li>\n<li>スタートアップスクリプト: 利用しない</li>\n</ul>\n<p>こんな感じでOSをインストールする。</p>\n<h3>一般ユーザーの作成</h3>\n<p>まず、さくらVPS管理画面にて、>サーバ一覧 >(設定したいサーバ) > _コンソール > _シリアルコンソール(β)版 から操作。</p>\n<h4>sampleuserの作成</h4>\n<p>以下、sampleuserは適当に自分の作りたいユーザー名に置き換える。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\">#rootでログイン </span>\n$ useradd sampleuser <span class=\"hljs-comment\">#ユーザー作成 </span>\n$ passwd sampleuser <span class=\"hljs-comment\">#パスワード設定 </span></code></pre>\n<h4>sampleuserがsudoできるようにする</h4>\n<pre><code class=\"hljs language-sh\">$ visudo </code></pre>\n<p>visudoで/etc/sudoersを編集する。次の行のコメントアウトを外す。</p>\n<pre><code>## Allows people in group wheel to run all commands \n#%wheel  ALL=(ALL)       ALL \n↓ \n## Allows people in group wheel to run all commands \n%wheel  ALL=(ALL)       ALL \n</code></pre>\n<p>:wqで保存。</p>\n<pre><code class=\"hljs language-sh\">$ usermod -aG wheel sampleuser \n<span class=\"hljs-comment\">#ユーザーをwheelグループに追加 </span>\n \n$ <span class=\"hljs-built_in\">exit</span> \n \n$ login <span class=\"hljs-comment\">#sampleuserでlogin </span>\n \n$ groups <span class=\"hljs-comment\">#自分の所属groupを確認 </span>\nsampleuser wheel \n \n$ sudo su <span class=\"hljs-comment\">#sampleuserでsudoできるか確認 </span>\n[sudo] password <span class=\"hljs-keyword\">for</span> sampleuser:{sampleuserのパスワード} \n \n$ whoami \nroot </code></pre>\n<h4>puttyからsshログインしてみる</h4>\n<p>putty.exeを起動。</p>\n<ul>\n<li>>Session の Host Name : サーバのipアドレスorドメイン名</li>\n<li>>Session の Port : 22</li>\n<li>>Conection の Seconds to between keepalives(0 to turn off) : 30</li>\n</ul>\n<p>(30秒ごとにnull文字が送信されることでしばらく操作が無くてもsshセッションが途絶えるのを防ぐ。)</p>\n<ul>\n<li>>Session の SavedSessions : sakura_vps_session</li>\n</ul>\n<p>Saveし、その後Openでssh接続できるか確認する。</p>\n<h3>セキュリティの強化</h3>\n<h4>rootのsshログインを止める</h4>\n<pre><code class=\"hljs language-sh\">$ vim sudo /etc/ssh/sshd_config </code></pre>\n<p>/etc/ssh/sshd_configを次のように編集する。</p>\n<pre><code> #PermitRootLogin yes \n ↓ \n PermitRootLogin no \n \n</code></pre>\n<p>:wqで保存。</p>\n<pre><code class=\"hljs language-sh\">$ systemctl restart sshd <span class=\"hljs-comment\">#設定を反映させる </span></code></pre>\n<h4>port番号変更とfirewall設定変更</h4>\n<p>sshポートを、標準である22から適当な値に変更する。ここでは2222に変更するが、セキュリティのためには各自適当な値を用いるべき。</p>\n<pre><code class=\"hljs language-sh\">$ sudo vim /etc/ssh/sshd_config </code></pre>\n<p>/etc/ssh/sshd_configを次のように編集する。</p>\n<pre><code>#Port22 \n↓ \nPort2222 \n</code></pre>\n<p>:wqで保存。</p>\n<pre><code class=\"hljs language-sh\">$ systemctl restart sshd <span class=\"hljs-comment\">#設定を反映させる </span></code></pre>\n<p>そして、sshの設定でポートを変更したのち、<strong>firewallの設定も変更しなければならない。。。</strong> これに気づかず最初つまづいた。</p>\n<pre><code class=\"hljs language-sh\">$ cp /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/ssh.xml \n \n$ sudo vim /etc/firewalld/services/ssh.xml </code></pre>\n<p>firewallのデフォルト設定は/usr/lib/firewalld/にあるが、これは触らないこと。\n編集する場合は、/etc/firewalld/以下にファイルを置くと、その部分だけシステム設定が上書きされるようになっているので、こちらに書き込む。</p>\n<p>/etc/firewalld/services/ssh.xmlを次のように編集する。</p>\n<pre><code>&#x3C;port protocol=\"tcp\" port=\"22\"/> \n↓ \n&#x3C;port protocol=\"tcp\" port=\"2222\"/> \n</code></pre>\n<p>:wqで保存。</p>\n<pre><code class=\"hljs language-sh\">$ firewall-cmd --reload <span class=\"hljs-comment\">#設定を反映させる </span></code></pre>\n<p>putty.exeでも、ポート設定を変更しておく。\nsakura_vps_session をLoadし、Portを2222に変えてSave。puttyから接続できるか確認しておく。</p>\n<h4>公開鍵認証</h4>\n<p>puttygen.exeで公開鍵、秘密鍵のペアを作成する。\nGenerateボタンを押した後、カーソルをウィンドウ上でランダムに動かすと鍵が作成できる。\nKey passphraseを任意のものに設定する。\n適当な場所に Save public key  で sakura_rsa.pub として、Save private key sakura_rsa.ppk として保存。</p>\n<p>公開鍵をサーバにアップロードする。\nWinSCPで、新しいサイトから、</p>\n<ul>\n<li>編集プロトコル:SFTP</li>\n<li>ホスト名:にサーバのipアドレスorドメイン名</li>\n<li>ポート番号:2222</li>\n<li>ユーザ名:sampleuser</li>\n<li>パスワード:(sampleuserのパスワード)</li>\n</ul>\n<p>として保存、ログインする。\nWinSCPでは画面左側にローカルの、画面右側にサーバのファイルが表示されており、ドラッグアンドドロップで相互に転送できる。\n先ほどの\nサーバの/home/sampleuser に先ほどの sakura_rsa.pub (公開鍵だけ)を転送する。</p>\n<p>サーバに公開鍵を登録する。</p>\n<pre><code class=\"hljs language-sh\">$ login <span class=\"hljs-comment\">#sampleuserでloginする </span>\n \n$ ssh-keygen -i -f sakura_rsa.pub >> authorized_keys <span class=\"hljs-comment\">#puttygen.exeで作成した公開鍵の形式を変換 </span>\n \n<span class=\"hljs-comment\">#/home/sampleuser/.ssh/にauthorized_keysを設置し、適切なユーザ権限を与える </span>\n$ mkdir .ssh \n$ chmod 700 .ssh \n$ mv authorized_keys .ssh \n$ chmod 600 .ssh/authorized_keys \n \n$ rm -f sakura_rsa.pub <span class=\"hljs-comment\">#変換前の公開鍵を削除 </span></code></pre>\n<p>puttyに秘密鍵を登録する。</p>\n<p>putty.exeで sakura_vps_session を Loadし、>Conection>SSH>Auth の Private key fire authentication にsakura_rsa.ppk(秘密鍵)を設定する。\n>Sessionから 設定の変更をSaveする。\nその後puttyで接続できるか確認。鍵を作成したときのパスフレーズをここで入力する必要があるはず。\n問題なく接続できれば、晴れて公開鍵認証でssh接続できている。</p>\n<p>パスワードログインの無効化をする。\n公開鍵認証でログインできても、まだ従来のパスワードによるログインもできるのでセキュリティ向上にはなっていない。従来のパスワードによるログインを無効化する。</p>\n<pre><code class=\"hljs language-sh\">$ vim sudo /etc/ssh/sshd_config </code></pre>\n<p>/etc/ssh/sshd_configを次のように編集する。</p>\n<pre><code>#PasswordAuthentication yes \n↓ \nPasswordAuthentication no \n</code></pre>\n<p>:wqで保存。</p>\n<pre><code class=\"hljs language-sh\">$ systemctl restart sshd <span class=\"hljs-comment\">#設定を反映させる </span></code></pre>\n<h2>docker構築</h2>\n<h3>dockerのインストール</h3>\n<pre><code class=\"hljs language-sh\">$ sudo yum update \n$ sudo yum install docker-io \n<span class=\"hljs-comment\">#dockerのインストール </span>\n \n$ sudo systemctl start docker \n<span class=\"hljs-comment\">#無事インストールされたか確認する </span>\n$ sudo docker info \n<span class=\"hljs-comment\">#インストールされていればつらつら現在の状況が表示される </span></code></pre>\n<h3>sampleuserがdockerを使えるようにする</h3>\n<pre><code class=\"hljs language-sh\">$ sudo groupadd docker <span class=\"hljs-comment\">#dockerグループの作成 </span>\n$ sudo gpasswd -a sampleuser docker \n<span class=\"hljs-comment\">#sampleuserをdockerグループへ追加 </span>\n \n$ sudo systemctl restart docker \n<span class=\"hljs-comment\">#dockerデーモンの再起動 </span>\n \n$ docker info \n<span class=\"hljs-comment\">#sampleuserで動くことを確認 </span></code></pre>\n<h3>Moby Dockを表示してみる</h3>\n<pre><code class=\"hljs language-sh\">$ docker run docker/whalesay cowsay <span class=\"hljs-string\">'Congrats!!!'</span> </code></pre>\n<h2>参考文献</h2>\n<ul>\n<li>CentOSでuserをsudo可能にする:</li>\n</ul>\n<p><a href=\"https://qiita.com/Esfahan/items/a159753d156d23baf180\">https://qiita.com/Esfahan/items/a159753d156d23baf180</a></p>\n<ul>\n<li>CentOS7のfirewalldでsshのポート番号を変更する方法:</li>\n</ul>\n<p><a href=\"https://qiita.com/DQNEO/items/5780d81b2e0af4cc1544\">https://qiita.com/DQNEO/items/5780d81b2e0af4cc1544</a></p>\n<ul>\n<li>PuTTYで公開鍵認証方式でのSSH接続を行う手順まとめ:</li>\n</ul>\n<p><a href=\"https://qiita.com/sugar_15678/items/55cb79d427b9ec21bac2\">https://qiita.com/sugar_15678/items/55cb79d427b9ec21bac2</a></p>\n<ul>\n<li>VPSにdocker環境構築:</li>\n</ul>\n<p><a href=\"https://qiita.com/t-mimura/items/c206d46f3af771292f89\">https://qiita.com/t-mimura/items/c206d46f3af771292f89</a></p>\n","content_text":"PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。\n\nwindows10のPCから、さくらVPSでCentOS7のサーバでdockerを使えるようにする記録。\n\nwindows10にはあらかじめputty,WinSCPがインストールされていることを想定。\n\nさくらVPS初期設定\n\nOSインストール\n\nさくらVPS管理画面にて、> サーバ一覧 > (設定したいサーバ) > 各種設定 > OSインストール\n\nOSインストール形式の選択: 標準OS\n\nインストールするOSを選んでください: CentOS7 x86\\_64\n\nrootパスワード: 適当に設定\n\nスタートアップスクリプト: 利用しない\n\nこんな感じでOSをインストールする。\n\n一般ユーザーの作成\n\nまず、さくらVPS管理画面にて、>サーバ一覧 >(設定したいサーバ) > \\_コンソール > \\_シリアルコンソール(β)版 から操作。\n\nsampleuserの作成\n\n以下、sampleuserは適当に自分の作りたいユーザー名に置き換える。\n\n\n\nsampleuserがsudoできるようにする\n\n\n\nvisudoで/etc/sudoersを編集する。次の行のコメントアウトを外す。\n\n\n\n:wqで保存。\n\n\n\nputtyからsshログインしてみる\n\nputty.exeを起動。\n\n\\>Session の Host Name : サーバのipアドレスorドメイン名\n\n\\>Session の Port : 22\n\n\\>Conection の Seconds to between keepalives(0 to turn off) : 30\n\n(30秒ごとにnull文字が送信されることでしばらく操作が無くてもsshセッションが途絶えるのを防ぐ。)\n\n\\>Session の SavedSessions : sakura_vps_session\n\nSaveし、その後Openでssh接続できるか確認する。\n\nセキュリティの強化\n\nrootのsshログインを止める\n\n\n\n/etc/ssh/sshd_configを次のように編集する。\n\n\n\n:wqで保存。\n\n\n\nport番号変更とfirewall設定変更\n\nsshポートを、標準である22から適当な値に変更する。ここでは2222に変更するが、セキュリティのためには各自適当な値を用いるべき。\n\n\n\n/etc/ssh/sshd_configを次のように編集する。\n\n\n\n:wqで保存。\n\n\n\nそして、sshの設定でポートを変更したのち、firewallの設定も変更しなければならない。。。 これに気づかず最初つまづいた。\n\n\n\nfirewallのデフォルト設定は/usr/lib/firewalld/にあるが、これは触らないこと。\n編集する場合は、/etc/firewalld/以下にファイルを置くと、その部分だけシステム設定が上書きされるようになっているので、こちらに書き込む。\n\n/etc/firewalld/services/ssh.xmlを次のように編集する。\n\n\n\n:wqで保存。\n\n\n\nputty.exeでも、ポート設定を変更しておく。\nsakura_vps_session をLoadし、Portを2222に変えてSave。puttyから接続できるか確認しておく。\n\n公開鍵認証\n\nputtygen.exeで公開鍵、秘密鍵のペアを作成する。\nGenerateボタンを押した後、カーソルをウィンドウ上でランダムに動かすと鍵が作成できる。\nKey passphraseを任意のものに設定する。\n適当な場所に Save public key  で sakura_rsa.pub として、Save private key sakura_rsa.ppk として保存。\n\n公開鍵をサーバにアップロードする。\nWinSCPで、新しいサイトから、\n\n編集プロトコル:SFTP\n\nホスト名:にサーバのipアドレスorドメイン名\n\nポート番号:2222\n\nユーザ名:sampleuser\n\nパスワード:(sampleuserのパスワード)\n\nとして保存、ログインする。\nWinSCPでは画面左側にローカルの、画面右側にサーバのファイルが表示されており、ドラッグアンドドロップで相互に転送できる。\n先ほどの\nサーバの/home/sampleuser に先ほどの sakura_rsa.pub (公開鍵だけ)を転送する。\n\nサーバに公開鍵を登録する。\n\n\n\nputtyに秘密鍵を登録する。\n\nputty.exeで sakura_vps_session を Loadし、>Conection>SSH>Auth の Private key fire authentication にsakura_rsa.ppk(秘密鍵)を設定する。\n\\>Sessionから 設定の変更をSaveする。\nその後puttyで接続できるか確認。鍵を作成したときのパスフレーズをここで入力する必要があるはず。\n問題なく接続できれば、晴れて公開鍵認証でssh接続できている。\n\nパスワードログインの無効化をする。\n公開鍵認証でログインできても、まだ従来のパスワードによるログインもできるのでセキュリティ向上にはなっていない。従来のパスワードによるログインを無効化する。\n\n\n\n/etc/ssh/sshd_configを次のように編集する。\n\n\n\n:wqで保存。\n\n\n\ndocker構築\n\ndockerのインストール\n\n\n\nsampleuserがdockerを使えるようにする\n\n\n\nMoby Dockを表示してみる\n\n\n\n参考文献\n\nCentOSでuserをsudo可能にする:\n\nhttps\\://qiita.com/Esfahan/items/a159753d156d23baf180\n\nCentOS7のfirewalldでsshのポート番号を変更する方法:\n\nhttps\\://qiita.com/DQNEO/items/5780d81b2e0af4cc1544\n\nPuTTYで公開鍵認証方式でのSSH接続を行う手順まとめ:\n\nhttps\\://qiita.com/sugar\\_15678/items/55cb79d427b9ec21bac2\n\nVPSにdocker環境構築:\n\nhttps\\://qiita.com/t-mimura/items/c206d46f3af771292f89\n"},{"id":"http://localhost:3000/posts/sakura-vps-dns","url":"http://localhost:3000/posts/sakura-vps-dns","title":"お名前.comで取得したドメインをさくらVPSで使う。","summary":"PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。 お名前.comで取得したドメインをさくらVPSで使う。DNSサーバーはさくらのものを利用する。 お名前.com側の設定 \\> ドメイン > ドメイン設定 > ネームサーバーの設定 > ネームサーバーの変更 目的のドメイン名にチェックを入れて 登録情報は正しいので、手続きを進める をクリック。 他のネームサーバーを利用 のタブにして 1プライマリネームサーバー(必須) :\tns1.dns.ne.jp 2セカンダリネームサーバー(必須) :\tns2.dns.ne.jp として確認画面へ進み、設定を適","date_published":"2020-03-28T03:03:08+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:%E3%81%8A%E5%90%8D%E5%89%8D.com%E3%81%A7%E5%8F%96%E5%BE%97%E3%81%97%E3%81%9F%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%92%E3%81%95%E3%81%8F%E3%82%89VPS%E3%81%A7%E4%BD%BF%E3%81%86%E3%80%82,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["さくらのVPS","ドメイン","DNS"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<p>PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。</p>\n<p>お名前.comで取得したドメインをさくらVPSで使う。DNSサーバーはさくらのものを利用する。</p>\n<h2>お名前.com側の設定</h2>\n<p>> ドメイン > ドメイン設定 > ネームサーバーの設定 > ネームサーバーの変更</p>\n<p>目的のドメイン名にチェックを入れて 登録情報は正しいので、手続きを進める をクリック。</p>\n<p>他のネームサーバーを利用 のタブにして</p>\n<ul>\n<li>1プライマリネームサーバー(必須) :\tns1.dns.ne.jp</li>\n<li>2セカンダリネームサーバー(必須) :\tns2.dns.ne.jp</li>\n</ul>\n<p>として確認画面へ進み、設定を適用する。</p>\n<p>これでネームサーバーはさくらインターネットのものが使われる</p>\n<h2>さくらVPS側の設定</h2>\n<p>> さくらのVPSコントロールパネル > ネームサーバ登録</p>\n<ul>\n<li>ドメイン名:example.com (目的のドメイン名)</li>\n</ul>\n<p>送信する をクリックして設定を適用する。</p>\n<p>> 会員メニュー > ドメイン > 管理ドメインとネームサーバの一覧<br>\nにてドメイン名:example.comの ゾーン編集 をクリック\n左側の 変更 から</p>\n<ul>\n<li>エントリ名: 空欄</li>\n<li>種別: IPアドレス(A)</li>\n<li>値: 192.0.43.10 (サーバのIPアドレス)</li>\n<li>DNSチェック: する</li>\n<li>TTLの指定: (チェックしない)</li>\n</ul>\n<p>として新規登録</p>\n<p>もう一度<br>\n> 会員メニュー > ドメイン > 管理ドメインとネームサーバの一覧<br>\nにてドメイン名:example.comの ゾーン編集 をクリックし、左側の 変更 から</p>\n<ul>\n<li>エントリ名: www</li>\n<li>種別: 別名(CNAME)</li>\n<li>値: @</li>\n<li>DNSチェック: する</li>\n<li>TTLの指定: (チェックしない)</li>\n</ul>\n<p>として新規登録</p>\n<p>以上で完了となる。</p>\n","content_text":"PCを整理していて発見したメモを移動して公開する。ファイルのタイムスタンプは2017/12/19。\n\nお名前.comで取得したドメインをさくらVPSで使う。DNSサーバーはさくらのものを利用する。\n\nお名前.com側の設定\n\n\\> ドメイン > ドメイン設定 > ネームサーバーの設定 > ネームサーバーの変更\n\n目的のドメイン名にチェックを入れて 登録情報は正しいので、手続きを進める をクリック。\n\n他のネームサーバーを利用 のタブにして\n\n1プライマリネームサーバー(必須) :\tns1.dns.ne.jp\n\n2セカンダリネームサーバー(必須) :\tns2.dns.ne.jp\n\nとして確認画面へ進み、設定を適用する。\n\nこれでネームサーバーはさくらインターネットのものが使われる\n\nさくらVPS側の設定\n\n\\> さくらのVPSコントロールパネル > ネームサーバ登録\n\nドメイン名:example.com (目的のドメイン名)\n\n送信する をクリックして設定を適用する。\n\n\\> 会員メニュー > ドメイン > 管理ドメインとネームサーバの一覧\nにてドメイン名:example.comの ゾーン編集 をクリック\n左側の 変更 から\n\nエントリ名: 空欄\n\n種別: IPアドレス(A)\n\n値: 192.0.43.10 (サーバのIPアドレス)\n\nDNSチェック: する\n\nTTLの指定: (チェックしない)\n\nとして新規登録\n\nもう一度\n\\> 会員メニュー > ドメイン > 管理ドメインとネームサーバの一覧\nにてドメイン名:example.comの ゾーン編集 をクリックし、左側の 変更 から\n\nエントリ名: www\n\n種別: 別名(CNAME)\n\n値: @\n\nDNSチェック: する\n\nTTLの指定: (チェックしない)\n\nとして新規登録\n\n以上で完了となる。\n"},{"id":"http://localhost:3000/posts/android-phone-call-command","url":"http://localhost:3000/posts/android-phone-call-command","title":"androidの架電アプリによる各種制御プログラムの起動","summary":"まえがき PC内のデータを整理していたら過去に自分向けに書いていたメモが出てきたので、ここ記す形で移動する。 タイムスタンプをみるに、2017/11/22頃に書かれたものだ。 androidでは、端末の細かい挙動の設定を変更する際、電話アプリで以下に有るようなコマンドを打ち込むと行えることがある。 過去のメモなので、どの機種、環境だと利用できるのか確認していないが、少なくとも SOL26で利用できそうである。 メモ 参考: http\\://www\\.commandshow\\.com/open-android-programs-using-command/ ","date_published":"2020-03-28T02:45:25+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:android%E3%81%AE%E6%9E%B6%E9%9B%BB%E3%82%A2%E3%83%97%E3%83%AA%E3%81%AB%E3%82%88%E3%82%8B%E5%90%84%E7%A8%AE%E5%88%B6%E5%BE%A1%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E8%B5%B7%E5%8B%95,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["android"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/2f3f89946ac843c738e245f5006fd33b096a62c8","comment":"Fix link\n","date_modified":"2020-04-14T02:28:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>まえがき</h2>\n<p>PC内のデータを整理していたら過去に自分向けに書いていたメモが出てきたので、ここ記す形で移動する。\nタイムスタンプをみるに、2017/11/22頃に書かれたものだ。</p>\n<p>androidでは、端末の細かい挙動の設定を変更する際、電話アプリで以下に有るようなコマンドを打ち込むと行えることがある。</p>\n<p>過去のメモなので、どの機種、環境だと利用できるのか確認していないが、少なくとも SOL26で利用できそうである。</p>\n<h2>メモ</h2>\n<pre><code>Open Android Mobile Programs Using Commend  \n \n Commands               Usages \n \n*#06# = IMEI Android serial number \n \n*#8999*523# = LCD Brightness \n*#1234# = To check Software and Hardware information, PDA, CSC,MODEM. \n \n*#2222# = it will open H/W Version \n*#*#4636#*#*= user statistics and Phone Info \n*#0011# = Displays status information for the GSM \n*2767*3855# = Full factory reset (Don’t dial unless you have problem, it does not ask you to confirm) \n*#12580*369# = SW &#x26; HW Info \n#*#8377466# = S/W Version &#x26; H/W Version \n#*5376# = DELETE ALL SMS!!!! \n*#197328640# = Service Mode \n*#0228# = Battery status (ADC, RSSI reading) \n*#32489# = Service mode (Ciphering Info) \n*#2255# = Call List \n#*3888# = BLUETOOTH Test mode \n#*7828# = Task screen \n*#5282837# = Java Version \n*#232331# = Bluetooth Test Mode \n*#232338# = WLAN MAC Address \n*#232339# = WLAN Test Mode \n*#8999*8378# = Test Menu \n*#0842# = Vibrate Motor Test Mode \n*#0782# = Real Time Clock Test \n*#0673# = Audio Test Mode \n*#0*# = General Test Mode \n*#2263# = RF Band Selection / Network modes select \n*#9090# = Diagnostic Configuration \n*#7284# = USB I2C Mode Control \n*#872564# = USB Logging Control \n*#4238378# = GCF Configuration \n*#0283# = Audio Loopback Control \n*#1575# = GPS Control Menu \n*#3214789650# = LBS Test Mode \n*#745# = RIL Dump Menu \n*#746# = Debug Dump Menu \n*#9900# = Takes you to System Dump, where Disabling Fast Dormancy gives a boost to your network speed on some networks (both Wi-Fi and Gpr), same code to re-enable it \n*#44336# = Software Version Info \n*#0289# = Melody Test Mode \n*#2663# = TSP / TSK firmware update \n*#03# = NAND Flash S/N \n*#0589# = Light Sensor Test Mode \n*#0588# = Proximity Sensor Test Mode \n*#273283*255*3282*# = Data Create Menu \n \n*#7594# = Remap Shutdown to End Call TSK \n*#7465625# = View Phone Lock Status \n*7465625*638*# = Configure Network Lock MCC/MNC \n#7465625*638*# = Insert Network Lock Key code \n*7465625*782*# = Configure Network Lock NSP \n#7465625*782*# = Insert Partial Network Lock key code \n*7465625*77*# = Insert Network Lock key code SP \n#7465625*77*# = Insert Operator Lock key code \n*7465625*27*# = Insert Network Lock key code NSP/CP \n#7465625*27*# = Insert Content Provider key code \n*#272*IMEI# = then we will get buyer code (For Samsung galaxy six code) \n*#*#7780#*#* = Factory data reset – Clears Google-account data, system and program settings and \n \n*2767*3855# = Format phone \n \nThe Most Useful Cods on Android Mobile \n– Disables Network Lock : #7465625*638*00000000# \n– Disables SIM Lock : #7465625*746*00000000# \n– Disables SP lock : #7465625*77*00000000# \n– Disables Subset Lock : #7465625*782*00000000# \n</code></pre>\n<p>参考: <a href=\"http://www.commandshow.com/open-android-programs-using-command/\">http://www.commandshow.com/open-android-programs-using-command/</a></p>\n","content_text":"まえがき\n\nPC内のデータを整理していたら過去に自分向けに書いていたメモが出てきたので、ここ記す形で移動する。\nタイムスタンプをみるに、2017/11/22頃に書かれたものだ。\n\nandroidでは、端末の細かい挙動の設定を変更する際、電話アプリで以下に有るようなコマンドを打ち込むと行えることがある。\n\n過去のメモなので、どの機種、環境だと利用できるのか確認していないが、少なくとも SOL26で利用できそうである。\n\nメモ\n\n\n\n参考: http\\://www\\.commandshow\\.com/open-android-programs-using-command/\n"},{"id":"http://localhost:3000/posts/sh-history","url":"http://localhost:3000/posts/sh-history","title":"shellでhistoryを使う","summary":"過去に実行したコマンドを再度実行する history ... unix系OSでshellに存在する組み込みコマンドだ。 過去に実行したコマンドを表示できる。 historyコマンドで表示されたコマンドの番号を!と合わせて入力すると、そのコマンドを実行できる。 以下のようにして全履歴を表示できる。 出力した後はgrepで煮るなり焼くなりするのが良いかと。 .zshrcでの設定 .zshrcでhistoryに関する設定をしておく ","date_published":"2020-03-26T00:13:29+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:shell%E3%81%A7history%E3%82%92%E4%BD%BF%E3%81%86,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["zsh","Shell"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>過去に実行したコマンドを再度実行する</h2>\n<p>history ... unix系OSでshellに存在する組み込みコマンドだ。</p>\n<p>過去に実行したコマンドを表示できる。</p>\n<p>historyコマンドで表示されたコマンドの番号を!と合わせて入力すると、そのコマンドを実行できる。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">history</span>\n  1  ls\n  2  <span class=\"hljs-built_in\">pwd</span>\n  3  <span class=\"hljs-built_in\">cd</span> /etc\n$ !1\nls\nhogedir/    fugafile</code></pre>\n<p>以下のようにして全履歴を表示できる。</p>\n<p>出力した後はgrepで煮るなり焼くなりするのが良いかと。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">history</span> -E 1\n<span class=\"hljs-comment\"># 履歴を全て表示する</span></code></pre>\n<h2>.zshrcでの設定</h2>\n<p><code>.zshrc</code>でhistoryに関する設定をしておく</p>\n<div class=\"remark-code-title\">.zshrc</div>\n<pre><code class=\"hljs language-sh\">HISTSIZE=50000 <span class=\"hljs-comment\"># メモリに保存するコマンド数</span>\nHISTFILE=~/.zsh_history\nSAVEHIST=100000 <span class=\"hljs-comment\"># ヒストリファイルに保存するコマンド数</span>\n\n<span class=\"hljs-built_in\">alias</span> <span class=\"hljs-built_in\">history</span>=<span class=\"hljs-string\">\"history -i\"</span>\n<span class=\"hljs-keyword\">function</span> history-all { <span class=\"hljs-built_in\">history</span> -E 1 }\n\n<span class=\"hljs-comment\"># 重複するコマンド行は古い方を削除</span>\n<span class=\"hljs-built_in\">setopt</span> hist_ignore_all_dups\n<span class=\"hljs-comment\"># 直前と同じコマンドラインはヒストリに追加しない</span>\n<span class=\"hljs-built_in\">setopt</span> hist_ignore_dups\n<span class=\"hljs-comment\"># コマンド履歴ファイルを共有する</span>\n<span class=\"hljs-built_in\">setopt</span> share_history\n<span class=\"hljs-comment\"># 履歴を追加 (毎回 .zsh_history を作るのではなく)</span>\n<span class=\"hljs-built_in\">setopt</span> append_history\n<span class=\"hljs-comment\"># 履歴をインクリメンタルに追加</span>\n<span class=\"hljs-built_in\">setopt</span> inc_append_history\n<span class=\"hljs-comment\"># ヒストリを呼び出してから実行する間に一旦編集可能</span>\n<span class=\"hljs-built_in\">setopt</span> hist_verify\n<span class=\"hljs-comment\"># 余分な空白は詰めて記録</span>\n<span class=\"hljs-built_in\">setopt</span> hist_reduce_blanks\n<span class=\"hljs-comment\"># historyコマンドは履歴に登録しない</span>\n<span class=\"hljs-built_in\">setopt</span> hist_no_store</code></pre>\n","content_text":"過去に実行したコマンドを再度実行する\n\nhistory ... unix系OSでshellに存在する組み込みコマンドだ。\n\n過去に実行したコマンドを表示できる。\n\nhistoryコマンドで表示されたコマンドの番号を!と合わせて入力すると、そのコマンドを実行できる。\n\n\n\n以下のようにして全履歴を表示できる。\n\n出力した後はgrepで煮るなり焼くなりするのが良いかと。\n\n\n\n.zshrcでの設定\n\n.zshrcでhistoryに関する設定をしておく\n\n"},{"id":"http://localhost:3000/posts/download-ubuntu","url":"http://localhost:3000/posts/download-ubuntu","title":"Ubuntuをダウンロードしてインストールする","summary":"Download Ubuntu Desktop 日本語 Remixをダウンロードする Torrentを利用するために、uTorrent classicを使用した。 ただし、catalinaがサポート外と書かれていたのでもしかしたら32bitアプリケーションかもしれない。 Torrentについては別途要検討 Check macでは次のようにしてmd5ハッシュを確認できる ダウンロードページのhashと比較して、ダウンロードが正しく行われたことを確認する Copy ","date_published":"2020-03-21T23:18:47+09:00","date_modified":"2021-05-08T19:42:24+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Ubuntu%E3%82%92%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%81%97%E3%81%A6%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Linux","Ubuntu"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>Download</h2>\n<p><a href=\"https://www.ubuntulinux.jp/download/ja-remix\">Ubuntu Desktop 日本語 Remix</a>をダウンロードする</p>\n<p>Torrentを利用するために、uTorrent classicを使用した。\nただし、catalinaがサポート外と書かれていたのでもしかしたら32bitアプリケーションかもしれない。\nTorrentについては別途要検討</p>\n<h2>Check</h2>\n<p>macでは次のようにしてmd5ハッシュを確認できる\nダウンロードページのhashと比較して、ダウンロードが正しく行われたことを確認する</p>\n<pre><code class=\"hljs language-sh\">$ md5 -q path/to/file\n<span class=\"hljs-comment\"># manによると、-qオプションはQuiet modeらしい。md5ハッシュのみ出力する。</span>\n<span class=\"hljs-comment\"># ので、次のように比較するのが良いかな</span>\n\n$ md5 -q path/to/file | diff <span class=\"hljs-built_in\">hash</span>/text/file/path -\n<span class=\"hljs-comment\"># diffの第二引数\"-\"は、標準入力の意</span></code></pre>\n<h2>Copy</h2>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># Convert iso to img</span>\n$ hdutil convert -format UDRW -o hoge.img hoge.iso\n$ mv hoge.img.dmg hoge.img\n\n<span class=\"hljs-comment\"># USBメモリの確認</span>\n$ diskutil list\n\n<span class=\"hljs-comment\"># Mountされていたら</span>\n$ diskutil unMountDisk path/to/device\n<span class=\"hljs-comment\"># ex)  $ diskutil unMountDisk /dev/disk1</span>\n\n$ sudo dd <span class=\"hljs-keyword\">if</span>=hoge.img of=path/to/device bs=1m\n\n$ sudo diskutil eject path/to/device</code></pre>\n","content_text":"Download\n\nUbuntu Desktop 日本語 Remixをダウンロードする\n\nTorrentを利用するために、uTorrent classicを使用した。\nただし、catalinaがサポート外と書かれていたのでもしかしたら32bitアプリケーションかもしれない。\nTorrentについては別途要検討\n\nCheck\n\nmacでは次のようにしてmd5ハッシュを確認できる\nダウンロードページのhashと比較して、ダウンロードが正しく行われたことを確認する\n\n\n\nCopy\n\n"},{"id":"http://localhost:3000/posts/install-dein-vim","url":"http://localhost:3000/posts/install-dein-vim","title":"dein.vimの導入","summary":"dotfiles環境下でvimのプラグイン管理にdein.vimを導入する。 前提 \\~/dotfilesで.vimrcを管理している dein.vimも\\~/dotfilesで管理する 下準備 .vimrcに追記 \\~/dotfiles/.vimrcの先頭に次を記載 load.vimに記述 \\~/dotfiles/dein/load.vimに次の内容を記述 vimを起動 .vimrcの記述により、vim起動によりdein.vimがinstallされる。 (ただし、gitが必要) 参考 yammerjp/dotfiles -GitHub ","date_published":"2020-03-17T00:13:35+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:dein.vim%E3%81%AE%E5%B0%8E%E5%85%A5,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Vim","dotfiles"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<p>dotfiles環境下でvimのプラグイン管理に<a href=\"https://github.com/Shougo/dein.vim\">dein.vim</a>を導入する。</p>\n<h2>前提</h2>\n<ul>\n<li><code>~/dotfiles</code>で<code>.vimrc</code>を管理している</li>\n<li>dein.vimも<code>~/dotfiles</code>で管理する</li>\n</ul>\n<h2>下準備</h2>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">cd</span> ~/dotfiles\n$ mkdir dein\n$ touch dein/load.vim</code></pre>\n<h2>.vimrcに追記</h2>\n<p><code>~/dotfiles/.vimrc</code>の先頭に次を記載</p>\n<div class=\"remark-code-title\">.vimrc</div>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-comment\">\"===== dein.vim =====</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">filereadable</span>(<span class=\"hljs-built_in\">expand</span>(<span class=\"hljs-string\">'dein/load.vim'</span>))\n    <span class=\"hljs-keyword\">source</span> dein/load.<span class=\"hljs-keyword\">vim</span>\n<span class=\"hljs-keyword\">endif</span></code></pre>\n<h2>load.vimに記述</h2>\n<p><code>~/dotfiles/dein/load.vim</code>に次の内容を記述</p>\n<div class=\"remark-code-title\">~/dotfiles/dein/load.vim</div>\n<pre><code class=\"hljs language-vim\"><span class=\"hljs-string\">\"\"</span><span class=\"hljs-comment\">\"===== dein.vim ======</span>\n\n<span class=\"hljs-comment\">\"dein.vim dark power</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:dein_dir</span> = <span class=\"hljs-built_in\">expand</span>(<span class=\"hljs-string\">'~/dotfiles/dein'</span>)\n<span class=\"hljs-comment\">\" s:dein_dirとg:rc-dirは一致させること。dein.tomlとdein-lazy.tomlをtouchしている</span>\n<span class=\"hljs-comment\">\"</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:dein_repo_dir</span> = <span class=\"hljs-variable\">s:dein_dir</span> . <span class=\"hljs-string\">'/repos/github.com/Shougo/dein.vim'</span>\n\n<span class=\"hljs-keyword\">set</span> nocompatible\n<span class=\"hljs-comment\">\" dein.vim をインストールしていない場合は自動インストール</span>\n<span class=\"hljs-keyword\">if</span> !isdirectory(<span class=\"hljs-variable\">s:dein_repo_dir</span>)\n  <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"install dein.vim...\"</span>\n  <span class=\"hljs-keyword\">execute</span> <span class=\"hljs-string\">'!git clone git://github.com/Shougo/dein.vim'</span> <span class=\"hljs-variable\">s:dein_repo_dir</span>\n  <span class=\"hljs-keyword\">execute</span> <span class=\"hljs-string\">'!touch -m '</span> . <span class=\"hljs-variable\">s:dein_dir</span> . <span class=\"hljs-string\">'/dein.toml'</span>\n  <span class=\"hljs-keyword\">execute</span> <span class=\"hljs-string\">'!touch -m '</span> . <span class=\"hljs-variable\">s:dein_dir</span> . <span class=\"hljs-string\">'/dein_lazy.toml'</span>\n<span class=\"hljs-keyword\">endif</span>\n<span class=\"hljs-keyword\">execute</span> <span class=\"hljs-string\">'set runtimepath^='</span> . <span class=\"hljs-variable\">s:dein_repo_dir</span>\n\n<span class=\"hljs-comment\">\"---------------------------</span>\n<span class=\"hljs-comment\">\" Start dein.vim Settings.</span>\n<span class=\"hljs-comment\">\"---------------------------</span>\n\n<span class=\"hljs-keyword\">if</span> dein#load_state(<span class=\"hljs-variable\">s:dein_dir</span>)\n  <span class=\"hljs-keyword\">call</span> dein#begin(<span class=\"hljs-variable\">s:dein_dir</span>)\n\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">g:rc_dir</span>    = <span class=\"hljs-built_in\">expand</span>(<span class=\"hljs-string\">'~/dotfiles/dein'</span>)\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:toml</span>      = <span class=\"hljs-variable\">g:rc_dir</span> . <span class=\"hljs-string\">'/dein.toml'</span>\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">s:lazy_toml</span> = <span class=\"hljs-variable\">g:rc_dir</span> . <span class=\"hljs-string\">'/dein_lazy.toml'</span>\n\n  <span class=\"hljs-comment\">\" TOMLファイルにpluginを記述</span>\n  <span class=\"hljs-keyword\">call</span> dein#load_toml(<span class=\"hljs-variable\">s:toml</span>,      {<span class=\"hljs-string\">'lazy'</span>: <span class=\"hljs-number\">0</span>})\n  <span class=\"hljs-keyword\">call</span> dein#load_toml(<span class=\"hljs-variable\">s:lazy_toml</span>, {<span class=\"hljs-string\">'lazy'</span>: <span class=\"hljs-number\">1</span>})\n\n  <span class=\"hljs-keyword\">call</span> dein#end()\n  <span class=\"hljs-keyword\">call</span> dein#save_state()\n<span class=\"hljs-keyword\">endif</span>\n\n<span class=\"hljs-comment\">\" 未インストールを確認</span>\n<span class=\"hljs-keyword\">if</span> dein#check_install()\n  <span class=\"hljs-keyword\">call</span> dein#install()\n<span class=\"hljs-keyword\">endif</span>\n\n<span class=\"hljs-comment\">\"---------------------------</span>\n<span class=\"hljs-comment\">\" End dein.vim Settings.</span>\n<span class=\"hljs-comment\">\"---------------------------</span></code></pre>\n<h2>vimを起動</h2>\n<p><code>.vimrc</code>の記述により、vim起動によりdein.vimがinstallされる。\n(ただし、gitが必要)</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/yammerjp/dotfiles\">yammerjp/dotfiles -GitHub</a></li>\n</ul>\n","content_text":"dotfiles環境下でvimのプラグイン管理にdein.vimを導入する。\n\n前提\n\n\\~/dotfilesで.vimrcを管理している\n\ndein.vimも\\~/dotfilesで管理する\n\n下準備\n\n\n\n.vimrcに追記\n\n\\~/dotfiles/.vimrcの先頭に次を記載\n\n\n\nload.vimに記述\n\n\\~/dotfiles/dein/load.vimに次の内容を記述\n\n\n\nvimを起動\n\n.vimrcの記述により、vim起動によりdein.vimがinstallされる。\n(ただし、gitが必要)\n\n参考\n\nyammerjp/dotfiles -GitHub\n"},{"id":"http://localhost:3000/posts/shell-pwd","url":"http://localhost:3000/posts/shell-pwd","title":"Shell Scriptにおける、カレントディレクトリの固定","summary":"前提 shell script内では、shell scriptを起動する前のカレントディレクトリが引き継がれる。 例えば、次のようなpwd.shを実行する。 次のように、shell scriptを呼び出す際のカレントディレクトリにより、shell scriptの挙動が変化する。 解決策 shell scriptの前方に、2行追加する。 これにより、shell scriptを呼び出す際のカレントディレクトリに関わらず、shell scriptでのカレントディレクトリが、shell scriptが配置されたディレクトリに固定される。 その他の解決策 shell script内のpathを、\"$HO","date_published":"2020-03-16T22:23:27+09:00","date_modified":"2021-05-04T13:21:45+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:Shell%20Script%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%80%81%E3%82%AB%E3%83%AC%E3%83%B3%E3%83%88%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%81%AE%E5%9B%BA%E5%AE%9A,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["Shell","Linux","macOS"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/b1c87df27cfab6d80bf16ebc335401cedfc095a7","comment":"tag -> keywords\n","date_modified":"2020-04-14T01:47:39+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>前提</h2>\n<p>shell script内では、shell scriptを起動する前のカレントディレクトリが引き継がれる。</p>\n<p>例えば、次のような<code>pwd.sh</code>を実行する。</p>\n<div class=\"remark-code-title\">pwd.sh</div>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\n<span class=\"hljs-built_in\">pwd</span></code></pre>\n<p>次のように、shell scriptを呼び出す際のカレントディレクトリにより、shell scriptの挙動が変化する。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">pwd</span>\n/Users/hoge\n\n$ ls -F\npwd.sh*   dir/\n\n$ sh pwd.sh \n/Users/hoge\n\n$ <span class=\"hljs-built_in\">cd</span> dir\n$ sh ../pwd.sh\n/Users/hoge/dir</code></pre>\n<h2>解決策</h2>\n<p>shell scriptの前方に、2行追加する。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\n\n<span class=\"hljs-comment\"># change directory to the shell file's directory</span>\nSCRIPT_DIR=`dirname <span class=\"hljs-variable\">$0</span>`\n<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$SCRIPT_DIR</span>\n\n<span class=\"hljs-built_in\">pwd</span></code></pre>\n<p>これにより、shell scriptを呼び出す際のカレントディレクトリに関わらず、shell scriptでのカレントディレクトリが、shell scriptが配置されたディレクトリに固定される。</p>\n<pre><code class=\"hljs language-sh\">$ <span class=\"hljs-built_in\">pwd</span>\n/Users/hoge\n\n$ ls -F\npwd.sh*   dir/\n\n$ sh pwd.sh \n/Users/hoge\n\n$ <span class=\"hljs-built_in\">cd</span> dir\n$ sh ../pwd.sh\n/Users/hoge</code></pre>\n<h2>その他の解決策</h2>\n<p>shell script内のpathを、<code>\"$HOME\"</code>などの変数を使って絶対パスで記載する。</p>\n<h2>まとめ</h2>\n<p>以下のテンプレートをshell scriptの先頭に追加すると良い。</p>\n<div class=\"remark-code-title\">sample.sh</div>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\nSCRIPT_DIR=`dirname <span class=\"hljs-variable\">$0</span>`\n<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$SCRIPT_DIR</span></code></pre>\n<h2>追記 (2020/03/19)</h2>\n<p><code>$SCRIPT_DIR</code>にフルパスを格納するなら以下の通り</p>\n<pre><code>SCRIPT_DIR=$(cd $(dirname $0); pwd)\ncd $SCRIPT_DIR\n</code></pre>\n","content_text":"前提\n\nshell script内では、shell scriptを起動する前のカレントディレクトリが引き継がれる。\n\n例えば、次のようなpwd.shを実行する。\n\n\n\n次のように、shell scriptを呼び出す際のカレントディレクトリにより、shell scriptの挙動が変化する。\n\n\n\n解決策\n\nshell scriptの前方に、2行追加する。\n\n\n\nこれにより、shell scriptを呼び出す際のカレントディレクトリに関わらず、shell scriptでのカレントディレクトリが、shell scriptが配置されたディレクトリに固定される。\n\n\n\nその他の解決策\n\nshell script内のpathを、\"$HOME\"などの変数を使って絶対パスで記載する。\n\nまとめ\n\n以下のテンプレートをshell scriptの先頭に追加すると良い。\n\n\n\n追記 (2020/03/19)\n\n$SCRIPT_DIRにフルパスを格納するなら以下の通り\n\n"},{"id":"http://localhost:3000/posts/hexo","url":"http://localhost:3000/posts/hexo","title":"hexoによる静的サイトの構築","summary":"Hexoによる静的サイトの構築 Hexoは、node.jsを使った静的サイトジェネレータ。 markdown形式の記事を静的サイトに簡単に公開できる。 Hexoの導入 Hexoの設定について 設定は基本的に\\_config.ymlに書き込む。 例えば、このサイトの\\_config.ymlが一例。 テーマの導入 Hexoはサードパーティで公開された様々なテーマを導入できる。 公式サイトのテーマ一覧にあるように、様々なものが選べる。 今回はair-cloudを導入した。 テーマ特有の設定は、Demoの\\_config.ymlが参考になる。 特別なページの設置 自己紹介ページの追加 source/a","date_published":"2020-03-16T09:09:00+09:00","date_modified":"2021-05-11T01:29:01+09:00","banner_image":"https://res.cloudinary.com/basd4g/image/upload/co_rgb:505050,l_text:Sawarabi%20Gothic_64_align_center:hexo%E3%81%AB%E3%82%88%E3%82%8B%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E6%A7%8B%E7%AF%89,w_800,c_fit/v1620733120/memo-yammer-jp.png","tags":["hexo","JavaScript","ブログ"],"language":"ja","authors":[{"name":"Keisuke Nakayama","url":"https://yammer.jp","avatar":""}],"_change_logs":[{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ae9f8434d6a5080d5cbadf9002485d663bda2d54","comment":"Update: ドメインをmemo.basd4g.net -> memo.yammer.jp に変更\n","date_modified":"2021-05-11T01:29:01+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/0cddc9de95d06d985b70762310c42e37abefb887","comment":"Fix: タグ名を整理 (大文字小文字の統一など)\n","date_modified":"2021-05-08T19:42:24+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/24ebe74a7fc3098f4815f0a10e55b197a5db5a47","comment":"Fix markdown directory\n","date_modified":"2021-05-04T13:21:45+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/149ce385dda4d7d43d96ae94674e4ea9ee213ef2","comment":"Add Next.js\n","date_modified":"2021-04-29T23:55:33+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/4c61f209b2c8da2f7d0b887f455bfae372d64738","comment":"YAML Front Matterのフォーマットを修正し\"\"で囲むよう統一\n","date_modified":"2021-04-29T23:17:22+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/a7726e1d33de7ff9097e10d44ac2cfb1f80ef11e","comment":"Add tags\n","date_modified":"2020-10-04T19:11:00+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/c35706e842136ecdcc6f56c2b3bf00884581570f","comment":"Update date format\n","date_modified":"2020-04-14T01:33:14+09:00"},{"url":"https://github.com/yammerjp/memo.yammer.jp/commit/ceed4c0d0cd5265c6b0cd550d188fd59a9fa22ba","comment":"Delete hexo\n","date_modified":"2020-04-14T00:37:48+09:00"}],"content_html":"<h2>Hexoによる静的サイトの構築</h2>\n<p><a href=\"https://hexo.io/\">Hexo</a>は、node.jsを使った静的サイトジェネレータ。</p>\n<p>markdown形式の記事を静的サイトに簡単に公開できる。</p>\n<h3>Hexoの導入</h3>\n<pre><code class=\"hljs language-sh\">$ npm install hexo-cli\n$ npx hexo init ../memo.yammer.jp \n$ <span class=\"hljs-built_in\">cd</span> ../memo.yammer.jp\n$ npm install\n$ hexo server\n<span class=\"hljs-comment\"># ローカルでサイトの確認</span></code></pre>\n<h3>Hexoの設定について</h3>\n<p>設定は基本的に<code>_config.yml</code>に書き込む。</p>\n<p>例えば、このサイトの<a href=\"https://github.com/yammerjp/memo.yammer.jp/blob/master/_config.yml\"><code>_config.yml</code></a>が一例。</p>\n<h3>テーマの導入</h3>\n<p>Hexoはサードパーティで公開された様々なテーマを導入できる。</p>\n<p><a href=\"https://hexo.io/themes/\">公式サイトのテーマ一覧</a>にあるように、様々なものが選べる。</p>\n<p>今回は<a href=\"https://github.com/aircloud/hexo-theme-aircloud\">air-cloud</a>を導入した。</p>\n<pre><code class=\"hljs language-sh\">$ git <span class=\"hljs-built_in\">clone</span> https://github.com/aircloud/hexo-theme-aircloud.git theme/air-cloud</code></pre>\n<p>テーマ特有の設定は、<a href=\"https://github.com/aircloud/hexo-aircloud-blog\">Demo</a>の<a href=\"https://github.com/aircloud/hexo-aircloud-blog/blob/master/_config.yml\"><code>_config.yml</code></a>が参考になる。</p>\n<h3>特別なページの設置</h3>\n<h4>自己紹介ページの追加</h4>\n<pre><code>$ npx hexo new page about\n</code></pre>\n<p><code>source/about/index.md</code>を次の内容に編集する。</p>\n<pre><code class=\"hljs language-md\">---\nlayout: about\ntitle: About Me\n<span class=\"hljs-section\">date: \"2020-03-16 11:22:00\"\n---</span>\n\n<span class=\"hljs-section\">## About Me</span>\n\nyammerjpの雑多なメモ。\n\n<span class=\"hljs-bullet\">-</span> twitter: [<span class=\"hljs-string\">@yammerjp</span>](<span class=\"hljs-link\">https://twitter.com/yammerjp</span>)\n<span class=\"hljs-bullet\">-</span> GitHub: [<span class=\"hljs-string\">@yammerjp</span>](<span class=\"hljs-link\">https://github.com/yammerjp</span>) \n<span class=\"hljs-bullet\">-</span> [<span class=\"hljs-string\">blog</span>](<span class=\"hljs-link\">https://blog.yammer.fun</span>)\n</code></pre>\n<h4>タグページの追加</h4>\n<p>次のコマンドで、tagページを作る</p>\n<pre><code class=\"hljs language-sh\">$ npx hexo new page <span class=\"hljs-string\">\"tags\"</span></code></pre>\n<p><code>source/tags/index.md</code>を次のように書き換える</p>\n<pre><code class=\"hljs language-md\">---\ntitle: All tags\ntype: \"tags\"\n--- </code></pre>\n<h4>検索機能の追加</h4>\n<pre><code class=\"hljs language-sh\">$ npm i hexo-generator-search --save</code></pre>\n<p><code>_config.yml</code>に次の内容を記載する</p>\n<div class=\"remark-code-title\">_config.yml</div>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">search:</span>\n  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">search.json</span>\n  <span class=\"hljs-attr\">field:</span> <span class=\"hljs-string\">post</span></code></pre>\n","content_text":"Hexoによる静的サイトの構築\n\nHexoは、node.jsを使った静的サイトジェネレータ。\n\nmarkdown形式の記事を静的サイトに簡単に公開できる。\n\nHexoの導入\n\n\n\nHexoの設定について\n\n設定は基本的に\\_config.ymlに書き込む。\n\n例えば、このサイトの\\_config.ymlが一例。\n\nテーマの導入\n\nHexoはサードパーティで公開された様々なテーマを導入できる。\n\n公式サイトのテーマ一覧にあるように、様々なものが選べる。\n\n今回はair-cloudを導入した。\n\n\n\nテーマ特有の設定は、Demoの\\_config.ymlが参考になる。\n\n特別なページの設置\n\n自己紹介ページの追加\n\n\n\nsource/about/index.mdを次の内容に編集する。\n\n\n\nタグページの追加\n\n次のコマンドで、tagページを作る\n\n\n\nsource/tags/index.mdを次のように書き換える\n\n\n\n検索機能の追加\n\n\n\n\\_config.ymlに次の内容を記載する\n\n"}],"version":"https://jsonfeed.org/version/1.1"}